---
layout: post
comments: true
title:  "Swift: API Design Guidelines (API 설계 지침)"
date:   2020-03-16 10:00:00 +0900
categories: Swift Language Grammar Revision History
---

## API Design Guidelines (API 설계 지침)

### Table of Contents (목차)

* [Fundamentals (기반)](#fundamentals-기반)
* [Naming](#naming-이름짓기)
- [Promote Clear Usage](#promote-clear-usage-명확한-사용법을-추구합니다)
- [Strive for Fluent Usage](#strive-for-fluent-usage-사용법이-자연스럽도록-노력합니다)
- [Use Terminology Well](#use-terminology-well-용어를-잘-사용합니다)
* Conventions
- General Conventions
- Parameters
- Argument Labels
* Special Instructions

### Fundamentals (기반)

* **사용하는 순간에 분명한 것** 이 가장 중요한 목표입니다. 메소드와 속성 같은 '개체 (entities)' 들은 한 번 선언해서 계속 반복 _사용하게 (used)_ 됩니다. 명확하고 간결하게 사용할 수 있도록 API 를 설계해야 합니다. 설계를 평가할 때, 선언을 읽고 이해하는 것으로는 충분하지 않습니다; 상황에 따라 명확하게 보일 수 있게 항상 실제 사용 사례를 검토하도록 합니다.

* **분명한 것이 간결한 것보다 더 중요합니다.** 스위프트 코드를 알차게 만들 수는 있더라도, 최소의 문자로 가능한 가장 작은 코드를 만들려고 하는 것이 _목표는-아닙니다 (non-goal)_. 스위프트 코드에서, 발생하는, 간결함이란, 강한 타입 시스템으로 인한 부수적인 효과인 것으로 획일적인 상용구를 자연스럽게 줄이는 특징을 가집니다.

* **문서화 주석 (documentation comment) 의 작성을** 모든 선언마다 합니다. 문서화를 작성하며 얻은 통찰력은 설계에 큰 영향을 줄 수 있으므로, 미루지 않도록 합니다.

API 의 기능을 간단한 용어로 설명하는 데 어려움을 겪고 있다면, **잘못된 API 를 설계하고 있는 것일 수 있습니다.**

- 스위프트 '전용 마크 다운 ([dialect of Markdown](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/))' 을 사용하기 바랍니다.

- **먼저 요약을 해서** 선언할 '개체 (entity)' 에 대한 설명을 합니다. 대체로, API 는 선언과 요약으로도 완전히 이해할 수 있습니다.

```swift
/// Returns a "view" of `self` containing the same elements in
/// reverse order.
/// 같은 원소를 반대 순서로 가지고 있는 `self` 의 "view" 를 반환합니다.
func reversed() -> ReverseCollection
```

1. **요약에 집중합니다**; 가장 중요한 부분입니다. 훌륭한 문서 주석 대부분은 사실 뛰어난 요약에 지나지 않습니다.

2. **단일한 문장 구절을**[^fragment] 가능한한 사용하며, 마침표로 끝맺습니다. 완전한 문장은 사용하지 않습니다.[^complete-sentence]

3. **함수나 메소드가 무엇을 _하는 (does)_ 지 무엇을 _반환하는 (returns)_ 지를 설명하고**, 없는 효과 (null effects) 와 `Void` 반환은 생략합니다:

```swift
/// Inserts `newHead` at the beginning of `self`.
/// `self` 의 처음 위치에 `newHead` 를 집어 넣습니다.
mutating func prepend(_ newHead: Int)

/// Returns a `List` containing `head` followed by the elements
/// of `self`.
/// 뒤에 `self` 의 원소가 있는 `head` 를 담고 있는 `List` 를 반환합니다.
func prepending(_ head: Element) -> List

/// Removes and returns the first element of `self` if non-empty;
/// returns `nil` otherwise.
/// 비어 있지 않은 경우 `self` 의 첫 번째 원소를 제거하고 반환합니다;
/// 다른 경우라면 `nil` 을 반환합니다.
mutating func popFirst() -> Element?
```

참고: 위의 `popFirst` 같이 드문 경우에 한하여, 요약을 여러 개의 문장 구절로 형성하고 세미콜론으로 구분합니다.

4. **첨자 연산 (subscript) 이 _접근하는 (accesses)_ 것이 무엇인지 설명합니다.**

```swift
/// Accesses the `index`th element.
/// `index` 번째 원소에 접근합니다.
subscript(index: Int) -> Element { get set }
```

5. **초기자가 _생성하는 (creates)_ 것이 무엇인지 설명합니다.**

```swift
/// Creates an instance containing `n` repetitions of `x`.
/// `x` 를 `n` 번 반복하여 담고 있는 인스턴스를 생성합니다.
init(count n: Int, repeatedElement x: Element)
```

6. 다른 모든 선언에 대해서는, **선언한 개체 (entity) 가 무엇 _인지 (is)_ 를 설명합니다.**

```swift
/// A collection that supports equally efficient insertion/removal
/// at any position.
/// 어떤 위치에서도 같은 효율을 가지는 삽입/제거를 지원하는 컬렉션.
struct List {

  /// The element at the beginning of `self`, or `nil` if self is
  /// empty.
  /// `self` 의 시작 위치에 있는 원소, 또는 self 가 비어 있는 경우 `nil` 입니다.
  var first: Element?
  ...
```

- **선택 사항으로, 계속하여** 하나 이상의 문단과 '목록 항목 (bullet items)' 을 둡니다. 문단은 빈 줄로 구분하며 '완전한 문장 (complete sentences)' 을 사용합니다.

```swift
/// Writes the textual representation of each    ← Summary
/// element of `items` to the standard output.
///                                              ← Blank line
/// The textual representation for each item `x` ← Additional discussion
/// is generated by the expression `String(x)`.
///
/// - Parameter separator: text to be printed    ⎫
///   between items.                             ⎟
/// - Parameter terminator: text to be printed   ⎬ Parameters section
///   at the end.                                ⎟
///                                              ⎭
/// - Note: To print without a trailing          ⎫
///   newline, pass `terminator: ""`             ⎟
///                                              ⎬ Symbol commands
/// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
///   `CustomStringConvertible`, `debugPrint`.   ⎭
public func print(
  _ items: Any..., separator: String = " ", terminator: String = "\n")

/// `items` 에 있는 각 원소에 대한 문장 형태의 표현을      ← 요약
/// 표준 출력 장치에 작성합니다.
///                                              ← 빈 줄
/// 각각의 항목 `x` 에 대한 문장 형태의 표현은            ← 추가적인 설명
/// `String(x)` 표현식으로 생성합니다.
///
/// - Parameter separator: 항목들 사이에 출력되는 문장   ⎫
/// - Parameter terminator: 맨 끝에 출력되는 문장      ⎬ 매개 변수 부분
///                                               ⎭
/// - Note: 끝자리에 '새 줄 (newline)' 없이 출력하려면   ⎫
///   `terminator: ""` 를 전달합니다                 ⎟
///                                               ⎬ 기호 명령
/// - SeeAlso: `CustomDebugStringConvertible`,    ⎟
///   `CustomStringConvertible`, `debugPrint`.    ⎭
public func print(
  _ items: Any..., separator: String = " ", terminator: String = "\n")
```

1. **인식이 되는 '기호 문서화 마크업 ([symbol documentation markup](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW1))' 원소를 사용하여**, 적당할 때마다, 요약 이외의 정보를 추가합니다.

2. '기호 명령 구문 표현 ([symbol command syntax](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW13))'[^symbol-comman-syntax] 으로 된 인식이 되는 '목록 항목 (bullet items)' 을 알아 보고 사용하도록 합니다. 'Xcode' 같은 대중적인 개발 도구들은 아래 키워드로 시작하는 '목록 항목 (bullet items)' 을 특수하게 처리합니다.

---|---|---|---
[Attention](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html)	| [Author](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Author.html) | [Authors](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Authors.html) | [Bug](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Bug.html)
[Complexity](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Complexity.html) | [Copyright](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Copyright.html)	| [Date](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Date.html) | [Experiment](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Experiment.html)
[Important](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Important.html)	| [Invariant](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Invariant.html) | [Note](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Note.html) | [Parameter](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameter.html)
[Parameters](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameters.html) | [Postcondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Postcondition.html) | [Precondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Precondition.html) | [Remark](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Remark.html)
[Requires](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html) | [Returns](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Returns.html) | [SeeAlso](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SeeAlso.html) | [Since](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Since.html)
[Throws](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Throws.html) | [ToDo](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Todo.html) | [Version](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Version.html) | [Warning](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Warning.html)

### Naming (이름짓기)

#### Promote Clear Usage (명확한 사용법을 추구합니다)

* **필요한 모든 단어를 포함시켜서** 이름이 사용된 곳의 코드를 읽을 때 모호함이 없도록 합니다.

예를 들어, '컬렉션 (collection)' 에서 주어진 위치의 원소를 제거하는 메소드를 고려해 봅시다.

```swift
// 좋은 경우
extension List {
  public mutating func remove(at position: Index) -> Element
}
employees.remove(at: x)
```

'메소드 서명 (method signature)' 에서 `at` 이라는 단어를 생략한다면, 읽는 사람이, `x` 를 제거할 원소의 위치를 지정하는데 사용하는 것이 아니라, `x` 와 같은 원소를 찾아서 제거하는 메소드라고 생각할 수 있을 것입니다.

```swift
// 안좋은 경우
employee.remove(x) // 불분명함 : x를 제거하는 것일까요?
```

* **불필요한 단어는 생략합니다.** 이름에 있는 모든 단어는 사용하는 쪽에 중요한 정보를 전달해야 합니다.

의도를 명확하게 하거나  의미의 모호함을 없애기 위해 더 많은 단어가 필요할 수 있지만, 읽는 쪽에서 이미 확보한 정보라서 과잉인 것들은 생략해야 합니다. 특히, _단순히 (merely)_ 타입 정보를 반복하는 단어는 생략합니다.

```swift
// 안좋은 경우
public mutating func removeElement(_ member: Element) -> Element?

allViews.removeElement(cancelButton)
```

이 경우, `Element` 라는 단어는 호출하는 쪽에 중요한 것은 아무 것도 추가하지 않습니다. 다음 API 가 더 좋을 것입니다:

```swift
// 좋은 경우
public mutating func remove(_ member: Element) -> Element?

allViews.remove(cancelButton) // 더 명확함
```

경우에 따라, 모호함을 피하기 위해 타입 정보를 반복하는 것도 필요하긴 하지만, 일반적으로 타입보다는 매개 변수의 _역할 (role)_ 을 설명하는 단어를 사용하는 것이 더 좋습니다. 자세한 것은 다음 항목을 참고하기 바랍니다.

* **변수, 매개 변수, 및 결합된 타입은 역할에 따라 이름을 짓되,** 타입 구속 조건으로 이름을 짓지 않도록 합니다.

```swift
// 안좋은 경우
var string = "Hello"
protocol ViewController {
  associatedtype ViewType : View
}
class ProductionLine {
  func restock(from widgetFactory: WidgetFactory)
}
```

이런 식으로 타입 이름을 재사용하면 분명함과 표현력에 대한 최적화를 실패하게 됩니다. 그 대신, '개체 (entity)' 의 _역할 (role)_ 을 표현하는 이름을 선택하려고 노력합니다.

```swift
// 좋은 경우
var greeting = "Hello"
protocol ViewController {
  associatedtype ContentView : View
}
class ProductionLine {
  func restock(from supplier: WidgetFactory)
}
```

'결합된 타입 (associated type)' 이 프로토콜 구속 조건에 너무 밀접하게 연결되어 있어서 프로토콜 이름이 역할 _인 (is)_ 경우, 프로토콜 이름에 `Protocol` 을 덧붙여서 충돌을 피하도록 합니다:

```swift
protocol Sequence {
  associatedtype Iterator : IteratorProtocol
}
protocol IteratorProtocol { ... }
```

* **타입 정보가 약할 경우 보완하여** 매개 변수의 역할을 분명하게 밝히도록 합니다.

특히 매개 변수 타입이 `NSObject`, `Any`, `AnyObject`, 또는 `Int` 및 `String` 같은 기반 타입일 때는, 사용 시점에서의 타입 정보와 상황이 의도를 온전히 전달하지 못할 수도 있습니다. 다음 예제에서, 선언은 명확하지만, 사용하는 쪽은 불분명합니다.

```swift
// 안좋은 경우
func add(_ observer: NSObject, for keyPath: String)

grid.add(self, for: graphics) // 불분명함
```

분명함을 다시 살리려면, 약한 타입인 각각의 매개 변수 앞에 역할을 설명하는 명사를 붙이도록 합니다.

```swift
// 좋은 경우
func addObserver(_ observer: NSObject, forKeyPath path: String)
grid.addObserver(self, forKeyPath: graphics) // 명확함
```

#### Strive for Fluent Usage (사용법이 자연스럽도록 노력합니다)

* **메소드와 함수 이름은 사용하는 쪽에서 문법적인 영어 문장을 형성하게끔 만들기 바랍니다.**

```swift
// 좋은 경우
x.insert(y, at: z)          “x 는, y 를 z 위치에 집어 넣습니다”
x.subViews(havingColor: y)  “x 의 하위 뷰는 y 색상을 가집니다”
x.capitalizingNouns()       “x 는 명사를 대문자로 만듭니다”
```

```swift
// 안좋은 경우
x.insert(y, position: z)
x.subViews(color: y)
x.nounCapitalize()
```

해당 인자들이 호출의 의미 중심이 아닐 때 첫 번째나 두 번째 인자 이후로 자연스러움의 감소는 받아들일 수 있습니다:

```swift
AudioUnit.instantiate(
  with: description,
  options: [.inProcess], completionHandler: stopProgressBar)
```

* **'공장 메소드 (factory methods)' 의 이름은 "`make`" 로 시작합니다.** 가령 `x.makeIterator()` 처럼 합니다.

* **초기자 및 [factory methods](https://en.wikipedia.org/wiki/Factory_method_pattern) 호출** 에 대한 첫 번째 인자는 '기본 이름 (base name)'[^base-name] 으로 시작하는 구절을 형성하지 않도록 합니다, 가령 `x.makeWidget(cogCount: 47)` 처럼 하지 않습니다.

예를 들어, 이런 호출에 대한 첫 번째 인자는 '기본 이름 (base name)' 과 같은 구절인 것으로 이해하지는 않습니다.

```swift
// 좋은 경우
let foreground = Color(red: 32, green: 64, blue: 128)
let newPart = factory.makeWidget(gears: 42, spindles: 14)
let ref = Link(target: destination)
```

다음에 있는 것들은, API 작성자가 첫 번째 인자에 '문법적인 연속성 (grammatical continuity)' 을 생성하려고 한 것입니다.

```swift
// 안좋은 경우
let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)
let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)
let ref = Link(to: destination)
```

실제로, 이 지침은 [argument labels](#argument-labels-인자-이름표) 에 대한 지침과 같이 호출이 [value preserving type conversion (값을 보존하는 타입 변환)](#type-conversion) 을 하지 않는 한 첫 번째 인자가 이름표를 가질 것임을 의미합니다.

```swift
let rgbForeground = RGBColor(cmykForeground)
```

* **함수와 메소드는 '부작용 (side-effects)'[^side-effects] 에 따라 이름을 짓습니다.**

- '부작용 (side-effects)' 이 없는 것들은, `x.distance(to: y)`, `i.successor()` 처럼, 명사구 처럼 읽혀야 합니다.

- '부작용 (side-effects)' 이 있는 것들은, `print(x)`, `x.sort()`, `x.append(y)` 처럼, '명령형 동사구 (imperative verb phrases)' 로 읽혀야 합니다.

- **변경/변경하지 않는 메소드 쌍의 이름은** 일관성이 있어야 합니다. '변경 메소드 (mutating method)' 는 때때로 비슷한 '의미 구조 (semantics)' 를 가진 '변경하지 않는 (nonmutating)' 것을 별도로 가지게 되는데, 이는 그 자리에서 인스턴스를 갱신하는 대신 새로운 값을 반환합니다.

* 연산을 **동사로 설명하는 것이 자연스러울** 때는, '변경 메소드 (mutating method)' 에 대해서 동사의 '명령형 (imperative)' 을 사용하고 이에 대응되는 '변경하지 않는 (nonmutating)' 것의 이름은 "ed" 또는 "ing" 접미사를 적용합니다.

**Mutating (변경)** | **Nonmutating (변경하지 않는)**
---|---
`x.sort()` | `z = x.sorted()`
`x.append(y)` | `z = x.appending(y)`

- 변경하지 않는 것의 이름은 (보통 "ed" 를 추가한) 동사의 '과거 분사 (past [participle](https://en.wikipedia.org/wiki/Participle)[^participle])' 를 사용하도록 합니다:

```swift
/// 그 자리에서 `self` 를 거꾸로 뒤집습니다.
mutating func reverse()

/// `self` 를 거꾸로 한 것의 복사본을 반환합니다.
func reversed() -> Self
...
x.reverse()
let y = x.reversed()
```

- 동사가 직접 목적어를 가지기 때문에 "ed" 를 추가하는 것이 문법적으로 맞지 않을 때는, 동사의 '현재 분사 [participle](https://en.wikipedia.org/wiki/Participle)' 를 사용하여, "ing" 를 덧붙여서, 변경하지 않는 것의 이름을 짓도록 합니다.

```swift
/// `self` 에서 모든 개행 문자를 벗겨냅니다.
mutating func stripNewlines()

/// `self` 에서 모든 개행 문자가 벗겨진 것의 복사본을 반환합니다.
func strippingNewlines() -> String
...
s.stripNewlines()
let oneLine = t.strippingNewlines()
```

* 연산을 **명사로 설명하는 것이 자연스러울** 때는, '변경하지 않는 메소드 (nonmutating method)' 에 대해서 명사를 사용하고 이에 대응되는 '변경하는 (nonmutating)' 것의 이름에 "form" 접두사를 적용합니다.

**Nonmutating (변경하지 않는)** | **Mutating (변경)**
---|---
`x = y.union(z)` | `y.formUnion(z)`
`j = c.successor(i)` | `c.formSuccessor(&i)`

* 사용할 때 변경되지 않는다면 **불리언 메소드와 불리언 속성은 받는 쪽에서 단언문으로 읽히도록 사용합니다** 가령 `x.isEmpty`, `line1.intersects(line2)` 같은 것이 있습니다.

* **그것이 무엇인지를 설명하는 프로토콜은 명사로 읽혀지도록 해야 합니다** (가령 `Collection` 같은 것이 있습니다).

* **_보유 능력 (capability)_ 을 설명하는 프로토콜은 `able`, `ible`, 또는 `ing` 접미사를 사용하여 이름을 지어야 합니다.** (가령 `Equatable`, `ProgressReporting` 같은 것이 있습니다).

* 그 외 다른 **타입, 속성, 변수, 및 상수는 명사로 읽혀지도록** 이름을 짓습니다.

#### Use Terminology Well (용어를 잘 사용합니다)

**Term of Art-기술 용어** _명사 (noun)_ 특정 분야 또는 직업에서 엄밀하고, 특수한 의미를 가지는 단어 또는 구절[^term-of-art]

* **애매한 용어는 피하고** 더 일반적이고 의미도 잘 전달하는 단어를 사용합니다. "피부 (skin)" 가 의도에 맞다면 굳이 "표피 (epidermis)" 라고 하지 않습니다. '기술 용어 (term of art)' 는 '핵심적인 소통 도구' 이지만, 다른 경우라면 잃어 버릴 수도 있는 '결정적인 의미 (crucial meaning)' 를 붙잡아야할 때만 사용하도록 합니다.

* **기존에 확립된 의미를 유지한 채로** 기술 용어를 사용합니다.

더 일반적인 단어 대신 '전문적인 용어 (technical term)' 를 사용하는 유일한 이유는 다른 경우라면 모호하거나 불명확한 것을 _엄밀하게 (precisely)_ 표현하기 때문입니다. 그러므로, API 는 합당한 의미에 따라 엄격하게 용어를 사용해야 합니다.

- **전문가를 놀라게 하지 않도록 합니다.**: 이미 용어에 친숙한 사람이 새로운 의미가 발명된 것을 보면 놀랍기도 하고 화가 나기도 할 것입니다.

- **초보자를 혼란스럽게 하지 않도록 합니다.**: 용어를 배우려는 사람은 웹 검색을 하게 될 것이고 전통적인 의미를 찾게 될 것입니다.

* **축약어를 피하도록 합니다.** '축약어 (abbreviations)', 특히 표준이-아닌 것은, 이해를 하려면 축약되지-않은 형태로 올바르게 번역해야만 한다는 점에서, 사실상 '기술 용어 (terms-of-art)' 인 것입니다.

> 사용한 축약어는 어떤 것이든 의도한 의미를 웹 검색으로 쉽게 찾을 수 있어야 합니다.

* **선례를 받아들이도록 합니다.** 기존 문화에 대한 준수를 희생하면서까지 완전 초보자를 위해 용어를 최적화하지는 않도록 합니다.

자료가 서로 인접해 있는 구조의 경우, 초보자라면 의미를 파악하기에 `List` 가 더 쉽더라도, `List` 라는 단순화된 용어보다 `Array` 라고 이름을 짓는 것이 더 좋습니다. '배열 (arrays)' 은 '현대의 컴퓨팅 (modern computing)' 에서 기반이므로, 모든 프로그래머가 배열이 무엇인지 알고 있거나-곧 배우게 될 것입니다. 대부분의 프로그래머에게 친숙한 용어를 사용하여, 웹 검색이나 질문을 통해 보상받을 수 있게 합니다.

수학 같은, 특정한 프로그래밍 _분야 (domain)_ 에서는 `sin(x)` 처럼 이미 널리 사용되는 용어가 `verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)`[^sin] 와 같은 설명 방식의 구절보다 더 적합합니다. 이 경우에는, 축약어를 피하라는 지침보다 선례가 더 중시된다는 점에 주목하기 바랍니다: 완전한 단어는 `sine` 일지라도, “sin(x)” 는 프로그래머 사이에서는 수십년 동안, 그리고 수학자 사이에서는 수백년 동안 일상적으로 사용된 것입니다.

### Conventions (협약)

#### General Conventions

#### Parameters

#### Argument Labels (인자 이름표)

<strong id="type-conversion">초기자에서 '값을 보존하는 타입 변환 (value preserving type conversion)' 을 하는 경우, 첫 번째 인자 이름표는 생략합니다.</strong>

### Special Instructions

### 참고 자료

[^fragment]: 여기서 '문장 구절 (sentence fragment)' 을 사용하라는 것은 완전한 문장이 아니라, 하나의 구절 형태로 사용하라는 의미입니다.

[^complete-sentence]: 왜 완전한 문장을 사용하지 않는 지에 대한 설명은 따로 없는 것 같습니다. 최대한 간단하게 핵심만 정리하라는 의미로 이해할 수 있습니다.

[^symbol-comman-syntax]: 사실 링크 자체는 바로 위에 있는 링크와 같은 문서로 연결됩니다.

[^base-name]: 여기서 '기본 이름 (base name)' 은 함수 또는 메소드의 식별자 이름을 의미하는 것이라 추측됩니다.

[^side-effects]: 컴퓨터 용어에서의 '부작용 (side-effects)' 은 무조건 나쁜 것이 아니라 '부가적인 효과' 정도의 의미로 이해할 수 있습니다.

[^participle]: 원문 자체가 위키피디아의 [participle](https://en.wikipedia.org/wiki/Participle) 항목에 대한 링크로 되어 있습니다.

[^term-of-art]: 이어지는 내용을 보면 알겠지만, 스위프트는 이런 '기술 용어 (term of art)' 대신 일상 용어를 더 많이 사용할 것을 권장하고 있습니다. 스위프트 표준 라이브러리에 있는 클래스들을 봐도, `Image` 나 `Button` 처럼, 접두사 없이 일상 용어로 타입 이름을 정하는 것을 볼 수 있습니다.

[^sin]: 'verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle' 이 말을 직역하면 '각도를 가진 반지름의 끝이 원점에 있는 단위 원 상에 있을 때의 수직 위치' 정도로 옮길 수 있습니다.
