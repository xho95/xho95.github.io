I"`v<blockquote>
  <p>Apple 에서 공개한 <a href="https://docs.swift.org/swift-book/">The Swift Programming Language (Swift 5.2)</a> 책의 <a href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html">Strings and Characters</a> 부분<sup id="fnref:Strings-and-Characters" role="doc-noteref"><a href="#fn:Strings-and-Characters" class="footnote">1</a></sup>을 번역하고 정리한 글입니다.</p>

  <p>현재 전체 중에서 번역 완료된 목록은 <a href="/swift/programming/language/grammar/2017/02/28/The-Swift-Programming-Language.html">Swift 5.2: Swift Programming Language (스위프트 프로그래밍 언어)</a> 에서 확인할 수 있습니다.</p>
</blockquote>

<h2 id="strings-and-characters-문자열과-문자">Strings and Characters (문자열과 문자)</h2>

<p><em>문자열 (string)</em> 문자가 연속되어 있는 것으로, <code class="highlighter-rouge">"hello, world"</code> 나 <code class="highlighter-rouge">"albatross"</code> 같은 것이 이에 해당합니다. 스위프트의 문자열은 <code class="highlighter-rouge">String</code> 타입으로 표현됩니다. <code class="highlighter-rouge">String</code> 의 내용물에 접근하는 방법은 <code class="highlighter-rouge">Character</code> 값의 ‘컬렉션 (collection)’<sup id="fnref:collection" role="doc-noteref"><a href="#fn:collection" class="footnote">2</a></sup> 도 포함하여 다양한 방법이 있습니다.</p>

<p>스위프트의 <code class="highlighter-rouge">String</code> 과 <code class="highlighter-rouge">Character</code> 타입은 코드에서 텍스트 작업을 할 때 빠르면서도 ‘유니코드에 부합하는 (Unicode-compliant)’ 방법을 제공합니다. 문자열을 생성하고 조작하는 구문 표현은 가볍고 이해하기 쉬우며, ‘문자열 글자표현 구문 (string literal syntax)’<sup id="fnref:string-literal-syntax" role="doc-noteref"><a href="#fn:string-literal-syntax" class="footnote">3</a></sup> 은 C 언어와 비슷합니다. 문자열 연결은 두 문자열을 <code class="highlighter-rouge">+</code> 연산자로 결합하기만 하면 될 정도로 간단하며, 문자열의 ‘가변성 (mutability)’ 은 스위프트의 다른 모든 값과 마찬가지로 상수인지 변수인지를 선택하는 것만으로 관리됩니다. 문자열을 사용하면 상수, 변수, ‘글자표현 (literals)’<sup id="fnref:literals" role="doc-noteref"><a href="#fn:literals" class="footnote">4</a></sup>, 그리고 ‘표현식 (expressions)’ 들을 더 큰 문자열에 삽입할 수도 있으며, 이 과정을 일컬어 ‘문자열 보간법 (string interpolation)’<sup id="fnref:interpolation" role="doc-noteref"><a href="#fn:interpolation" class="footnote">5</a></sup> 이라고 합니다. 이것으로 표시, 저장, 출력할 때 필요한 문자열을 아주 쉽게 만들 수 있습니다.</p>

<p>이렇게 간단한 구문 표현을 사용하면서도, 스위프트의 <code class="highlighter-rouge">String</code> 타입은 빠르고, 현대적인 문자열로 구현되었습니다. 모든 문자열은 ‘인코딩-독립적인 유니코드 문자들 (encoding-independent Unicode characters)’ 로 구성되며, 다양한 유니코드 표현식으로 해당 문자들에 대한 접근을 지원합니다.</p>

<blockquote>
  <p>스위프트의 <code class="highlighter-rouge">String</code> 타입은 ‘Foundation’ 프레임웍에 있는 <code class="highlighter-rouge">NSString</code> 클래스와 연동되어 (bridged) 있습니다. ‘Foundation’ 은 또한 <code class="highlighter-rouge">String</code> 을 확장해서 <code class="highlighter-rouge">NSString</code> 의 메소드들을 노출시킵니다. 이것은 ‘Foundation’ 을 ‘import’ 하면, ‘casting (타입 변환)’ 없이도 <code class="highlighter-rouge">String</code> 에서 <code class="highlighter-rouge">NSString</code> 메소드들 사용할 수 있음을 의미합니다.</p>

  <p>‘Foundation’ 및 ‘Cocoa’ 프레임웍과 <code class="highlighter-rouge">String</code> 을 같이 사용하는 방법에 대해서는 <a href="https://developer.apple.com/documentation/swift/string#2919514">Bridging Between String and NSString</a> 에서 더 자세히 알 수 있습니다.</p>
</blockquote>

<h3 id="string-literals-문자열-글자표현">String Literals (문자열 글자표현)</h3>

<p>미리 정의된 <code class="highlighter-rouge">String</code> 값을 코드 내에 <em>문자열 글자표현 (string literals)</em> 의 형태로 포함할 수 있습니다. ‘문자열 글자표현’ 은 큰 따옴표 (<code class="highlighter-rouge">"</code>) 로 묶인 일련의 문자들을 말합니다.</p>

<p>문자열 글자표현은 상수나 변수의 기본 설정 값으로 사용됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">someString</span> <span class="o">=</span> <span class="s">"Some string literal value"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">someString</code> 상수가 ‘문자열 글자표현 값’ 으로 초기화되었기 때문에, 스위프트가 이를 <code class="highlighter-rouge">String</code> 타입으로 추론할 수 있음을 명심하기 바랍니다.</p>

<h4 id="multiline-string-literals-여러-줄짜리-문자열-글자표현">Multiline String Literals (여러 줄짜리 문자열 글자표현)</h4>

<p>여러 줄에 걸쳐있는 문자열이 필요한 경우, ‘여러 줄짜리 문자열 글자표현 (multiline string literal)’-세 개의 큰 따옴표로 묶인 일련의 문자들-을 사용하십시오:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">quotation</span> <span class="o">=</span> <span class="s">"""
The White Rabbit put on his spectacles. "</span><span class="kt">Where</span> <span class="n">shall</span> <span class="kt">I</span> <span class="n">begin</span><span class="p">,</span>
<span class="n">please</span> <span class="n">your</span> <span class="kt">Majesty</span><span class="p">?</span><span class="s">" he asked.

"</span><span class="kt">Begin</span> <span class="n">at</span> <span class="n">the</span> <span class="n">beginning</span><span class="p">,</span><span class="s">" the King said gravely, "</span><span class="n">and</span> <span class="n">go</span> <span class="n">on</span>
<span class="n">till</span> <span class="n">you</span> <span class="n">come</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span><span class="p">;</span> <span class="n">then</span> <span class="n">stop</span><span class="o">.</span><span class="s">"
"""</span>
</code></pre></div></div>

<p>‘여러 줄짜리 문자열 글자표현’ 은 여는 따옴표와 닫는 따옴표 사이의 모든 줄도 포함합니다. 문자열은 여는 따옴표 (<code class="highlighter-rouge">"""</code>) 다음의 첫 번째 줄에서 시작하고 닫는 따옴표 앞의 줄에서 끝나며, 이는 아래에 있는 문자열은 어느 것도 ‘줄 바꿈 (line break)’ 으로 시작하거나 끝나지 않음을 의미합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">singleLineString</span> <span class="o">=</span> <span class="s">"These are the same."</span>
<span class="k">let</span> <span class="nv">multilineString</span> <span class="o">=</span> <span class="s">"""
These are the same.
"""</span>
</code></pre></div></div>

<p>‘줄 바꿈’ 으로 시작하거나 끝나는 ‘여러 줄짜리 문자열 글자표현’ 을 만들려면, 첫 줄 또는 마지막 줄에 빈 줄을 쓰면 됩니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">lineBreaks</span> <span class="o">=</span> <span class="s">"""

This string starts with a line break.
It also ends with a line break.

"""</span>
</code></pre></div></div>

<p>‘여러 줄짜리 문자열 (multiline string)’ 은 들여쓰기를 해서 주변 코드와 위치를 맞출 수 있습니다. 닫는 따옴표 (<code class="highlighter-rouge">"""</code>) 앞에 있는 공백은 스위프트가 모든 줄에서 그 만큼의 공백을 무시하도록 합니다. 하지만, 줄 맨 앞에 닫는 따옴표 앞에 있는 것보다 더 많은 공백을 입력하면, 그 공백은 문자열에 포함됩니다.</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Strings-and-Characters-indent.jpg" alt="Indentation" /></p>

<p>위의 예에서, ‘여러 줄짜리 문자열 글자표현 (multiline string literal)’ 전체가 들여쓰기되어 있지만, 문자열의 첫 줄과 마지막 줄은 공백으로 시작하지 않습니다. 가운데 줄은 닫는 따옴표보다 더 많이 들여쓰기 되어 있으므로, 이것만 추가로 4칸 들여쓰기로 시작합니다.</p>

<h4 id="special-characters-in-string-literals-문자열-글자표현-속의-특수-문자">Special Characters in String Literals (문자열 글자표현 속의 특수 문자)</h4>

<p>‘문자열 글자표현’ 은 다음의 특수 문자를 포함할 수 있습니다:</p>

<ul>
  <li>(본래의 의미를) ‘벗어난 (escaped)<sup id="fnref:escaped" role="doc-noteref"><a href="#fn:escaped" class="footnote">6</a></sup> 특수 문자’ 들, <code class="highlighter-rouge">\0</code> (null-널 문자), <code class="highlighter-rouge">\\</code> (backslash-백슬래쉬), <code class="highlighter-rouge">\t</code> (가로 tab-탭), <code class="highlighter-rouge">\n</code> (line feed-줄 먹임), <code class="highlighter-rouge">\r</code> (carriage-캐리지 리턴), <code class="highlighter-rouge">\"</code> (큰 따옴표) 그리고 <code class="highlighter-rouge">\'</code> (작은 따옴표)</li>
  <li>임의의 ‘유니코드 크기 값 (Unicode scalar<sup id="fnref:scalar" role="doc-noteref"><a href="#fn:scalar" class="footnote">7</a></sup> value)’, <code class="highlighter-rouge">\u{</code><em>n</em><code class="highlighter-rouge">}</code> 의 형태로 작성하며, 여기서 <em>n</em> 은 1~8 자리의 16진수 값입니다. (유니코드는 아래의 <a href="">Unicode</a> 에서 설명합니다.)</li>
</ul>

<p>아래의 코드에서 특수 문자에 대한 네 가지 예를 보였습니다. <code class="highlighter-rouge">wiseWords</code> 상수는 두 개의 ‘escaped (벗어난)’ 큰 따옴표를 담고 있습니다. <code class="highlighter-rouge">dollarSign</code>, <code class="highlighter-rouge">blackHeart</code> 그리고 <code class="highlighter-rouge">sparklingHeart</code> 상수는 ‘유니코드 크기 양식 (Unicode scalar format)’ 을 보여줍니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">wiseWords</span> <span class="o">=</span> <span class="s">"</span><span class="se">\"</span><span class="s">Imagination is more important than knowledge</span><span class="se">\"</span><span class="s"> - Einstein"</span>
<span class="c1">// "Imagination is more important than knowledge" - Einstein</span>
<span class="k">let</span> <span class="nv">dollarSign</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{24}</span><span class="s">"</span>         <span class="c1">// $, 유니코드 크기 값 U+0024</span>
<span class="k">let</span> <span class="nv">blackHeart</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{2665}</span><span class="s">"</span>       <span class="c1">// ♥, 유니코드 크기 값 U+2665</span>
<span class="k">let</span> <span class="nv">sparklingHeart</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{1F496}</span><span class="s">"</span>  <span class="c1">// 💖, 유니코드 크기 값 U+1F496</span>
</code></pre></div></div>

<p>‘여러 줄짜리 문자열 글자표현 (multiline string literals)’ 은 하나가 아닌 세 개의 큰 따옴표를 사용하므로, 여러 줄짜리 문자열 글자표현 안에 큰 따옴표 (<code class="highlighter-rouge">"</code>) 를 포함할 때는 ‘escaping (본래 의미를 벗어나게)’<sup id="fnref:escaping" role="doc-noteref"><a href="#fn:escaping" class="footnote">8</a></sup> 할 필요가 없습니다. 여러 줄짜리 문자열에 <code class="highlighter-rouge">"""</code> 텍스트를 포함시키려면, 최소한 하나 이상의 따옴표를 ‘escape (본래 의미를 벗어나게)’ 만들어야 합니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">threeDoubleQuotationMarks</span> <span class="o">=</span> <span class="s">"""
Escaping the first quotation mark </span><span class="se">\"</span><span class="s">""
Escaping all three quotation mark </span><span class="se">\"\"\"</span><span class="s">
"""</span>
</code></pre></div></div>

<h4 id="extended-string-delimiters-확장된-문자열-구분자">Extended String Delimiters (확장된 문자열 구분자)</h4>

<p>‘문자열 글자표현 (string literal)’ 을 <em>확장된 구분자 (extended delimiters)</em> 안에 배치하면, 문자열에 특수 문자를 포함시키면서 효과는 발현 안되게 할 수 있습니다. 이것은 문자열을 따옴표 (<code class="highlighter-rouge">"</code>) 안에 넣고, 번호 기호 (<code class="highlighter-rouge">#</code>)<sup id="fnref:number-sign" role="doc-noteref"><a href="#fn:number-sign" class="footnote">9</a></sup> 로 감싸면 됩니다. 예를 들어, ‘문자열 글자표현’ <code class="highlighter-rouge">#"Line 1\nLine 2"#</code> 를 출력하면 문자열이 두 줄로 출력되는 대신 ‘줄 바꿈 escape sequence (이스케잎 시퀀스)’인 (<code class="highlighter-rouge">\n</code>) 가 그대로 출력됩니다.</p>

<p>‘문자열 글자표현 (string literal)’ 에 있는 문자의 특수 효과를 사용하고 싶을 때는, 문자열 내에서 escape 문자 (<code class="highlighter-rouge">\</code>) 뒤에 같은 개수의 ‘번호 기호’ 를 붙여주면 됩니다. 예를 들어, 문자열이 <code class="highlighter-rouge">#"Line 1\nLine 2"#</code> 일 때, 줄을 바꾸고 싶으면 <code class="highlighter-rouge">#"Line 1\#nLine 2"#</code> 라고 하면 됩니다. 마찬가지로 <code class="highlighter-rouge">###"Line 1\###nLine 2"###</code> 라고 해도 줄 바꿈이 일어납니다.</p>

<p>‘확장된 구분자’ 로 생성한 ‘문자열 글자표현 (string literal)’ 역시 ‘여러 줄짜리 문자열 글자표현’ 이 될 수 있습니다. ‘확장된 구분자’ 를 사용하면 ‘여러 줄짜리 문자열’ 에 <code class="highlighter-rouge">"""</code> 텍스트를 넣을 수 있는데, 이 때 본래 가진 ‘글자표현 (literal) 을 끝낸다’ 는 기본 기능을 뒤엎고 (overriding), 단순히 텍스트로 넣을 수 있습니다. 예를 들면 다음과 같습니다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let threeMoreDoubleQuotationMarks = #"""
Here are three more double quotes: """
"""#
</code></pre></div></div>

<h3 id="initializing-an-empty-string-빈-문자열-초기화하기">Initializing an Empty String (빈 문자열 초기화하기)</h3>

<p>더 긴 문자열을 만들기 위한 시작점으로 빈 <code class="highlighter-rouge">String</code> 을 만들려면, 변수에 ‘빈 문자열 글자표현 (empty string literal)’ 을 할당하거나, ‘초기화 구문 표현 (initializer syntax)’ 을 써서 새로운 <code class="highlighter-rouge">String</code> 인스턴스를 초기화하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">emptyString</span> <span class="o">=</span> <span class="s">""</span>                <span class="c1">// 빈 문자열 글자 표현 (empty string literal)</span>
<span class="k">var</span> <span class="nv">anotherEmptyString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">()</span>   <span class="c1">// 초기화 구문 표현 (initializer syntax)</span>
<span class="c1">// 위 두 문자열은 모두 비어 있으며, 서로 동등합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">String</code> 값이 비어있는지 확인하려면, 불린 (Boolean) 속성인 <code class="highlighter-rouge">isEmpty</code> 를 검사하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">emptyString</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Nothing to see here"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Nothing to see here" 를 출력합니다.</span>
</code></pre></div></div>

<h3 id="string-mutability-문자열-가변성">String Mutability (문자열 가변성)</h3>

<p>특정한 <code class="highlighter-rouge">String</code> 이 수정 (또는 <em>변경-mutated</em>) 가능한지를 지정하려면, 그것을 변수에 (이러면 수정 가능함) 할당하거나, 상수에 (이러면 수정 불가능함) 할당하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">variableString</span> <span class="o">=</span> <span class="s">"Horse"</span>
<span class="n">variableString</span> <span class="o">+=</span> <span class="s">" and carriage"</span>
<span class="c1">// variableString 은 이제 "Horse and carriage" 입니다.</span>

<span class="k">let</span> <span class="nv">constantString</span> <span class="o">=</span> <span class="s">"Highlander"</span>
<span class="n">constantString</span> <span class="o">+=</span> <span class="s">" and another Highlander"</span>
<span class="c1">// 이것은 컴파일-시간에 -상수 문자열은 수정될 수 없다는 (a constant string cannot be modified -에러를 발생시킵니다.</span>
</code></pre></div></div>

<blockquote>
  <p>‘오브젝티브-C’ 와 ‘Cocoa’ 에서의 문자열 가변성 지정 방식은 좀 다른데, 이들은 두 개의 클래스 (<code class="highlighter-rouge">NSString</code> 와 <code class="highlighter-rouge">NSMutableString</code>) 중에서 선택하는 것으로써 문자열이 변할 수 있는지를 지정합니다.</p>
</blockquote>

<h3 id="strings-are-value-types-문자열은-값-타입입니다">Strings Are Value Types (문자열은 값 타입입니다)</h3>

<p>스위프트의 <code class="highlighter-rouge">String</code> 타입은 ‘<em>값 타입 (value type)</em>’<sup id="fnref:value-type" role="doc-noteref"><a href="#fn:value-type" class="footnote">10</a></sup> 입니다. 이것은 새로운 <code class="highlighter-rouge">String</code> 값을 만들고서, 이를 함수나 메소드에 전달하거나, 상수나 변수에 할당할 때, 이 <code class="highlighter-rouge">String</code> 값이 <em>복사 (copied)</em> 된다는 것을 말합니다. 각각의 경우에, 기존 <code class="highlighter-rouge">String</code> 값에 대한 새 복사본이 만들어져서, 원래 버전 대신, 이 복사본이 전달되거나 할당됩니다. 값 타입에 대해서는 <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html#ID88">Structure and Enumerations Are Value Types</a> 에 설명되어 있습니다.</p>

<p>스위프트의 <code class="highlighter-rouge">String</code> 이 ‘기본적으로-복사 (copy-by-default)’ 행동을 한다는 것은 함수나 메소드로 <code class="highlighter-rouge">String</code> 값을 전달받을 때, 어디서 왔든 신경쓸 필요 없이, 그 <code class="highlighter-rouge">String</code> 값을 온전히 가지게 됐음을 분명히 한다는 것입니다. 전달받은 문자열은 본인이 직접 수정하지 않는 이상 수정될 일이 없다고 확신헤도 됩니다.</p>

<p>한편, 스위프트의 컴파일러는 문자열 처리를 최적화하기 때문에 실제 복사는 꼭 필요할 때에만 일어납니다.<sup id="fnref:optimize-string" role="doc-noteref"><a href="#fn:optimize-string" class="footnote">11</a></sup> 이것은 값 타입인 문자열을 사용하더라도 항상 뛰어난 성능을 보장받을 수 있다는 의미입니다.</p>

<h3 id="working-with-characters-문자-다루기">Working with Characters (문자 다루기)</h3>

<p><code class="highlighter-rouge">String</code> 에 있는 개별 <code class="highlighter-rouge">Character</code> 값에 접근하려면, <code class="highlighter-rouge">for-in</code> 반복문으로 문자열에 ‘동작을 반복 적용 (interating over)’ 시키면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">character</span> <span class="k">in</span> <span class="s">"Dog!🐶"</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">character</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// D</span>
<span class="c1">// o</span>
<span class="c1">// g</span>
<span class="c1">// !</span>
<span class="c1">// 🐶</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">for-in</code> 반복문은 <a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID121">For-In Loope (For-In 반복문)</a> 에 설명되어 있습니다.</p>

<p>다른 방법으로, <code class="highlighter-rouge">Character</code> 타입 ‘주석 (annotation)’<sup id="fnref:annotation" role="doc-noteref"><a href="#fn:annotation" class="footnote">12</a></sup> 을 쓰면 ‘단일-문자 문자열 글자표현 (single-character string literal)’ 으로 독립된 <code class="highlighter-rouge">Character</code> 상수나 변수를 만들 수도 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">exclamationMark</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"!"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">String</code> 값은 초기자의 인자로 <code class="highlighter-rouge">Character</code> 값의 배열을 전달하는 것으로도 생성할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">catCharacters</span><span class="p">:</span> <span class="p">[</span><span class="kt">Character</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"C"</span><span class="p">,</span> <span class="s">"a"</span><span class="p">,</span> <span class="s">"t"</span><span class="p">,</span> <span class="s">"!"</span><span class="p">,</span> <span class="s">"🐱"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">catString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">catCharacters</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">catString</span><span class="p">)</span>
<span class="c1">// "Cat!🐱" 을 출력합니다.</span>
</code></pre></div></div>

<h3 id="concatenating-strings-and-characters-문자열-및-문자-연결하기">Concatenating Strings and Characters (문자열 및 문자 연결하기)</h3>

<p><code class="highlighter-rouge">String</code> 값을 ‘더하기 연산자 (<code class="highlighter-rouge">+</code>)’ 로 서로 더하기-또는 <em>연결 (concatenated)</em> 하여 새 <code class="highlighter-rouge">String</code> 값을 만들 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">string1</span> <span class="o">=</span> <span class="s">"hello"</span>
<span class="k">let</span> <span class="nv">string2</span> <span class="o">=</span> <span class="s">" there"</span>
<span class="k">var</span> <span class="nv">welcome</span> <span class="o">=</span> <span class="n">string1</span> <span class="o">+</span> <span class="n">string2</span>
<span class="c1">// welcome 은 이제 "hello there" 와 같습니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">String</code> 값을 ‘더하고 할당하기 연산자 (<code class="highlighter-rouge">+=</code>)’ 로 기존 <code class="highlighter-rouge">String</code> 변수에 덧붙일 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">instruction</span> <span class="o">=</span> <span class="s">"look over"</span>
<span class="n">instruction</span> <span class="o">+=</span> <span class="n">string2</span>
<span class="c1">// instruction 은 이제 "look over there" 와 같습니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Character</code> 값을 <code class="highlighter-rouge">String</code> 변수에 덧붙이려면 <code class="highlighter-rouge">String</code> 타입의 <code class="highlighter-rouge">append()</code> 메소드를 사용하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">exclamationMark</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"!"</span>
<span class="n">welcome</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">exclamationMark</span><span class="p">)</span>
<span class="c1">// welcome 은 이제 "hello there!" 와 같습니다.</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">String</code> 이나 <code class="highlighter-rouge">Character</code> 를 기존 <code class="highlighter-rouge">Character</code> 변수에 덧붙일 수는 없으며, 이는 <code class="highlighter-rouge">Character</code> 값은 반드시 단 하나의 문자만 가질 수 있기 때문입니다.</p>
</blockquote>

<p>‘여러 줄짜리 문자열 글자표현’ 으로 더 긴 줄의 문자열을 만들 때, 문자열의 모든 줄이 마지막 줄도 포함해서, 줄 바꿈으로 끝나기를 원할 것입니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">basStart</span> <span class="o">=</span> <span class="s">"""
one
two
"""</span>

<span class="k">let</span> <span class="nv">end</span> <span class="o">=</span> <span class="s">"""
three
"""</span>

<span class="nf">print</span><span class="p">(</span><span class="n">basStart</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span>
<span class="c1">// 다음의 두 줄을 출력합니다:</span>
<span class="c1">// one</span>
<span class="c1">// twothree</span>

<span class="k">let</span> <span class="nv">goodStart</span> <span class="o">=</span> <span class="s">"""
one
two

"""</span>

<span class="nf">print</span><span class="p">(</span><span class="n">goodStart</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span>
<span class="c1">// 다음의 세 줄을 출력합니다:</span>
<span class="c1">// one</span>
<span class="c1">// two</span>
<span class="c1">// three</span>
</code></pre></div></div>

<p>위의 코드에서, <code class="highlighter-rouge">badStart</code> 와 <code class="highlighter-rouge">end</code> 를 연결하니 두 줄짜리 문자열이 만들어졌는데, 이는 원하는 결과가 아닙니다. 왜냐면 <code class="highlighter-rouge">badStart</code> 의 마지막 줄이 줄 바꿈으로 끝나지 않아서, 그 줄이 <code class="highlighter-rouge">end</code> 의 첫 줄과 붙어버렸기 때문입니다. 이와는 다르게, <code class="highlighter-rouge">goodStart</code> 의 두 줄은 모두 줄 바꿈으로 끝나므로, <code class="highlighter-rouge">end</code> 와 결합해도 결과는 예상한 대로 세 줄이 됩니다.</p>

<h3 id="string-interpolation-문자열-보간법">String Interpolation (문자열 보간법)</h3>

<p><em>문자열 보간법 (string interpolation)</em> 은 상수, 변수, 글자표현, 그리고 표현식들을 서로 섞어서 새로운 <code class="highlighter-rouge">String</code> 값을 생성하는 방법으로, 이 때 ‘문자열 글자표현 (string literal)’ 안에 그 값을 포함하는 방식을 사용합니다. 문자열 보간법은 한 줄짜리 혹은 여러 줄짜리 ‘문자열 글자표현 (string literal)’ 모두에서 사용 가능합니다. 각 요소를 문자열 글자표현에 삽입하려면 그것을 괄호 쌍으로 감싼 후에 맨 앞에 ‘백 슬래쉬 (<code class="highlighter-rouge">\</code>)’ 를 붙여주면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">multiplier</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">let</span> <span class="nv">message</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">multiplier</span><span class="se">)</span><span class="s"> times 2.5 is </span><span class="se">\(</span><span class="kt">Double</span><span class="p">(</span><span class="n">multiplier</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.5</span><span class="se">)</span><span class="s">"</span>
<span class="c1">// message 는 "3 times 2.5 is 7.5" 입니다.</span>
</code></pre></div></div>

<p>위의 예에서 처럼, <code class="highlighter-rouge">multiplier</code> 의 값을 ‘문자열 글자표현’ 에 삽입하려면 <code class="highlighter-rouge">\(multiplier)</code> 라고 하면 됩니다. 이것이 있는 자리는 <code class="highlighter-rouge">multiplier</code> 의 실제 값으로 교체되는데, 이는 실제 문자열을 생성하려고 ‘문자열 보간’ 값을 퍙가할 때 이뤄집니다.</p>

<p><code class="highlighter-rouge">multiplier</code> 는 문자열에 나오는 ‘더 큰 표현식’ 의 일부이기도 합니다. 이 표현식은 <code class="highlighter-rouge">Double(multiplier) * 2.5</code> 의 값을 계산한 후 결과인 (<code class="highlighter-rouge">7.5</code>) 를 문자열에 삽입합니다. 이 경우, 표현식을 ‘문자열 글자표현’ 안에 넣으려면 <code class="highlighter-rouge">\(Double(multiplier) * 2.5)</code> 라고 하면 됩니다.</p>

<p>‘확장된 문자열 구분자 (extended string delimiters)’ 를 사용하면 ‘문자열 보간법’ 으로 취급되는 문자를 그대로 담고 있는 문자열도 만들 수 있습니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="err">#</span><span class="s">"Write an interpolated string in Swift using </span><span class="se">\(</span><span class="n">multiplier</span><span class="se">)</span><span class="s">."</span><span class="err">#</span><span class="p">)</span>
<span class="c1">// "Write an interpolated string in Swift using \(multiplier)." 를 출력합니다.</span>
</code></pre></div></div>

<p>‘확장된 구분자’ 를 사용하는 문자열 내에서 ‘문자열 보간법’ 을 사용하려면, 문자열의 시작과 끝에 있는 ‘번호 기호’ 의 개수와 같은 ‘번호 기호’ 를 백 슬래시 뒤에 붙이면 됩니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="err">#</span><span class="s">"6 times 7 is </span><span class="err">\</span><span class="s">#(6 * 7)."</span><span class="err">#</span><span class="p">)</span>
<span class="s">"6 times 7 is 42."</span> <span class="n">를</span> <span class="n">출력합니다</span><span class="o">.</span>
</code></pre></div></div>

<blockquote>
  <p>보간된 문자열 내에서 괄호 안의 표현식은 ‘unescaped (벗어나지 않은)’ 백슬래시 (<code class="highlighter-rouge">\</code>), 캐리지 리턴 (<code class="highlighter-rouge">\r</code>), 또는 줄 바꿈 (<code class="highlighter-rouge">\n</code>) 을 포함할 수 없습니다. 그러나, 다른 ‘문자열 글자표현 (string literals)’ 은 포함할 수 있습니다.</p>
</blockquote>

<h3 id="unicode-유니코드">Unicode (유니코드)</h3>

<p><em>유니코드 (Unicode)</em> 는 서로 다른 ‘문자 (writing system)’ 끼리 텍스트를 ‘부호화하고 (encoding)’, 표현하며, 처리하는 국제 표준입니다. 이를 통해 어떤 언어로도 거의 모든 문자를 표준화된 형태로 표현할 수 있으며, 텍스트 파일이나 웹 페이지와 같은 외부 소스에서 그 문자를 읽고 쓸 수 있게 됩니다. 스위프트의 <code class="highlighter-rouge">String</code> 과 <code class="highlighter-rouge">Character</code> 타입은 완전히 유니코드에 부합하며 (Unicode-compliant), 이번 장에서 그것을 확인할 수 있습니다.</p>

<h4 id="unicode-scalars-유니코드-크기-값">Unicode Scalars (유니코드 크기 값)</h4>

<p>속을 들여다보면, 본래 스위프트의 <code class="highlighter-rouge">String</code> 타입은 <em>유니코드 크기 값 (Unicode scalar value)</em> 으로 만들어져 있습니다. ‘유니코드 크기 값’ 은 하나의 문자 또는 ‘수정자 (modifier)’ 에 대해 유일하게 지정된 21-bit 수를 말하여, 가령 <code class="highlighter-rouge">U+0061</code> 은 <code class="highlighter-rouge">LATIN SMALL LETTER A</code> (<code class="highlighter-rouge">"a"</code>), 또 <code class="highlighter-rouge">U+1F425</code> 는 <code class="highlighter-rouge">FRONT-FACING BABY CHICK</code> (<code class="highlighter-rouge">"🐥"</code>) 입니다.</p>

<p>모든 21-bit ‘유니코드 크기 값’ 에 문자가 할당되어 있는 것은 아님을 명심하기 바랍니다-일부 크기 값은 미래에 할당될 때나 UTF-16 부호화 (encoding) 에 사용될 때를 대비해서 예약되어 있습니다. 문자에 할당된 ‘크기 값 (scalar values)’ 은 보통 이름을 가지고 있으며, 위에서 <code class="highlighter-rouge">LATIN SMALL LETTER A</code> 와 <code class="highlighter-rouge">FRONT-FACING BABY CHICK</code> 이 그런 예입니다.</p>

<h4 id="extended-grapheme-clusters-확장된-자소-덩어리">Extended Grapheme Clusters (확장된 자소 덩어리)</h4>

<p>스위프트 <code class="highlighter-rouge">Character</code> 타입의 모든 인스턴스는 하나의 단일한 <em>확장된 자소 덩어리 (extended grapheme cluster)</em> 를 표현합니다.<sup id="fnref:extended-grapheme-cluster" role="doc-noteref"><a href="#fn:extended-grapheme-cluster" class="footnote">13</a></sup> ‘확장된 자소 덩어리’ 는 하나 이상의 유니코드 크기 값이 연속되어 있는 것으로 (서로 결합하면) 사람이 읽을 수 있는 단일한 문자를 만들어 냅니다.</p>

<p>여기 예를 들어 보겠습니다. 문자 <code class="highlighter-rouge">é</code> 는 단일한 유니코드 크기 값 <code class="highlighter-rouge">é</code> (<code class="highlighter-rouge">LATIN SMALL LETTER E WITH ACUTE</code>, 또는 <code class="highlighter-rouge">U+00E9</code>) 로 표현될 수 있습니다. 하지만, 같은 문자를 한 <em>쌍 (pair)</em> 의 ‘크기 값 (scalars)’ 으로도 표시 할 수 있습니다-표준 문자 <code class="highlighter-rouge">e</code> (<code class="highlighter-rouge">LATIN SMALL LETTER E</code>, 또는 <code class="highlighter-rouge">U+0065</code>), 에다가 <code class="highlighter-rouge">COMBINING ACUTE ACCENT</code> 크기 값 (<code class="highlighter-rouge">U+0301</code>) 를 뒤에 붙인 것 말입니다. <code class="highlighter-rouge">COMBINING ACUTE ACCENT</code> 크기 값은 그 앞에 오는 크기 값의 모양을 바꾸는 역할을 하며, 유니코드-인식 글자-표현 시스템에 의해 <code class="highlighter-rouge">e</code> 를 <code class="highlighter-rouge">é</code> 로 바꾸게 됩니다.</p>

<p>두 경우에서 문자 <code class="highlighter-rouge">é</code> 는 스위프트에서 ‘확장된 자소 덩어리’ 를 표현하는 단일한 <code class="highlighter-rouge">Character</code> 값을 나타냅니다. 첫 번째에서는, 덩어리가 단일한 크기 값을 갖고 있고; 두 번째에서는 덩어리가 두 개의 크기 값을 갖고 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">eAcute</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{E9}</span><span class="s">"</span>                <span class="c1">// é</span>
<span class="k">let</span> <span class="nv">combinedEAcute</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{65}\u{301}</span><span class="s">"</span> <span class="c1">// e followed by ́</span>
<span class="c1">// eAcute 는 é 이고, combinedEAcute 는 é 입니다.</span>
</code></pre></div></div>

<p>‘확장된 자소 덩어리 (extended grapheme clusters)’ 라는 유연한 방법 덕분에 문자 표기법이 많고 복잡하더라도 이를 단일한 <code class="highlighter-rouge">Character</code> 값으로 표현할 수 있게 되었습니다. 예를 들어, 한글로 한국어 음절을 표현하는 방식은 ‘완성형 (precomposed)’ 과 ‘조합형 (decomposed)’ 두 가지가 있습니다. 스위프트에서는 이 두 표현 방식 모두 단일한 <code class="highlighter-rouge">Character</code> 값으로인정받습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">precomposed</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{D55C}</span><span class="s">"</span>                 <span class="c1">// 한</span>
<span class="k">let</span> <span class="nv">decomposed</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{1112}\u{1161}\u{11AB}</span><span class="s">"</span>  <span class="c1">// ᄒ, ᅡ, ᆫ</span>
<span class="c1">// precomposed 는 '한' 이고, decomposed 도 '한' 입니다.</span>
</code></pre></div></div>

<p>‘확장된 자소 덩어리’ 를 사용하면 테두리 기호 (가령 <code class="highlighter-rouge">COMBINING ENCLOSING CIRCLE</code>, 또는 <code class="highlighter-rouge">U+20DD</code>) 크기 값으로 다른 유니코드 크기 값에 테두리를 만들어서 하나의 단일한 <code class="highlighter-rouge">Character</code> 값을 만드는 것도 가능합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">enclosedEAcute</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{E9}\u{20DD}</span><span class="s">"</span>
<span class="c1">// enclosedEAcute 은 é⃝ 입니다.</span>
</code></pre></div></div>

<p>‘지역 표시 기호’ 에 대한 유니코드 크기 값 한 쌍을 결합해서 하나의 단일한 <code class="highlighter-rouge">Character</code> 값을 만들 수 있는데, 가령 <code class="highlighter-rouge">REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA)</code> 와 <code class="highlighter-rouge">REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8)</code> 를 결합하면 아래와 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">regionalIndicatorForUS</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{1F1FA}\u{1F1F8}</span><span class="s">"</span>
<span class="c1">// regionalIndicatorForUS is 🇺🇸</span>
</code></pre></div></div>

<h3 id="counting-characters-문자-개수-살리기">Counting Characters (문자 개수 살리기)</h3>

<p>문자열에 있는 <code class="highlighter-rouge">Character</code> 의 개수를 구하려면, 문자열의 <code class="highlighter-rouge">count</code> 속성을 사용하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">unusualMenagerie</span> <span class="o">=</span> <span class="s">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"unusualMenagerie has </span><span class="se">\(</span><span class="n">unusualMenagerie</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s"> characters"</span><span class="p">)</span>
<span class="c1">// "unusualMenagerie has 40 characters" 를 출력합니다.</span>
</code></pre></div></div>

<p>스위프트에서는 <code class="highlighter-rouge">Character</code> 값으로 ‘확장된 자소 덩어리’ 를 사용하므로 문자열을 연결하거나 수정하더라도 문자열의 문자 개수가 변하지 않을 수도 있다는 점을 명심하기 바랍니다.</p>

<p>예를 들어, 새로운 문자열을 4-개의 글자로 된 단어 <code class="highlighter-rouge">cafe</code> 로 초기화한 후, 문자열 끝에 <code class="highlighter-rouge">COMBINING ACUTE ACCENT</code> (<code class="highlighter-rouge">U+0301</code>) 를 덧붙이면, 그 결과 문자열의 글자 개수는 여전히 <code class="highlighter-rouge">4</code> 개이며, 네 번째 문자는 <code class="highlighter-rouge">e</code> 대신 <code class="highlighter-rouge">é</code> 가 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">word</span> <span class="o">=</span> <span class="s">"cafe"</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"the number of characters in </span><span class="se">\(</span><span class="n">word</span><span class="se">)</span><span class="s"> is </span><span class="se">\(</span><span class="n">word</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// "the number of characters in cafe is 4" 를 출력합니다.</span>

<span class="n">word</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\u{301}</span><span class="s">"</span>       <span class="c1">// COMBINING ACUTE ACCENT, U+0301</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"the number of characters in </span><span class="se">\(</span><span class="n">word</span><span class="se">)</span><span class="s"> is </span><span class="se">\(</span><span class="n">word</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="c1">// "the number of characters in café is 4" 를 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p>확장된 자소 덩어리 (extended grapheme clusters) 는 여러 가지의 유니코드 크기 값들로 구성 될 수 있습니다. 이것은 다른 문자들-그리고 같은 문자에 대한 다른 표현 방법들-을 저장할 때 메모리의 크기가 다를 수도 있다는 것을 의미합니다. 이러한 이유로, 스위프트의 문자들은 각각이 문자열 내에서 같은 크기의 메모리를 차지하고 있지 않습니다. 그 결과, 문자열의 문자 개수를 계산하려면 문자열 전체에 동작을 반복하는 과정이 반드시 필요하며, 이는 확장된 자소 덩어리의 경계를 알아야 하기 때문입니다. 특히 긴 문자열을 사용하면서 <code class="highlighter-rouge">count</code> 속성을 사용하게 되면, 문자열의 문자 개수를 구하기 위해 전체 문자열에 있는 유니코드 크기 값을 구하는 동작을 반복하게 된다는 것을 알고 있어야 합니다.</p>

  <p><code class="highlighter-rouge">count</code> 속성이 반환하는 문자 개수는 같은 문자들을 갖고 있는 <code class="highlighter-rouge">NSString</code> 의 <code class="highlighter-rouge">length</code> (길이) 속성과 다를 수도 있습니다. <code class="highlighter-rouge">NSString</code> 의 길이 값은 문자열의 UTF-16 표현 방식에 있는 ‘16-비트 코드 단위’ 의 개수를 기반으로 한 것이며 문자열에 있는 유니코드 방식의 ‘확장된 자소 덩어리’ 개수가 아닙니다.</p>
</blockquote>

<h3 id="accessing-and-modifying-a-string-문자열에-접근하고-수정하기">Accessing and Modifying a String (문자열에 접근하고 수정하기)</h3>

<p>문자열에 접근하고 수정하려면, 문자열의 메소드와 속성, 또는 ‘첨자 연산 구문 (subscript syntax)’ 을 사용하면 됩니다.</p>

<h4 id="string-indices-문자열-색인">String Indices (문자열 색인)</h4>

<p>각각의 <code class="highlighter-rouge">String</code> 값은 관련된 색인 타입인 <code class="highlighter-rouge">String.Index</code> 을 가지고 있는데, 이 값은 문자열에서 각 <code class="highlighter-rouge">Character</code> 의 위치에 해당합니다.</p>

<p>앞에서 언급했듯이, 서로 다른 문자들을 저장할 때의 메모리 양이 서로 다를 수 있으므로, 특정 위치에 있는 <code class="highlighter-rouge">Character</code> 가 무엇인지 판별하려면, 문자열의 처음부터 끝까지 각 ‘유니코드 크기 값’ 을 뒤지는 동작을 반복 적용해야만 합니다. 이러한 이유로, 스위프트의 문자열은 정수 값의 색인을 가질 수 없습니다.</p>

<p><code class="highlighter-rouge">String</code> 의 첫 번째에 위치한 <code class="highlighter-rouge">Character</code> 에 접근하려면 <code class="highlighter-rouge">startIndex</code> 속성을 사용해야 합니다. <code class="highlighter-rouge">endIndex</code> 속성은 <code class="highlighter-rouge">String</code> 에서 마지막 문자의 그 다음 위치를 가리킵니다. 따라서 <code class="highlighter-rouge">endIndex</code> 속성은 문자열의 ‘첨자 연산 (subscript)’ 인자로 유효하지 않습니다. <code class="highlighter-rouge">String</code> 이 비어있으면, <code class="highlighter-rouge">startIndex</code> 와 <code class="highlighter-rouge">endIndex</code> 이 같습니다.</p>

<p>주어진 색인 전후의 색인에 접근하려면 <code class="highlighter-rouge">String</code> 에 있는 <code class="highlighter-rouge">index(before:)</code> 와 <code class="highlighter-rouge">index(after:)</code> 메소드를 사용하기 바랍니다. 주어진 색인에서 멀리 떨어진 색인에 접근하려면, 앞서의 메소드들을 여러 번 호출하는 대신 <code class="highlighter-rouge">index(_:offsetBy:)</code> 메소드를 사용하면 됩니다.</p>

<p>‘첨자 연산 구문 (subscript syntax)’ 을 사용하여 특정 <code class="highlighter-rouge">String</code> 색인에 있는 <code class="highlighter-rouge">Character</code> 에 접근할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">greeting</span> <span class="o">=</span> <span class="s">"Guten Tag!"</span>
<span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="o">.</span><span class="n">startIndex</span><span class="p">]</span>
<span class="c1">// G</span>
<span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="nv">before</span><span class="p">:</span> <span class="n">greeting</span><span class="o">.</span><span class="n">endIndex</span><span class="p">)]</span>
<span class="c1">// !</span>
<span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="nv">after</span><span class="p">:</span> <span class="n">greeting</span><span class="o">.</span><span class="n">startIndex</span><span class="p">)]</span>
<span class="c1">// u</span>
<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">greeting</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="n">greeting</span><span class="o">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">greeting</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="c1">// a</span>
</code></pre></div></div>

<p>문자열 범위 밖의 색인이나 문자열 범위 밖의 색인에 있는 <code class="highlighter-rouge">Character</code> 에 접근하려고 시도하면 ‘runtime error (실행시간에 에러)’ 를 띄웁니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// greeting[greeting.endIndex]  // 에러</span>
<span class="c1">// greeting.index(after: greeting.endIndex) // 에러</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">indices</code> 속성을 사용하면 문자열에 있는 개별 문자의 모든 색인에 접근할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="n">greeting</span><span class="o">.</span><span class="n">indices</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">greeting</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "G u t e n   T a g ! " 를 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">startIndex</code> 와 <code class="highlighter-rouge">endIndex</code> 속성들 및 <code class="highlighter-rouge">index(before:)</code>, <code class="highlighter-rouge">index(after:)</code> 와 <code class="highlighter-rouge">index(_:offsetBy:)</code> 메소드들은 <code class="highlighter-rouge">Collection</code> 프로토콜을 준수하기만 하면 어떤 타입에서도 사용할 수 있습니다. 여기에는 지금까지 설명한 <code class="highlighter-rouge">String</code> 외에도 <code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">Dictionary</code> 그리고 <code class="highlighter-rouge">Set</code> 같은 컬렉션 타입들이 포함됩니다.</p>
</blockquote>

<h4 id="inserting-and-removing-삽입하고-제거하기">Inserting and Removing (삽입하고 제거하기)</h4>

<p>단일 문자를 문자열의 지정된 색인 위치에 삽입하려면, <code class="highlighter-rouge">insert(_:at:)</code> 메소드를 사용하고, 다른 문자열 ‘내용 (contents)’ 을 지정된 색인 위치에 삽입하려면, <code class="highlighter-rouge">insert(contentsOf:at:)</code> 메소드를 사용합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">welcome</span> <span class="o">=</span> <span class="s">"hello"</span>
<span class="n">welcome</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="s">"!"</span><span class="p">,</span> <span class="nv">at</span><span class="p">:</span> <span class="n">welcome</span><span class="o">.</span><span class="n">endIndex</span><span class="p">)</span>
<span class="c1">// welcome 은 이제 "hello!" 와 같습니다.</span>

<span class="n">welcome</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nv">contentsOf</span><span class="p">:</span> <span class="s">" there"</span><span class="p">,</span> <span class="nv">at</span><span class="p">:</span> <span class="n">welcome</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="nv">before</span><span class="p">:</span> <span class="n">welcome</span><span class="o">.</span><span class="n">endIndex</span><span class="p">))</span>
<span class="c1">// welcome 은 이제 "hello there!" 와 같습니다.</span>
</code></pre></div></div>

<p>문자열에서 지정된 색인 위치의 단일 문자를 제거하려면, <code class="highlighter-rouge">remove(at:)</code> 메소드를 사용하고, 지정된 범위에 있는 ‘하위 문자열 (substring)’ 을 제거하려면, <code class="highlighter-rouge">removeSubrange(_:)</code> 메소드를 사용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">welcome</span><span class="o">.</span><span class="nf">remove</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">welcome</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="nv">before</span><span class="p">:</span> <span class="n">welcome</span><span class="o">.</span><span class="n">endIndex</span><span class="p">))</span>
<span class="c1">// welcome 은 이제 "hello there" 와 같습니다.</span>

<span class="k">let</span> <span class="nv">range</span> <span class="o">=</span> <span class="n">welcome</span><span class="o">.</span><span class="nf">index</span><span class="p">(</span><span class="n">welcome</span><span class="o">.</span><span class="n">endIndex</span><span class="p">,</span> <span class="nv">offsetBy</span><span class="p">:</span> <span class="o">-</span><span class="mi">6</span><span class="p">)</span><span class="o">..&lt;</span><span class="n">welcome</span><span class="o">.</span><span class="n">endIndex</span>
<span class="n">welcome</span><span class="o">.</span><span class="nf">removeSubrange</span><span class="p">(</span><span class="n">range</span><span class="p">)</span>
<span class="c1">// welcome 은 이제 "hello" 와 같습니다.</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">insert(_:at:)</code>, <code class="highlighter-rouge">insert(contentsOf:at:)</code>, <code class="highlighter-rouge">remove(at:)</code>, 그리고 <code class="highlighter-rouge">removeSubrange(_:)</code> 메소드들은 <code class="highlighter-rouge">RangeReplaceableCollection</code> 프로토콜을 준수하기만 하면 어떤 타입에서도 사용할 수 있습니다. 여기에는 지금까지 설명한 <code class="highlighter-rouge">String</code> 외에도 <code class="highlighter-rouge">Array</code>, <code class="highlighter-rouge">Dictionary</code> 그리고 <code class="highlighter-rouge">Set</code> 같은 컬렉션 타입들이 포함됩니다.</p>
</blockquote>

<h3 id="substrings-하위-문자열">Substrings (하위 문자열)</h3>

<p>문자열에서 ‘하위 문자열 (substring)’ 을 가져오면-예를 들어, 첨자 연산이나 <code class="highlighter-rouge">prefix(_:)</code> 같은 메소드를 쓸 경우-그 결과는 하나의 <a href="https://developer.apple.com/documentation/swift/substring">Substring</a> 인스턴스이며, 또 다른 문자열 (타입) 인 것이 아닙니다. 스위프트의 ‘하위 문자열 (substring)’ 은 ‘문자열 (string)’ 과 거의 같은 메소드를 가지고 있기 때문에, 하위 문자열을 문자열을 쓰듯이 작업할 수 있긴 합니다. 하지만, 문자열과는 달리, 하위 문자열로 문자열 작업을 수행할 때는 짧은 시간 동안만 사용하도록 합니다. 결과를 더 오랜 시간동안 저장하려고 한다면, 하위 문자열을 <code class="highlighter-rouge">String</code> 인스턴스로 변환하도록 합니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">greeting</span> <span class="o">=</span> <span class="s">"Hello, world!"</span>
<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="n">greeting</span><span class="o">.</span><span class="nf">firstIndex</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="s">","</span><span class="p">)</span> <span class="p">??</span> <span class="n">greeting</span><span class="o">.</span><span class="n">endIndex</span>
<span class="k">let</span> <span class="nv">beginning</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="o">..&lt;</span><span class="n">index</span><span class="p">]</span>
<span class="c1">// beginning 은 "Hello" 입니다.</span>

<span class="c1">// 오래 저장하기 위해 결과를 String 으로 변환합니다.</span>
<span class="k">let</span> <span class="nv">newString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">beginning</span><span class="p">)</span>
</code></pre></div></div>

<p>문자열과 마찬가지로, 각각의 하위 문자열은 그 하위 문자열을 구성하는 문자들을 저장하는 메모리 영역이 있습니다. 문자열과 하위 문자열의 차이점은, 성능 최적화로 인해, 하위 문자열은 원래 문자열 또는 다른 하위 문자열이 저장된 메모리의 일부를 재사용할 수도 있다는 것입니다. (문자열도 비슷한 최적화 기능을 갖고 있지만, 두 문자열이 메모리를 공유할 때는, 서로 같을 때 뿐입니다.) 이러한 성능 최적화가 의미하는 것은 문자열이나 하위 문자열의 경우 수정하기 전까지는 메모리를 복사하는데 드는 성능 비용을 신경쓰지 않아도 된다는 점입니다. 앞서 언급한 대로, 하위 문자열은 오랜-기간 저장하는 용도로는 적합하지 않습니다-이는 원래 문자열의 저장 공간을 재사용할 경우, 하위 문자열을 사용하는 한 원래 문자열 전체에 대한 메모리를 계속 유지해야만 하기 때문입니다.</p>

<p>위의 예에서, <code class="highlighter-rouge">greeting</code> 은 문자열이므로, 이를 구성하는 문자들을 저장하는 메모리 영역을 가지고 있습니다. <code class="highlighter-rouge">beginning</code> 은 <code class="highlighter-rouge">greeting</code> 의 하위 문자열이라서, <code class="highlighter-rouge">greeting</code> 이 가지고 있는 메모리를 재사용합니다. 이와는 다르게, <code class="highlighter-rouge">newString</code> 은 하나의 문자열로-하위 문자열을 이용해서 생성될 때, 자신만의 저장 공간을 가집니다. 이 관계는 아래 그림과 같습니다:</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Strings-and-Characters-indent.jpg" alt="Indentation" /></p>

<blockquote>
  <p><code class="highlighter-rouge">String</code> 과 <code class="highlighter-rouge">Substring</code> 은 모두 <a href="https://developer.apple.com/documentation/swift/stringprotocol">StringProtocol</a> 프로토콜을 준수하는데, 이는 <code class="highlighter-rouge">StringProtocol</code> 값을 전달받는 ‘문자열 조작 함수 (string manipulation functions)’ 를 쓰는 것이 편할 때가 많다는 것을 의미합니다. 이러한 함수는 <code class="highlighter-rouge">String</code> 이나 <code class="highlighter-rouge">Substring</code> 값에 상관없이 호출할 수 있습니다.</p>
</blockquote>

<h3 id="comparing-strings-문자열-비교하기">Comparing Strings (문자열 비교하기)</h3>

<p>스위프트는 ‘글자 형태의 값 (textual values)’ 을 비교하는 다음의 세 가지 방법을 제공합니다: ‘문자열과 문자 동등성 (string and character equality)’, ‘접두사 동등성 (prefix equality)’, ‘접미사 동등성 (suffix equality)’.</p>

<h4 id="string-and-character-equality-문자열-동등성-및-문자-동등성">String and Character Equality (문자열 동등성 및 문자 동등성)</h4>

<p>문자열 동등성 및 문자의 동등성은 “같음” 연산자 (<code class="highlighter-rouge">==</code>) 와 “같지 않음” 연산자 (<code class="highlighter-rouge">!=</code>) 로 검사하며, 이는 <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID70">Comparison Operators</a> 에서 설명한 바 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">quotation</span> <span class="o">=</span> <span class="s">"We're a lot alike, you and I."</span>
<span class="k">let</span> <span class="nv">sameQuotation</span> <span class="o">=</span> <span class="s">"We're a lot alike, you and I."</span>
<span class="k">if</span> <span class="n">quotation</span> <span class="o">==</span> <span class="n">sameQuotation</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"These two strings are considered equal"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "These two strings are considered equal." 을 출력합니다.</span>
</code></pre></div></div>

<p>두 개의 <code class="highlighter-rouge">String</code> 값 (또는 두 개의 <code class="highlighter-rouge">Character</code> 값) 은 그들의 ‘확장된 자소 덩어리 (extended grapheme clusters)’ 가 <em>법적으로 동등하면 (canonically equivalent)</em> 서로 같다고 여겨집니다. 확장된 자소 덩어리가 법적으로 동등하다는 말은, 그들이 실제로는 서로 다른 ‘유니코드 크기 값’ 으로 구성되었더라도, 언어적인 의미와 형태가 같다면 동등하다는 말입니다.</p>

<p>예를 들어, <code class="highlighter-rouge">LATIN SMALL LETTER E WITH ACUTE</code> (<code class="highlighter-rouge">U+00E9</code>) 는 <code class="highlighter-rouge">LATIN SMALL LETTER E</code> (<code class="highlighter-rouge">U+0065</code>) 뒤에 <code class="highlighter-rouge">COMBINING ACUTE ACCENT</code> (<code class="highlighter-rouge">U+0301</code>) 가 붙은 것과 법적으로 동등합니다. 이 두 개의 ‘확장된 자소 덩어리’ 는 모두 문자 <code class="highlighter-rouge">é</code> 를 표현하는 유효한 방법이므로, 법적으로 동등하다고 볼 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</span>
<span class="k">let</span> <span class="nv">eAcuteQuestion</span> <span class="o">=</span> <span class="s">"Voulez-vous un caf</span><span class="se">\u{E9}</span><span class="s">?"</span>

<span class="c1">// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span>
<span class="k">let</span> <span class="nv">combinedEAccuteQuestion</span> <span class="o">=</span> <span class="s">"Voulez-vous un caf</span><span class="se">\u{65}\u{301}</span><span class="s">?"</span>

<span class="k">if</span> <span class="n">eAcuteQuestion</span> <span class="o">==</span> <span class="n">combinedEAccuteQuestion</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"These two strings are considered equal"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "These two strings are considered equal" 를 출력합니다.</span>
</code></pre></div></div>

<p>이와는 다르게, 영어에서 사용되는 <code class="highlighter-rouge">LATIN CAPITAL A</code> (<code class="highlighter-rouge">U+0041</code>, 또는 <code class="highlighter-rouge">"A"</code>) 는 러시아어에서 사용되는 <code class="highlighter-rouge">CYRILLIC CAPITAL LETTER A</code> (<code class="highlighter-rouge">U+0410</code>, 또는 <code class="highlighter-rouge">"А"</code>) 와 같지 <em>않 (not)</em> 습니다. 두 문자는 비슷해 보이지만, 동일한 언어적인 의미를 가지지 않기 때문입니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">latinCapitalLetterA</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{41}</span><span class="s">"</span>

<span class="k">let</span> <span class="nv">cyrillicCapitalLetterA</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{0410}</span><span class="s">"</span>

<span class="k">if</span> <span class="n">latinCapitalLetterA</span> <span class="o">!=</span> <span class="n">cyrillicCapitalLetterA</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"These two characters are not equivalent"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "These two characters are not equivalent" 를 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p>스위프트의 문자열 비교 연산 및 문자 비교 연산은 ‘지역에-민감하지 (locale-sensitive)’<sup id="fnref:locale-sensitive" role="doc-noteref"><a href="#fn:locale-sensitive" class="footnote">14</a></sup> 않습니다.</p>
</blockquote>

<h4 id="prefix-and-suffix-equality-접두사-및-접미사-동등성">Prefix and Suffix Equality (접두사 및 접미사 동등성)</h4>

<p>문자열에 특정 문자열로 된 접두사나 접미사가 있는지 확인하려면, 문자열의 <code class="highlighter-rouge">hasPrefix(_:)</code> 와 <code class="highlighter-rouge">hasSuffix(_:)</code> 메소드를 호출하면 되는데, 이 둘은 모두 <code class="highlighter-rouge">String</code> 타입의 단일 인자를 가지고, 불린 (Boolean) 값을 반환합니다.</p>

<p>아래 예제는 문자열의 배열에 대한 예제로, 이는 셰익스피어의 희곡 <em>로미오와 줄리엣 (Romeo and Juliet)</em> 의 첫 두 막에 대한 각 ‘장 (scene)’ 의 장소입니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">romeoAndJuliet</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"Act 1 Scene 1: Verona, A public place"</span><span class="p">,</span>
    <span class="s">"Act 1 Scene 2: Capulet's mansion"</span><span class="p">,</span>
    <span class="s">"Act 1 Scene 3: A room in Capulet's mansion"</span><span class="p">,</span>
    <span class="s">"Act 1 Scene 4: A street outside Capulet's mansion"</span><span class="p">,</span>
    <span class="s">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span><span class="p">,</span>
    <span class="s">"Act 2 Scene 1: Outside Capulet's mansion"</span><span class="p">,</span>
    <span class="s">"Act 2 Scene 2: Capulet's orchard"</span><span class="p">,</span>
    <span class="s">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span><span class="p">,</span>
    <span class="s">"Act 2 Scene 4: A street in Verona"</span><span class="p">,</span>
    <span class="s">"Act 2 Scene 5: Capulet's mansion"</span><span class="p">,</span>
    <span class="s">"Act 2 Scene 6: Friar Lawrence's cell"</span>
<span class="p">]</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">hasPrefix(_:)</code> 메소드를 <code class="highlighter-rouge">romeoAndJuliet</code> 배열에 사용하여, 희곡의 제 1 막에 있는 ‘장 (scene)’ 의 개수를 계산할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">act1SceneCount</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">scene</span> <span class="k">in</span> <span class="n">romeoAndJuliet</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">scene</span><span class="o">.</span><span class="nf">hasPrefix</span><span class="p">(</span><span class="s">"Act 1"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">act1SceneCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"There are </span><span class="se">\(</span><span class="n">act1SceneCount</span><span class="se">)</span><span class="s"> scenes in Act 1"</span><span class="p">)</span>
<span class="c1">// "There are 5 scenes in Act 1" 를 출력합니다.</span>
</code></pre></div></div>

<p>이와 비슷하게, <code class="highlighter-rouge">hasSuffix(_:)</code> 메소드를 사용하여 ‘장 (scene)’ 에서 ‘Capulet’s mansion (저택)’ 과 ‘Friar Lawrence’s cell (작은 방)’ 위치에 대한 개수를 계산할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">mansionCount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="nv">cellCount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">scene</span> <span class="k">in</span> <span class="n">romeoAndJuliet</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">scene</span><span class="o">.</span><span class="nf">hasSuffix</span><span class="p">(</span><span class="s">"Capulet's mansion"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mansionCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">scene</span><span class="o">.</span><span class="nf">hasSuffix</span><span class="p">(</span><span class="s">"Friar Lawrence's cell"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cellCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">mansionCount</span><span class="se">)</span><span class="s"> mansion scenes; </span><span class="se">\(</span><span class="n">cellCount</span><span class="se">)</span><span class="s"> cell scenes"</span><span class="p">)</span>

<span class="c1">// "6 mansion scenes; 2 cell scenes" 를 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">hasPrefix(_:)</code> 와 <code class="highlighter-rouge">hasSuffix(_:)</code> 메소드는 각 문자열에 대해 ‘확장된 자소 덩어리’ 사이의 개별 문자하나씩 법적으로 동등한지를 비교하는 연산을 수행하며, 이는 <a href="">String and Character Equality</a> 에 설명되어 있습니다.</p>
</blockquote>

<h3 id="unicode-representations-of-strings-문자열의-유니코드-표현">Unicode Representations of Strings (문자열의 유니코드 표현)</h3>

<p>유니코드 문자열을 텍스트 파일이나 다른 저장소에 기록하면, 그 문자열의 ‘유니코드 크기 값’ 은 유니코드에-정의된 여러 ‘<em>인코딩 양식 (encording forms; 부호화 양식)</em>’ 중 한 가지로 인코딩 됩니다. 각 양식은 문자열을 <em>코드 단위 (code units)</em> 라는 작은 조각으로 인코딩합니다. 여기에는 UTF-8 인코딩 양식 (문자열을 8-bit ‘코드 단위’ 로 인코딩), UTF-16 인코딩 양식 (문자열을 16-bit ‘코드 단위’ 로 인코딩), 그리고 UTF-32 인코딩 양식 (문자열을 32-bit ‘코드 단위’ 로 인코딩) 이 있습니다.</p>

<p>스위프트는 문자열의 유니코드 ‘표현 (representations)’ 에 접근하는 여러 가지 방법들을 제공합니다. 문자열에 <code class="highlighter-rouge">for-in</code> 구문을 사용하면, 개별 <code class="highlighter-rouge">Character</code> 값을 ‘확장된 자소 덩어리’ 의 형태로 접근하여, 동작을 반복 적용시킬 수 있습니다. 이 과정은 <a href="">Working with Characters</a> 에 설명되어 있습니다.</p>

<p>다른 방법으로, <code class="highlighter-rouge">String</code> 값에 대해 다음의 세 가지 ‘유니코드-부합 표현 (Unicode-compliant representations)’ 형태로 접근할 수도 있습니다:</p>

<ul>
  <li>UTF-8 ‘코드 단위’ 의 컬렉션 (문자열의 <code class="highlighter-rouge">utf8</code> 속성으로 접근 가능)</li>
  <li>UTF-16 ‘코드 단위’ 의 컬렉션 (문자열의 <code class="highlighter-rouge">utf16</code> 속성으로 접근 가능)</li>
  <li>21-bit ‘유니코드 크기 값’ 의 컬렉션, 문자열의 UTF-32 인코딩 양식과 동등함 (문자열의 <code class="highlighter-rouge">unicodeScalars</code> 속성으로 접근 가능)</li>
</ul>

<p>이제부터 나올 각 예제는 다음 문자열에 대한 서로 다른 ‘표현 (representaions)’ 을 보여줍니다. 이 문자열은 문자 <code class="highlighter-rouge">D</code>, <code class="highlighter-rouge">o</code>, <code class="highlighter-rouge">g</code>, <code class="highlighter-rouge">‼</code> (<code class="highlighter-rouge">DOUBLE EXCLAMATION MARK</code>, 또는 유니코드 크기 값 <code class="highlighter-rouge">U+203C</code>) 와 문자 <code class="highlighter-rouge">🐶</code> (<code class="highlighter-rouge">DOG FACE</code> 또는 유니코드 크기 값 <code class="highlighter-rouge">U+1F436</code>) 로 구성되어 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">dogString</span> <span class="o">=</span> <span class="s">"Dog!!🐶"</span>
</code></pre></div></div>

<h4 id="utf-8-representation-utf-8-표현">UTF-8 Representation (UTF-8 표현)</h4>

<p><code class="highlighter-rouge">String</code> 의 ‘UTF-8 표현’ 에 접근하려면 <code class="highlighter-rouge">utf8</code> 속성에 동작을 반복 적용하면 (iterating over) 됩니다. 이 속성의 타입은 <code class="highlighter-rouge">String.UTF8View</code> 이며, 이는 문자열의 UTF-8 표현에 있는 각각의 바이트 (byte) 하나가 부호없는 8-bit (<code class="highlighter-rouge">UInt8</code>) 값으로 된 컬렉션 (집합체) 임을 의미합니다:</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Strings-and-Characters-UTF-8-representation.jpg" alt="UTF-8 representation" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">codeUnit</span> <span class="k">in</span> <span class="n">dogString</span><span class="o">.</span><span class="n">utf8</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">codeUnit</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
<span class="c1">// "68 111 103 226 128 188 240 159 144 182 " 를 출력합니다.</span>
</code></pre></div></div>

<p>위의 예에서, <code class="highlighter-rouge">codeUnit</code> 의 처음 세 10-진수의 값들 (<code class="highlighter-rouge">68</code>, <code class="highlighter-rouge">111</code>, <code class="highlighter-rouge">103</code>) 은 문자 <code class="highlighter-rouge">D</code>, <code class="highlighter-rouge">o</code>, 그리고 <code class="highlighter-rouge">g</code> 를 나타내며, 이들의 ‘UTF-8 표현’ 은 ‘ASCII 표현’ 과 같음을 알 수 있습니다. <code class="highlighter-rouge">codeUnit</code> 의 그 다음의 세 10-진수 값들 (<code class="highlighter-rouge">226</code>, <code class="highlighter-rouge">128</code>, <code class="highlighter-rouge">188</code>) 은 <code class="highlighter-rouge">DOUBLE EXCLAMATION MARK</code> 문자에 대한 3-바이트짜리 ‘UTF-8 표현’ 입니다. <code class="highlighter-rouge">codeUnit</code> 의 마지막 네 값들 (<code class="highlighter-rouge">240</code>, <code class="highlighter-rouge">159</code>, <code class="highlighter-rouge">144</code>, <code class="highlighter-rouge">182</code>) 은 <code class="highlighter-rouge">DOG FACE</code> 문자에 대한 4-바이트짜리 ‘UTF-8 표현’ 입니다.</p>

<h4 id="utf-16-representation-utf-16-표현">UTF-16 Representation (UTF-16 표현)</h4>

<p><code class="highlighter-rouge">String</code> 의 ‘UTF-16 표현’ 에 접근하려면 <code class="highlighter-rouge">utf16</code> 속성에 동작을 반복 적용하면 (iterating over) 됩니다. 이 속성의 타입은 <code class="highlighter-rouge">String.UTF16View</code> 이며, 이는 문자열의 UTF-16 표현에 있는 각각의 바이트 (byte) 하나가 부호없는 16-bit (<code class="highlighter-rouge">UInt16</code>) 값으로 된 컬렉션 (집합체) 임을 의미합니다:</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Strings-and-Characters-UTF-16-representation.jpg" alt="UTF-16 representation" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">codeUnit</span> <span class="k">in</span> <span class="n">dogString</span><span class="o">.</span><span class="n">utf16</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">codeUnit</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
<span class="c1">// "68 111 103 8252 55357 56374 " 를 출력합니다.</span>
</code></pre></div></div>

<p>위의 예에서, <code class="highlighter-rouge">codeUnit</code> 의 처음 세 10-진수의 값들 (<code class="highlighter-rouge">68</code>, <code class="highlighter-rouge">111</code>, <code class="highlighter-rouge">103</code>) 은 문자 <code class="highlighter-rouge">D</code>, <code class="highlighter-rouge">o</code>, 그리고 <code class="highlighter-rouge">g</code> 를 나타내며, 이들의 ‘UTF-8 표현’ 은 ‘ASCII 표현’ 과 같음을 알 수 있습니다. <code class="highlighter-rouge">codeUnit</code> 의 그 다음의 세 10-진수 값들 (<code class="highlighter-rouge">226</code>, <code class="highlighter-rouge">128</code>, <code class="highlighter-rouge">188</code>) 은 <code class="highlighter-rouge">DOUBLE EXCLAMATION MARK</code> 문자에 대한 3-바이트짜리 ‘UTF-8 표현’ 입니다. <code class="highlighter-rouge">codeUnit</code> 의 마지막 네 값들 (<code class="highlighter-rouge">240</code>, <code class="highlighter-rouge">159</code>, <code class="highlighter-rouge">144</code>, <code class="highlighter-rouge">182</code>) 은 <code class="highlighter-rouge">DOG FACE</code> 문자에 대한 4-바이트짜리 ‘UTF-8 표현’ 입니다.</p>

<p>또다시, <code class="highlighter-rouge">codeUnit</code> 의 처음 세 값들 (<code class="highlighter-rouge">68</code>, <code class="highlighter-rouge">111</code>, <code class="highlighter-rouge">103</code>) 은 문자 <code class="highlighter-rouge">D</code>, <code class="highlighter-rouge">o</code>, 그리고 <code class="highlighter-rouge">g</code> 를 나타내며, 이들의 ‘UTF-16 표현’ 은 ‘UTF-8 표현’ 과 같습니다. (왜냐면 이들의 ‘유니코드 크기 값’ 은 ‘ASCII 문자’ 를 나타내기 때문입니다.)</p>

<p><code class="highlighter-rouge">codeUnit</code> 의 네 번째 값 (<code class="highlighter-rouge">8252</code>) 은 16-진수 값 <code class="highlighter-rouge">203C</code> 에 해당하는 10-진수 값으로, <code class="highlighter-rouge">DOUBLE EXCLAMATION MARK</code> 문자에 대한 ‘유니코드 크기 값’ <code class="highlighter-rouge">U+203C</code> 를 나타냅니다. 이 문자는 ‘UTF-16’ 에서 단일한 ‘코드 단위’ 로 표시할 수 있습니다.</p>

<p><code class="highlighter-rouge">codeUnit</code> 의 다섯 번째와 여섯 번째 값들 (<code class="highlighter-rouge">55357</code> 와 <code class="highlighter-rouge">56374</code>) 은 <code class="highlighter-rouge">DOG FACE</code> 문자에 대한 ‘UTF-16 대체-쌍 (surrogate pair) 표현’ 입니다. 이들의 값은 ‘높은자리-대체 값’ <code class="highlighter-rouge">U+D83D</code> (10-진수 값 <code class="highlighter-rouge">55357</code>) 과 ‘낮은자리-대체 값’ <code class="highlighter-rouge">U+DC36</code> (10-진수 값 <code class="highlighter-rouge">56374</code>) 입니다.</p>

<h4 id="unicode-scalar-representation-유니코드-크기-값-표현">Unicode Scalar Representation (‘유니코드 크기 값’ 표현)</h4>

<p><code class="highlighter-rouge">String</code> 값의 ‘유니코드 크기 값 표현’ 에 접근하려면 <code class="highlighter-rouge">unicodeScalars</code> 속성에 동작을 반복 적용하면 (iterating over) 됩니다. 이 속성의 타입은 <code class="highlighter-rouge">UnicodeScalarView</code> 이며, 이는 타입이 <code class="highlighter-rouge">UnicodeScalar</code> 인 값들의 컬렉션 (집합체) 임을 의미합니다.</p>

<p>각 <code class="highlighter-rouge">UnicodeScalar</code> 은 ‘크기 값’ 을 21-bit 값으로 반환하는 <code class="highlighter-rouge">value</code> 속성을 갖고 있는데, 이 반환 값은 <code class="highlighter-rouge">UInt32</code> 값으로 표현됩니다:</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Strings-and-Characters-Unicode-scalar-representation.jpg" alt="Unicode Scalar representation" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">scalar</span> <span class="k">in</span> <span class="n">dogString</span><span class="o">.</span><span class="n">unicodeScalars</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">scalar</span><span class="o">.</span><span class="n">value</span><span class="se">)</span><span class="s"> "</span><span class="p">,</span> <span class="nv">terminator</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
<span class="c1">// "68 111 103 8252 128054 " 를 출력합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">UnicodeScalar</code> 의 처음 세 값들에 대한 <code class="highlighter-rouge">value</code> 속성들 (<code class="highlighter-rouge">68</code>, <code class="highlighter-rouge">111</code>, <code class="highlighter-rouge">103</code>) 은 또다시 문자 <code class="highlighter-rouge">D</code>, <code class="highlighter-rouge">o</code>, 그리고 <code class="highlighter-rouge">g</code> 를 나타냅니다.</p>

<p>네 번째 값 (<code class="highlighter-rouge">8252</code>) 은 또다시 16-진수 값 <code class="highlighter-rouge">203C</code> 에 해당하는 10-진수 값으로, <code class="highlighter-rouge">DOUBLE EXCLAMATION MARK</code> 문자에 대한 ‘유니코드 크기 값’ <code class="highlighter-rouge">U+203C</code> 를 나타냅니다.</p>

<p><code class="highlighter-rouge">UnicodeScalar</code> 의 다섯 번째이자 마지막 값에 대한 <code class="highlighter-rouge">value</code> 속성, <code class="highlighter-rouge">128054</code>, 는 16-진수 값 <code class="highlighter-rouge">1F436</code> 에 해당하는 10-진수 값으로, <code class="highlighter-rouge">DOG FACE</code> 문자에 대한 ‘유니코드 크기 값’ <code class="highlighter-rouge">U+1F436</code> 을 나타냅니다.</p>

<p><code class="highlighter-rouge">value</code> 속성을 조회하는 대신, 각각의 <code class="highlighter-rouge">UnicodeScalar</code> 값을 사용하여 새로운 <code class="highlighter-rouge">String</code> 값을 생성할 수 있으며, 가령 ‘문자열 보간법 (string interpolation)’ 이 이에 해당합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">scalar</span> <span class="k">in</span> <span class="n">dogString</span><span class="o">.</span><span class="n">unicodeScalars</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">scalar</span><span class="se">)</span><span class="s"> "</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// D</span>
<span class="c1">// o</span>
<span class="c1">// g</span>
<span class="c1">// ‼</span>
<span class="c1">// 🐶</span>
</code></pre></div></div>

<h3 id="참고-자료">참고 자료</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:Strings-and-Characters" role="doc-endnote">
      <p>원문은 <a href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html">Strings and Characters</a> 에서 확인할 수 있습니다. <a href="#fnref:Strings-and-Characters" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:collection" role="doc-endnote">
      <p>‘컬렉션 (collection)’ 은 스위프트에서 특정한 값들의 집합을 묘사하는 ‘집합체’ 타입입니다. 보다 자세한 내용은 <a href="/swift/grammar/collection/array/set/dictionary/2016/06/06/Collection-Types.html">Collection Types (집합체 타입)</a> 을 보도록 합니다. <a href="#fnref:collection" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:string-literal-syntax" role="doc-endnote">
      <p>‘문자열 글자표현 구문 (string literal syntax)’ 은 말은 어렵지만 개념은 아주 간단합니다. <code class="highlighter-rouge">let greeting = "hello"</code> 와 같은 문장에서 <code class="highlighter-rouge">"hello"</code> 가 바로 ‘문자열 글자표현 구문 (string literal syntax)’ 입니다. 이 책에서 말하는 것은 스위프트에서 사용하는 이 ‘문자열 글자표현 구문’ 이 사실상 C 언어와 같아서 이해하기 쉽다는 의미입니다. <a href="#fnref:string-literal-syntax" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:literals" role="doc-endnote">
      <p>여기서 ‘글자표현 (literals)’ 는 ‘글자로 표현된 실제 값’ 을 의미하며, <code class="highlighter-rouge">let a = 3.14</code> 에서는 <code class="highlighter-rouge">3.14</code> 라는 <code class="highlighter-rouge">Double</code> 값이 되고, <code class="highlighter-rouge">let b = "hello"</code> 에서는 <code class="highlighter-rouge">"hello"</code> 라는 <code class="highlighter-rouge">String</code> 값이 됩니다. 즉 ‘글자표현 (literals)’ 에서 값의 타입은 그 값이 실제로 표현하는 것이 무엇인지에 따라 달라집니다. <a href="#fnref:literals" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:interpolation" role="doc-endnote">
      <p>‘보간법 (interpolation)’ 은 원래 수학 용어로 그래프 상에서 두 점 사이의 값을 근사적으로 구해서 채워넣는 방법을 말합니다. ‘string interpolation’ 은 굳이 직역하면 ‘문자열 삽입법’ 등으로 옮길 수 있겠지만, ‘interpolation’ 은 원래부터 ‘보간법’ 이라는 말로 많이 사용하고 있으므로 그대로 ‘보간법’ 을 사용하도록 합니다. ‘문자열 보간법’ 은 한 문자열 중간에 다른 값을 문자열의 형태로 집어넣는 것으로 이해할 수 있습니다. <a href="#fnref:interpolation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:escaped" role="doc-endnote">
      <p>‘escaped’ 는 우리 말로 ‘벗어난’ 을 의미하는 단어인데, 프로그래밍에서 ‘escaped special characters’ 라고 하면 ‘(본래의 의미를) 벗어나서 다른 의미를 가지게된 특수 문자’ 라는 의미가 됩니다. 예를 들어 <code class="highlighter-rouge">n</code> 이라고 하면, 그냥 하나의 영어 문자가 되지만, <code class="highlighter-rouge">\n</code> 이라고 하면 본래의 영어 단어의 의미를 벗어나서, <code class="highlighter-rouge">new line (feed)</code> 이라는 새로운 의미를 가지게 됩니다. 이렇게 문자 앞에 슬래쉬 (<code class="highlighter-rouge">\</code>) 를 붙여서 ‘본래 의미를 벗어난 다른 의미를 가지는 문자’ 를 일컬어 ‘escaped characters’ 라고 합니다. <a href="#fnref:escaped" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:scalar" role="doc-endnote">
      <p>‘scalar’ 는 원래 수학 용어로 ‘크기만을 가지는 값’ 입니다. 여기서 ‘Unicode scalar value’ 은 각각의 문자에 일대일 대응되는 ‘유니코드 크기 값’ 을 의미합니다. 예를 들어, 문자는 <code class="highlighter-rouge">$</code> 는 유니코드 크기 값이 <code class="highlighter-rouge">U+0024</code> 에 해당합니다. <a href="#fnref:scalar" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:escaping" role="doc-endnote">
      <p>여기서 ‘escaping’ 할 필요 없다는 말은 슬래쉬 (<code class="highlighter-rouge">\</code>) 기호를 붙일 필요가 없다는 것을 의미합니다. <a href="#fnref:escaping" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:number-sign" role="doc-endnote">
      <p>’#’ 은 영어로 ‘number sign’ 이라고 하는데, 보통 우리 말로는 ‘샾 기호’ 라고 알려져 있습니다. 하지만 실제 샾 기호와는 다르며 하나의 숫자를 의미합니다. 여기서는 ‘번호 기호’ 라고 옮기도록 합니다. <a href="#fnref:number-sign" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:value-type" role="doc-endnote">
      <p>‘값 타입 (value type)’ 이라는 말은, 프로그래밍 용어에서 ‘깊은 복사’ 와 ‘옅은 복사’ 라는 말이 있는데, 이 중에서 복사 시의 기본 동작이 ‘깊은 복사’ 인 타입이라고 이해할 수 있습니다. <a href="#fnref:value-type" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:optimize-string" role="doc-endnote">
      <p>이 말은 기본적으로 <code class="highlighter-rouge">String</code> 은 ‘깊은 복사’ 를 한다고는 하지만, 만약 전달받은 <code class="highlighter-rouge">String</code> 을 상수처럼 사용할 경우, 굳이 값을 복사할 필요가 없으므로 스위프트가 성능 최적화를 해서, 실제 복사를 안할 수도 있다는 말입니다. <a href="#fnref:optimize-string" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:annotation" role="doc-endnote">
      <p>‘annotation’ 은 ‘주석’ 이라는 말로 옮길 수 있는데, 스위프트에서 ‘주석 (annotation)’ 이라 하면 <code class="highlighter-rouge">let a: Int = 10</code> 에서 <code class="highlighter-rouge">Int</code> 처럼 타입을 지정해 주는 것을 말합니다. <a href="#fnref:annotation" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:extended-grapheme-cluster" role="doc-endnote">
      <p>하나의 문자가 ‘자소 덩어리’ 라는 말은, <code class="highlighter-rouge">가</code> 라는 하나의 문자가 <code class="highlighter-rouge">ㄱ</code> 과 <code class="highlighter-rouge">ㅏ</code> 라는 자소들의 덩어리로 이루어졌다는 것을 의미합니다. ‘확장된 자소 덩어리’ 에 대한 개념은 좀 더 아래의 본문에 <code class="highlighter-rouge">한</code> 이라는 글자로 설명되어 있습니다. <a href="#fnref:extended-grapheme-cluster" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:locale-sensitive" role="doc-endnote">
      <p>‘locale-sensitive’ 라는 ‘지역에 대한 민감성’ 을 나타내는데, ‘비교 연산 (comparison)’ 이 ‘지역에 민감한 (locale-sensitive)’ 것은 서로 다른 지역의 언어에 대해 비교 연산을 할 수 없다는 의미로 추측됩니다. 스위프트의 문자열 연산은 유니코드에 부합하므로 지역에 민감하지 않다고 볼 수 있습니다. <a href="#fnref:locale-sensitive" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET