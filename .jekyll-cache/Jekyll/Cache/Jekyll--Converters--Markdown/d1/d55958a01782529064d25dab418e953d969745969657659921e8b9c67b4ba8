I"<blockquote>
  <p>Apple 에서 공개한 <a href="https://docs.swift.org/swift-book/">The Swift Programming Language (Swift 5.2)</a> 책의 <a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html">A Swift Tour</a> 부분<sup id="fnref:A-Swift-Tour" role="doc-noteref"><a href="#fn:A-Swift-Tour" class="footnote">1</a></sup>을 번역하고 정리한 글입니다.</p>

  <p>현재 전체 중에서 번역 완료된 목록은 <a href="/swift/programming/language/grammar/2017/02/28/The-Swift-Programming-Language.html">Swift 5.2: Swift Programming Language (스위프트 프로그래밍 언어)</a> 에서 확인할 수 있습니다.</p>
</blockquote>

<h2 id="a-swift-tour-스위프트-둘러보기">A Swift Tour (스위프트 둘러보기)</h2>

<p>전통적으로 새로운 언어로 만든 첫 번째 프로그램은 화면에 <code class="highlighter-rouge">"Hello, world!"</code> 라는 문장을 출력합니다. 스위프트로는, 이것을 단 한 줄로 할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
<span class="c1">// "Hello, world!"  를 출력합니다.</span>
</code></pre></div></div>

<p>C 언어나 오브젝티브-C 언어로 코딩을 해봤다면, 이 구문 표현이 익숙한 듯 보이겠지만-스위프트에서는, 이 코드 한 줄로 프로그램이 완성된 것입니다. 입력/출력이나 문자열 처리와 같은 기능을 위해 개별 라이브러리를 불러올 필요가 없습니다. 전역 범위 공간에 작성한 코드는 프로그램의 진입점으로 사용되므로, <code class="highlighter-rouge">main()</code> 함수도 필요 없습니다.모든 문장의 끝에 세미콜론을 붙일 필요 또한 없습니다.</p>

<p>이 둘러보기는 스위프트 코드 작성을 시작하기 충분한 정보를 제공해 주기 위해 다양한 프로그래밍 작업을 수행하는 방법을 보이도록 할 것입니다. 어떤 부분에서 이해가 가지 않더라도 당황할 필요 없습니다-이 둘러보기에서 소개한 모든 내용은 이 책의 나머지 부분에서 더 자세하게 다시 설명할 것이기 때문입니다.</p>

<blockquote>
  <p>최고의 경험을 위해, 이 장을 Xcode 에 있는 ‘playgroud (놀이터)’ 로 열어보기 바랍니다. ‘playground (놀이터)’ 로 코드 목록을 편집하고 그 결과를 즉시 확인할 수 있습니다.</p>

  <p><a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.playground.zip">‘playground (놀이터)’ 다운로드 하기</a></p>
</blockquote>

<h3 id="simple-values-간단한-값들">Simple Values (간단한 값들)</h3>

<p><code class="highlighter-rouge">let</code> 을 사용하여 상수를 만들고 <code class="highlighter-rouge">var</code> 를 사용하여 변수를 만듭니다. 상수의 값은 컴파일 시간에 알아야 할 필요는 없지만, 그 값을 반드시 정확히 한 번은 할당해야 합니다. 이는 한 번 결정하고 나면 많은 곳에서 사용할 수 있는 값에 이름을 짓는 것이 상수라는 것을 의미합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">myVariable</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">myVariable</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">let</span> <span class="nv">myConstant</span> <span class="o">=</span> <span class="mi">42</span>
</code></pre></div></div>

<p>상수나 변수는 반드시 할당하려는 값과 타입이 같아야 합니다. 하지만, 타입을 항상 명시적으로 적어야만 하는 것은 아닙니다. 상수나 변수를 만들 때 값을 제공하면 컴파일러가 그 타입을 추론할 수 있습니다. 위의 예제에서, 컴파일러는 <code class="highlighter-rouge">myVariable</code> 이 정수라고 추론하는데 이는 기본 설정 값이 정수이기 때문입니다.</p>

<p>기본 설정 값이 충분한 정보를 제공하지 않거나 (혹은 기본 설정 값이 없는 경우), 변수 뒤에 콜론 (<code class="highlighter-rouge">:</code>) 을 써서 구분한 다음, 타입을 지정하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">implicitInteger</span> <span class="o">=</span> <span class="mi">70</span>
<span class="k">let</span> <span class="nv">implicitDouble</span> <span class="o">=</span> <span class="mf">70.0</span>
<span class="k">let</span> <span class="nv">explicitDouble</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">70</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>명시적인 타입이 <code class="highlighter-rouge">Float</code> 이고 값이 <code class="highlighter-rouge">4</code> 인 상수를 만들어 봅시다.</p>
</blockquote>

<p>값은 절대 다른 타입으로 암시적으로 변환되지 않습니다. 값을 다른 타입으로 변환할 필요가 있을 경우, 원하는 타입의 인스턴스를 명시적으로 만들어야 합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="s">"The width is "</span>
<span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="mi">94</span>
<span class="k">let</span> <span class="nv">widthLabel</span> <span class="o">=</span> <span class="n">label</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>마지막 줄에서 <code class="highlighter-rouge">String</code> 으로의 변환을 제거해 봅시다. 어떤 에러가 발생합니까?</p>
</blockquote>

<p>문자열에 값을 포함시킬 수 있는 더 간단한 방법도 있습니다. 값을 괄호 안에 쓰고, 괄호 앞에 백 슬래시 (<code class="highlighter-rouge">\</code>) 를 쓰면 됩니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">apples</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">let</span> <span class="nv">oranges</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">let</span> <span class="nv">appleSummary</span> <span class="o">=</span> <span class="s">"I have </span><span class="se">\(</span><span class="n">apples</span><span class="se">)</span><span class="s"> apples."</span>
<span class="k">let</span> <span class="nv">fruitSummary</span> <span class="o">=</span> <span class="s">"I have </span><span class="se">\(</span><span class="n">apples</span> <span class="o">+</span> <span class="n">oranges</span><span class="se">)</span><span class="s"> pieces of fruit."</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">\()</code> 를 사용하여 문자열에 부동-소수점 연산을 포함시켜 보고 또 인사말에 다른 사람 이름을 포함시켜 봅시다.</p>
</blockquote>

<p>따옴표 세 개 (<code class="highlighter-rouge">"""</code>) 를 써서 여러 줄짜리 문자열을 만들 수 있습니다. 닫는 따옴표 앞에 들여쓰기가 있으면, 그 만큼의 들여쓰기가 각 줄 시작마다 제거됩니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">quotation</span> <span class="o">=</span> <span class="s">"""
I said "</span><span class="kt">I</span> <span class="n">have</span> <span class="p">\(</span><span class="n">apples</span><span class="p">)</span> <span class="n">apples</span><span class="o">.</span><span class="s">"
And then I said "</span><span class="kt">I</span> <span class="n">have</span> <span class="p">\(</span><span class="n">apples</span> <span class="o">+</span> <span class="n">oranges</span><span class="p">)</span> <span class="n">pieces</span> <span class="n">of</span> <span class="n">fruit</span><span class="o">.</span><span class="s">"
"""</span>
</code></pre></div></div>

<p>대괄호 (<code class="highlighter-rouge">[]</code>) 로 ‘배열 (arrays)’ 과 ‘딕셔너리 (dictionary)’ 를 만들고, 괄호 안에 색인과 키를 작성해서 그 원소에 접근할 수 있습니다. 마지막 원소 뒤에는 쉼표가 있어도 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">shoppingList</span> <span class="o">=</span> <span class="p">[</span><span class="s">"catfish"</span><span class="p">,</span> <span class="s">"water"</span><span class="p">,</span> <span class="s">"tulips"</span><span class="p">,</span> <span class="s">"blue paint"</span><span class="p">]</span>
<span class="n">shoppingList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"bottle of water"</span>

<span class="k">var</span> <span class="nv">occupations</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"Malcolm"</span><span class="p">:</span> <span class="s">"Captain"</span><span class="p">,</span>
    <span class="s">"Kaylee"</span><span class="p">:</span> <span class="s">"Mechanic"</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">occupations</span><span class="p">[</span><span class="s">"Jayne"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Public Relations"</span>
</code></pre></div></div>

<p>배열은 원소를 더할 때마다 자동으로 크기가 커집니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"blue paint"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">shoppingList</span><span class="p">)</span>
</code></pre></div></div>

<p>빈 ‘배열 (array)’ 이나 빈 ‘딕셔너리 (dictionary)’ 를 만들려면, ‘초기자 구문 표현 (initializer syntax)’ 을 사용하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">emptyArray</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]()</span>
<span class="k">let</span> <span class="nv">emptyDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Float</span><span class="p">]()</span>
</code></pre></div></div>

<p>타입 정보를 추론할 수 있는 경우에는, 빈 배열은 <code class="highlighter-rouge">[]</code> 라고 쓸 수 있고 빈 딕셔너리는 <code class="highlighter-rouge">[:]</code> 라고 쓸 수 있습니다-예를 들어, 변수에 새 값을 설정하거나 함수의 인자로 전달할 때에 해당합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">occupations</span> <span class="o">=</span> <span class="p">[:]</span>
</code></pre></div></div>

<h3 id="control-flow-제어-흐름">Control Flow (제어 흐름)</h3>

<p><code class="highlighter-rouge">if</code> 와 <code class="highlighter-rouge">switch</code> 를 사용하여 조건문을 만들고, <code class="highlighter-rouge">for-in</code>, <code class="highlighter-rouge">while</code> 그리고 <code class="highlighter-rouge">repeat-while</code> 을 사용하여 반복문을 만듭니다. 조건이나 반복 변수 주위의 괄호는 선택 사항입니다. 다만 본문 주위의 중괄호는 필수입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">individualScores</span> <span class="o">=</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">103</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="k">var</span> <span class="nv">teamScore</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">score</span> <span class="k">in</span> <span class="n">individualScores</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="p">{</span>
        <span class="n">teamScore</span> <span class="o">+=</span> <span class="mi">3</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">teamScore</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">teamScore</span><span class="p">)</span>
<span class="c1">// "11" 을 출력합니다.  </span>
</code></pre></div></div>

<p><code class="highlighter-rouge">if</code> 문에서, ‘조건절 (the conditional)’ 은 반드시 ‘불린 표현식 (Boolean expression)’ 이어야 합니다-이것은 <code class="highlighter-rouge">if score { ... }</code> 와 같은 코드는 에러가 되는 것이지, 0으로 암시적인 비교를 하는 게 아님을 의미합니다.</p>

<p><code class="highlighter-rouge">if</code> 와 <code class="highlighter-rouge">let</code> 을 같이 사용하여 누락될 수도 있는 값을 다룰 수 있습니다. 이 값은 ‘옵셔널 (optionals)’ 을 써서 나타냅니다. 옵셔널 값은 하나의 값을 가지거나 아니면 값이 누락됐음을 나타내는 <code class="highlighter-rouge">nil</code> 을 가지고 있습니다. 값의 타입 뒤에 물음표 (<code class="highlighter-rouge">?</code>) 를 붙여서 그 값이 ‘옵셔널’ 임을 표시합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">optionalString</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"Hello"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">optionalString</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
<span class="c1">// "false" 를 출력합니다.</span>

<span class="k">var</span> <span class="nv">optionalName</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="s">"John Appleseed"</span>
<span class="k">var</span> <span class="nv">greeting</span> <span class="o">=</span> <span class="s">"Hello!"</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="n">optionalName</span> <span class="p">{</span>
    <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hello, </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">optionalName</code> 을 <code class="highlighter-rouge">nil</code> 로 바꿔 보기 바랍니다. 어떤 인사말을 받게 됩니까? <code class="highlighter-rouge">else</code> 절을 추가해서 <code class="highlighter-rouge">optionalName</code> 이 <code class="highlighter-rouge">nil</code> 이면 다른 인사말을 하도록 설정해 보도록 합니다.</p>
</blockquote>

<p>옵셔널 값이 <code class="highlighter-rouge">nil</code> 이면, 조건절이 <code class="highlighter-rouge">false</code> 가 되어 중괄호 안의 코드를 건너뛰게 됩니다. 그렇지 않다면, 옵셔널 값이 풀려서 <code class="highlighter-rouge">let</code> 뒤의 상수에 할당되어, 코드 블럭 내부에서 이 풀린 값을 사용할 수 있게 됩니다.</p>

<p>옵셔널 값을 처리하는 또 다른 방법은 <code class="highlighter-rouge">??</code> 연산자를 사용하여 기본 설정 값을 제공하는 것입니다. 이 경우 옵셔널 값이 누락됐을 경우, 기본 설정 값을 대신 사용하게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nickName</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="k">let</span> <span class="nv">fullName</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"John Appleseed"</span>
<span class="k">let</span> <span class="nv">informalGreeting</span> <span class="o">=</span> <span class="s">"Hi </span><span class="se">\(</span><span class="n">nickName</span> <span class="p">??</span> <span class="n">fullName</span><span class="se">)</span><span class="s">"</span>
</code></pre></div></div>

<p>‘switches (스위치)’ 문은 모든 종류의 데이터를 지원하며 비교 가능한 연산 종류도 광범위합니다-정수에만 한정되지 않으며 같은 지만 검사할 수 있는 것도 아닙니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">vegetable</span> <span class="o">=</span> <span class="s">"red pepper"</span>
<span class="k">switch</span> <span class="n">vegetable</span> <span class="p">{</span>
<span class="k">case</span> <span class="s">"celery"</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Add some raisins and make ants on a log."</span><span class="p">)</span>
<span class="k">case</span> <span class="s">"cucumber"</span><span class="p">,</span> <span class="s">"watercress"</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"That would make a good tea sandwich."</span><span class="p">)</span>
<span class="k">case</span> <span class="k">let</span> <span class="nv">x</span> <span class="k">where</span> <span class="n">x</span><span class="o">.</span><span class="nf">hasSuffix</span><span class="p">(</span><span class="s">"pepper"</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Is it a spicy </span><span class="se">\(</span><span class="n">x</span><span class="se">)</span><span class="s">?"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Everything tastes good in soup."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Is it a spicy red pepper?" 를 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>‘기본 경우 값 (default case)’ 을 제거해 봅니다. 어떤 에러를 받게 됩니까?</p>
</blockquote>

<p>패턴 안에서 <code class="highlighter-rouge">let</code> 을 사용하여 패턴에 해당하는 값을 상수에 할당할 수 있음에 주목하기 바랍니다.</p>

<p>‘스위치 경우 값 (switch case)’ 에 해당하는 코드를 실행하고 나면, ‘스위치 (switch)’ 구문을 빠져 나오게 됩니다. 프로그램 실행은 그 다음 ‘경우 값 (case)’ 으로 계속 이어지지 않으므로, 각 ‘경우 값 (case)’ 의 코드 끝에서 ‘스위치 (switch) 문’ 을 ‘깨고 나와야 한다 (break out)’ 고 명시할 필요가 없습니다.<sup id="fnref:break-out" role="doc-noteref"><a href="#fn:break-out" class="footnote">2</a></sup></p>

<p><code class="highlighter-rouge">for-in</code> 을 사용하여 ‘딕셔너리’ 에 있는 항목에 동작을 반복 적용시키려면 각각의 ‘키-값 쌍 (key-value pair)’ 에 사용할 ‘이름 쌍’ 을 제공하면 됩니다. ‘딕셔너리’ 는 순서가 없는 ‘컬렉션 (collection’ 이므로, 이 키와 값들은 임의의 순서로 동작을 반복 적용시키게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">interestingNumbers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"Prime"</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>
    <span class="s">"Fibonacci"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
    <span class="s">"Square"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">],</span>
<span class="p">]</span>
<span class="k">var</span> <span class="nv">largest</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span> <span class="k">in</span> <span class="n">interestingNumbers</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">number</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">largest</span><span class="p">)</span>
<span class="c1">// "25" 를 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>가장 큰 수가 무엇인지 추적했던 것처럼, 다른 변수를 추가하여 가장 큰 수의 종류가 무엇인지 추적해보기 바랍니다.</p>
</blockquote>

<p><code class="highlighter-rouge">while</code> 문을 사용하면 조건이 바뀌기 전까지 한 ‘코드 블럭 (block of code)’ 을 반복할 수 있습니다. 반복문이 최소한 한 번은 실행되도록 하려면, 대신 반복 조건을 맨 뒤에 두면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="c1">// "128" 을 출력합니다.</span>

<span class="k">var</span> <span class="nv">m</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">repeat</span> <span class="p">{</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span> <span class="k">while</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="nf">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="c1">// "128" 을 출력합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">..&lt;</code> 로 색인 범위를 만들면 반복문 내에서 색인을 유지할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">4</span> <span class="p">{</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">i</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
<span class="c1">// "6" 을 출력합니다.</span>
</code></pre></div></div>

<p>최상단 값을 생략하는 범위를 만들려면 <code class="highlighter-rouge">..&lt;</code> 를 사용하고, 양 끝단의 값을 모두 포함하는 범위를 만들려면 <code class="highlighter-rouge">...</code> 를 사용하면 됩니다.</p>

<h3 id="functions-and-closures-함수와-클로져">Functions and Closures (함수와 클로져)</h3>

<p><code class="highlighter-rouge">func</code> 을 사용하여 함수를 선언합니다. 함수 호출은 이름 뒤에 인자 목록을 담은 괄호를 붙여주면 됩니다. <code class="highlighter-rouge">-&gt;</code> 를 사용하여 매개 변수의 이름과 타입을 함수의 반환 타입에서 구분짓도록 합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">day</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">person</span><span class="se">)</span><span class="s">, today is </span><span class="se">\(</span><span class="n">day</span><span class="se">)</span><span class="s">."</span>
<span class="p">}</span>
<span class="nf">greet</span><span class="p">(</span><span class="nv">person</span><span class="p">:</span> <span class="s">"Bob"</span><span class="p">,</span> <span class="nv">day</span><span class="p">:</span> <span class="s">"Tuesday"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">day</code> 매개 변수를 제거해 봅니다. 매개 변수를 추가하여 인사말에 오늘의 점심 특선을 포함시켜 봅니다.</p>
</blockquote>

<p>기본적으로, 함수는 매개 변수의 이름을 인자의 ‘이름표 (labels)’ 로 사용합니다. 자신만의 인자 ‘이름표 (label)’ 를 사용하려면 매개 변수 앞에 써 주면 되고, 아무런 인자 이름표 사용하지 않으려면 <code class="highlighter-rouge">_</code> 를 써주면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">_</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">on</span> <span class="nv">day</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello </span><span class="se">\(</span><span class="n">person</span><span class="se">)</span><span class="s">, today is </span><span class="se">\(</span><span class="n">day</span><span class="se">)</span><span class="s">."</span>
<span class="p">}</span>
<span class="nf">greet</span><span class="p">(</span><span class="s">"John"</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="s">"Wednesday"</span><span class="p">)</span>
</code></pre></div></div>

<p>‘튜플 (tuple)’ 을 사용하면 ‘복합 값 (compound value)’ 을 만들 수 있습니다-예를 들어, 함수에서 여러 값을 반환할 때 쓸 수 있습니다. 튜플의 원소들은 이름이나 번호로 참조할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">calculateStatistics</span><span class="p">(</span><span class="nv">scores</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nv">min</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">max</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">sum</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">min</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">max</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">var</span> <span class="nv">sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">score</span> <span class="k">in</span> <span class="n">scores</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">score</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">score</span>
        <span class="p">}</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">score</span>
    <span class="p">}</span>

    <span class="nf">return</span> <span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">sum</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">statistics</span> <span class="o">=</span> <span class="nf">calculateStatistics</span><span class="p">(</span><span class="nv">scores</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">statistics</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="c1">// "120" 을 출력합니다.</span>
<span class="nf">print</span><span class="p">(</span><span class="n">statistics</span><span class="o">.</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">// "120" 을 출력합니다.</span>
</code></pre></div></div>

<p>함수는 ‘nested (품어질)’ 수 있습니다. ‘nested (품어진)’ 함수는 외부 함수에서 선언한 변수에 접근할 수 있습니다. ‘nested (품어진)’ 함수를 사용하여 길고 복잡한 함수의 코드를 정돈할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">returnFifteen</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">y</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="kd">func</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="mi">5</span>
    <span class="p">}</span>
    <span class="nf">add</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">y</span>
<span class="p">}</span>
<span class="nf">returnFifteen</span><span class="p">()</span>
</code></pre></div></div>

<p>함수는 ‘일급 타입 (first-class type)’ 입니다.<sup id="fnref:first-class" role="doc-noteref"><a href="#fn:first-class" class="footnote">3</a></sup> 이것은 함수가 다른 함수를 값의 형태로 반환할 수 있다는 것을 의미합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">makeIncrementer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">addOne</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">number</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">addOne</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">increment</span> <span class="o">=</span> <span class="nf">makeIncrementer</span><span class="p">()</span>
<span class="nf">increment</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</code></pre></div></div>

<p>함수는 다른 함수를 인자의 하나로 받을 수도 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">hasAnyMatches</span><span class="p">(</span><span class="nv">list</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">condition</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">list</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">condition</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">lessThanTen</span><span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="mi">10</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="nf">hasAnyMatches</span><span class="p">(</span><span class="nv">list</span><span class="p">:</span> <span class="n">numbers</span><span class="p">,</span> <span class="nv">condition</span><span class="p">:</span> <span class="n">lessThanTen</span><span class="p">)</span>
</code></pre></div></div>

<p>함수는 실제로는 ‘클로저 (closures; 잠금 블럭)’ 의 특수한 경우에 해당합니다: 여기서 클로저는 나중에 호출할 수 있는 코드 블럭을 말합니다. 클로저의 코드는 클로저가 만들어진 범위 영역에서 사용 가능한 변수와 함수 등에 접근할 수 있는데, 이 범위 영역은 클로저가 실행될 때는 달라져도 상관없습니다-이에 대한 예제는 앞서 ‘nested (품어진)’ 함수에서 이미 살펴봤었습니다. 클로저는 이름 없이 만들 수도 있는데 이 때는 코드를 중괄호 (<code class="highlighter-rouge">{}</code>) 로 감싸기만 하면 도비니다. 이 경우 <code class="highlighter-rouge">in</code> 을 사용하여 인자와 반환 값을 본문에서 구분하게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="p">(</span><span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">})</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>클로저가 모든 홀수에 대해 0을 반환하도록 재작성해 봅시다.</p>
</blockquote>

<p>클로저를 더 간결하게 작성하기 위한 여러 개의 옵션이 있습니다. 클로저의 타입이 이미 알려진 경우, 가령 ‘대리자 (delegate)’ 의 ‘콜백 (callback)’ 등인 경우, 매개 변수의 타입, 반환 값의 타입, 또는 두 가지 모두를 생략할 수 있습니다. 단일 문장으로 된 클로저는 그 한 문장의 값을 암시적으로 반환합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">mappedNumbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">number</span> <span class="p">})</span>
<span class="nf">print</span><span class="p">(</span><span class="n">mappedNumbers</span><span class="p">)</span>
<span class="c1">// "[60, 57, 21, 36]" 을 출력합니다.</span>
</code></pre></div></div>

<p>매개 변수를 이름 대신 번호로 참조 할 수도 있습니다-이 접근 방법은 클로저가 아주 짧을 때 특히 유용합니다. 함수의 마지막 인자로 전달된 클로저는 괄호 바로 뒤에 나타낼 수 있습니다. 클로저가 함수의 유일한 인자인 경우에는, 괄호를 완전히 생략 할 수도 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">sortedNumbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">sorted</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="n">sortedNumbers</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="objects-and-classes-객체와-클래스">Objects and Classes (객체와 클래스)</h4>

<p><code class="highlighter-rouge">class</code> 뒤에 그 클래스 이름을 쓰면 ‘클래스 (class)’ 를 만들게 됩니다. 클래스에서 속성의 선언은, 그것이 클래스 영역 안에 있다는 것만 빼면, 그냥 상수나 변수의 선언과 방법이 똑같습니다. 마찬가지로, 메소드와 함수의 선언도 같은 방법으로 하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Shape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">numberOfSides</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"A shape with </span><span class="se">\(</span><span class="n">numberOfSides</span><span class="se">)</span><span class="s"> sides."</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">let</code> 을 써서 상수 속성을 추가해 봅시다. 인자를 받는 또 다른 메소드도 추가해 봅시다.</p>
</blockquote>

<p>클래스의 인스턴스를 만들려면 클래스 이름 뒤에 괄호를 써주면 됩니다. ‘점 구문 표현 (dot syntax)’ 으로 그 인스턴스의 속성과 메소드에 접근할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">shape</span> <span class="o">=</span> <span class="kt">Shape</span><span class="p">()</span>
<span class="n">shape</span><span class="o">.</span><span class="n">numberOfSides</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">var</span> <span class="nv">shapeDescription</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span>
</code></pre></div></div>

<p>이 버전의 <code class="highlighter-rouge">Shape</code> 클래스에는 뭔가 중요한 것이 누락됐습니다: 인스턴스가 만들어질 때 클래스를 설정하는 ‘초기자 (initializer)’ 말입니다. <code class="highlighter-rouge">init</code> 을 사용하여 하나 만들어 봅시다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">NamedShape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">numberOfSides</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"A shape with </span><span class="se">\(</span><span class="n">numberOfSides</span><span class="se">)</span><span class="s"> sides."</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>‘초기자’ 의 <code class="highlighter-rouge">name</code> 인자와 <code class="highlighter-rouge">name</code> 속성을 구별하기 위해 <code class="highlighter-rouge">self</code> 를 사용하는 방법에 주목하기 바랍니다. 초기자의 인자는 클래스 인스턴스를 만들 때 전달되는 데 이는 함수 호출에서 그런 것과 비슷합니다. 모든 속성에는 값이 할당돼야 합니다-(<code class="highlighter-rouge">numberOfSides</code> 처럼) 선언에서든 (<code class="highlighter-rouge">name</code> 처럼) ‘초기자’ 에서든 말입니다.</p>

<p>객체를 해제하기 전에 어떤 정리 작업을 수행해야 할 경우 <code class="highlighter-rouge">deinit</code> 을 사용하여 ‘정리자 (deinitializer)’ 를 만들도록 합니다.</p>

<p>‘하위 클래스 (subclasses)’ 는 클래스 이름 뒤에, 콜론으로 구분된, ‘상위 클래스 (superclass)’ 이름을 포함합니다. 클래스가 어떤 ‘표준 근원 클래스 (standard root class)’ 의 ‘하위 클래스’ 여야 한다는 ‘필수 조건 (requirement)’ 은 전혀 없으므로, 필요에 따라 ‘상위 클래스’ 를 포함할 수도 있고 생략할 수도 있습니다.</p>

<p>‘하위 클래스’ 의 메소드가 ‘상위 클래스’ 의 구현을 ‘재정의 (override)’ 할 경우 <code class="highlighter-rouge">override</code> 를 써서 표시합니다—우연히 메소드를 재정의하면서, <code class="highlighter-rouge">override</code> 를 붙이지 않을 경우, 컴파일러는 에러라고 감지합니다. 컴파일러는 메소드에 <code class="highlighter-rouge">override</code> 를 붙이고도 실제로는 ‘상위 클래스’ 의 어떤 메소드도 재정의하지 않는 경우도 감지합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Square</span><span class="p">:</span> <span class="kt">NamedShape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Double</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">numberOfSides</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">area</span><span class="p">()</span> <span class="o">-&gt;</span>  <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sideLength</span> <span class="o">*</span> <span class="n">sideLength</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"A square with sides of length </span><span class="se">\(</span><span class="n">sideLength</span><span class="se">)</span><span class="s">."</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">test</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mf">5.2</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"my test square"</span><span class="p">)</span>
<span class="n">test</span><span class="o">.</span><span class="nf">area</span><span class="p">()</span>
<span class="n">test</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>반지름과 이름을 초기자의 인자로 받는 <code class="highlighter-rouge">Circle</code> 을 이라는 <code class="highlighter-rouge">NamedShape</code> 의 ‘하위 클래스’ 를 만들어 봅시다. <code class="highlighter-rouge">Circle</code> 클래스에 <code class="highlighter-rouge">area()</code> 와 <code class="highlighter-rouge">simpleDescription()</code> 메소드를 구현해 봅시다.</p>
</blockquote>

<p>저장되는 간단한 속성 외에도, ‘getter (획득자)’ 와 ‘setter (설정자)’ 를 가지는 속성도 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">EquilateralTriangle</span><span class="p">:</span> <span class="kt">NamedShape</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">numberOfSides</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">perimeter</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">sideLength</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="n">sideLength</span> <span class="o">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"An equilateral triangle with sides of length </span><span class="se">\(</span><span class="n">sideLength</span><span class="se">)</span><span class="s">."</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">triangle</span> <span class="o">=</span> <span class="kt">EquilateralTriangle</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mf">3.1</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"a triangle"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">triangle</span><span class="o">.</span><span class="n">perimeter</span><span class="p">)</span>
<span class="c1">// "9.3" 을 출력합니다.</span>
<span class="n">triangle</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="mf">9.9</span>
<span class="nf">print</span><span class="p">(</span><span class="n">triangle</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span>
<span class="c1">// "3.3000000000000003" 을 출력합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">perimeter</code> 에 대한 ‘setter (설정자)’ 에서, 새로운 값의 암시적인 이름은 <code class="highlighter-rouge">newValue</code> 입니다. <code class="highlighter-rouge">set</code> 뒤에 명시적인 이름을 괄호 안에 써서 제공할 수도 있습니다.</p>

<p><code class="highlighter-rouge">EquilateralTriangle</code> 클래스의 초기자는 다음의 세 단계를 가지고 있음에 주목하기 바랍니다:</p>

<ol>
  <li>그 ‘하위 클래스’ 가 선언한 속성의 값을 설정하기</li>
  <li>‘상위 클래스’ 의 초기자 호출하기</li>
  <li>‘상위 클래스’ 에서 정의한 속성의 값을 바꾸기. 이 시점에서 메소드, ‘getter (획득자)’, 또는 ‘setter (설정자)’ 를 사용하는 모든 추가적인 설정 작업들도 수행할 수 있습니다.</li>
</ol>

<p>속성을 계산할 필요는 없지만 새 값의 설정 전후에 실행될 코드를 제공할 필요가 있을 경우, <code class="highlighter-rouge">willSet</code> 과  <code class="highlighter-rouge">didSet</code> 을 사용하면 됩니다. 제공한 코드는 초기자 외부에서 값의 변경이 있을 때마다 실행됩니다. 예를 들어, 아래 클래스는 삼각형의 한 변의 길이가 항상 사각형의 한 변의 길이와 같도록 만들어 줍니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">TriangleAndSquare</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">triangle</span><span class="p">:</span> <span class="kt">EquilateralTriangle</span> <span class="p">{</span>
        <span class="k">willSet</span> <span class="p">{</span>
            <span class="n">square</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">sideLength</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">square</span><span class="p">:</span> <span class="kt">Square</span> <span class="p">{</span>
        <span class="k">willSet</span> <span class="p">{</span>
            <span class="n">triangle</span><span class="o">.</span><span class="n">sideLength</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">sideLength</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">square</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">triangle</span> <span class="o">=</span> <span class="kt">EquilateralTriangle</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">triangleAndSquare</span> <span class="o">=</span> <span class="kt">TriangleAndSquare</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"another test shape"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">triangleAndSquare</span><span class="o">.</span><span class="n">square</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span>
<span class="c1">// "10.0" 을 출력합니다.</span>
<span class="nf">print</span><span class="p">(</span><span class="n">triangleAndSquare</span><span class="o">.</span><span class="n">triangle</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span>
<span class="c1">// "10.0" 을 출력합니다.</span>
<span class="n">triangleAndSquare</span><span class="o">.</span><span class="n">square</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"larger square"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">triangleAndSquare</span><span class="o">.</span><span class="n">triangle</span><span class="o">.</span><span class="n">sideLength</span><span class="p">)</span>
<span class="c1">// "50.0" 을 출력합니다.</span>
</code></pre></div></div>

<p>‘옵셔널 (optional)’ 값으로 작업할 때, 메소드, 속성, 그리고 ‘첨자 연산 (subscripting)’ 등의 연산 전에 <code class="highlighter-rouge">?</code> 를 쓸 수가 있습니다. <code class="highlighter-rouge">?</code> 앞의 값이 <code class="highlighter-rouge">nil</code> 이면, <code class="highlighter-rouge">?</code> 이후의 모든 것은 무시되고 전체 표현식의 값이 <code class="highlighter-rouge">nil</code> 이 됩니다. 그렇지 않다면, 옵셔널 값은 풀리고, <code class="highlighter-rouge">?</code> 이후의 모든 것은 이 ‘풀린 값 (unwrapped value)’ 에 대해 작용합니다. 두 경우 모두, 전체 표현식은 옵셔널 값입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">optionalSquare</span><span class="p">:</span> <span class="kt">Square</span><span class="p">?</span> <span class="o">=</span> <span class="kt">Square</span><span class="p">(</span><span class="nv">sideLength</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">,</span> <span class="nv">name</span><span class="p">:</span> <span class="s">"optional square"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">sideLength</span> <span class="o">=</span> <span class="n">optionalSquare</span><span class="p">?</span><span class="o">.</span><span class="n">sideLength</span>
</code></pre></div></div>

<h3 id="enumerations-and-structures-열거체와-구조체">Enumerations and Structures (열거체와 구조체)</h3>

<p>열거체를 만들려면 <code class="highlighter-rouge">enum</code> 을 사용합니다. 클래스와 다른 모든 ‘이름있는 타입들 (named types)’ 처럼, 열거체도 자신과 관련된 메소드를 가질 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Rank</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ace</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="n">two</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="n">four</span><span class="p">,</span> <span class="n">five</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span> <span class="n">seven</span><span class="p">,</span> <span class="n">eight</span><span class="p">,</span> <span class="n">nine</span><span class="p">,</span> <span class="n">ten</span>
    <span class="k">case</span> <span class="n">jack</span><span class="p">,</span> <span class="n">queen</span><span class="p">,</span> <span class="n">king</span>
    <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">ace</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"ace"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">jack</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"jack"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">queen</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"queen"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">king</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"king"</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">rawValue</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">ace</span> <span class="o">=</span> <span class="kt">Rank</span><span class="o">.</span><span class="n">ace</span>
<span class="k">let</span> <span class="nv">aceRawValue</span> <span class="o">=</span> <span class="n">ace</span><span class="o">.</span><span class="n">rawValue</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>‘원시 값 (raw value)’ 을 비교하는 방식으로 두 <code class="highlighter-rouge">Rank</code> 값을 비교하는 함수를 작성해 봅시다.</p>
</blockquote>

<p>기본적으로, 스위프트는 ‘원시 값 (raw value)’ 을 ‘0’ 에서 시작하여 매번 ‘1’ 씩 증가하며 할당하는데, 지정된 값을 명시하면 이 방식을 바꿀 수도 있습니다. 위의 예제에서, <code class="highlighter-rouge">Ace</code> 의 ‘원시 값 (raw value)’ 은 <code class="highlighter-rouge">1</code> 로 명시되었으며, 나머지 ‘원시 값’ 들은 순서대로 할당됩니다. 열거체의 원시 (값) 타입으로 ‘문자열’ 이나 ‘부동-소수점 수’ 를 사용하는 것도 가능합니다. ‘열거체 경우 값 (enumeration case)’ 의 ‘원시 값’ 에 접근하려면 <code class="highlighter-rouge">rawValue</code> 속성을 사용하면 됩니다.</p>

<p>‘원시 값’ 을 써서 열거체의 인스턴스를 만들려면 <code class="highlighter-rouge">init?(rawValue:)</code> 초기자를 사용하면 됩니다. 이는 ‘원시 값’ 에 해당하는 ‘열거체의 경우 값 (enumeration case)’ 을 반환하거나 또는 해당하는 <code class="highlighter-rouge">Rank</code> 가 없을 경우 <code class="highlighter-rouge">nil</code> 을 반환합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">convertedRank</span> <span class="o">=</span> <span class="kt">Rank</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">threeDescription</span> <span class="o">=</span> <span class="n">convertedRank</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>열거체의 ‘경우 값 (case values)’ 은 실제 값이며, 단순히 ‘원시 값 (raw values)’ 을 표기하는 또 다른 방법인 것이 아닙니다. 실제로, ‘경우 값’ 에 의미있는 ‘원시 값’ 이 없을 때는, 굳이 이를 제공할 필요가 없습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Suit</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">spades</span><span class="p">,</span> <span class="n">hearts</span><span class="p">,</span> <span class="n">diamonds</span><span class="p">,</span> <span class="n">clubs</span>
    <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">spades</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"spades"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">hearts</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"hearts"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">diamonds</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"diamonds"</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">clubs</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"clubs"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">hearts</span> <span class="o">=</span> <span class="kt">Suit</span><span class="o">.</span><span class="n">hearts</span>
<span class="k">let</span> <span class="nv">heartsDescription</span> <span class="o">=</span> <span class="n">hearts</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">Suit</code> 에 <code class="highlighter-rouge">color()</code> 메소드를 추가하여, ‘스페이드’ 와 ‘클럽’ 일 때는 “검정색” 을 반환하고, ‘하트’ 와 ‘다이아몬드’ 일 때는 “빨간색” 을 반환하도록 해 봅시다.</p>
</blockquote>

<p>위에서 열거체의 ‘<code class="highlighter-rouge">hearts</code> 경우 값 (case)’ 을 참조할 때 두 가지 다른 방법을 썼음에 주목하기 바랍니다: <code class="highlighter-rouge">hearts</code> 상수에 값을 할당할 때는, 열거체 경우 값 <code class="highlighter-rouge">Suit.hearts</code> 이 전체 이름으로 참조됐는데 이는 이 상수에 명시적인 타입이 지정된 것이 없기 때문입니다. ‘switch (스위치)’ 구문 내부에서는, 열거체의 기본 설정 값이 <code class="highlighter-rouge">.hearts</code> 라는 단축된 양식으로 참조되었으며 이는 <code class="highlighter-rouge">self</code> 값이 이미 ‘suit’ 인 것을 알고 있기 때문입니다. 이처럼 값의 타입을 이미 알고 있을 때는 언제든 단축된 양식을 사용할 수 있습니다.</p>

<p>열거체가 원시 값을 가질 경우, 이 값은 선언의 일부로써 결정되며, 이는 특정한 ‘열거체 경우 값 (enumeration case)’ 의 모든 인스턴스는 항상 같은 ‘원시 값’ 을 가진다는 것을 의미합니다. 열거체의 경우 값은 또 다른 선택을 할 수 있는데 그 경우 값에 ‘관련 값’ 을 가지도록 하는 것입니다-이 값이 결정될 때는 인스턴스를 만들 때이므로, ‘열거체 경우 값’ 의 개별 인스턴스마다 다를 수 있습니다. ‘관련 값 (associated values)’ 은 ‘열거체 경우 값 인스턴스 (enumeration case instance)’ 의 ‘저장 속성’ 처럼 동작하는 것으로 생각할 수 있습니다. 예를 들어, 서버에서 일출 시간과 일몰 시간을 요청하는 경우를 고려해 봅시다. 서버의 응답은 요청한 정보일 수도 있고, 또는 뭔가 잘못됐을 경우에 대한 설명일 수도 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">ServerResponse</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">result</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">failure</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">success</span> <span class="o">=</span> <span class="kt">ServerResponse</span><span class="o">.</span><span class="nf">result</span><span class="p">(</span><span class="s">"6:00 am"</span><span class="p">,</span> <span class="s">"8:09 pm"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">failure</span> <span class="o">=</span> <span class="kt">ServerResponse</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="s">"Out of cheese."</span><span class="p">)</span>

<span class="k">switch</span> <span class="n">success</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">result</span><span class="p">(</span><span class="n">sunrise</span><span class="p">,</span> <span class="n">sunset</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Sunrise is at </span><span class="se">\(</span><span class="n">sunrise</span><span class="se">)</span><span class="s"> and sunset is at </span><span class="se">\(</span><span class="n">sunset</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Failure...  </span><span class="se">\(</span><span class="n">message</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="s">"Sunrise is at 6:00 am and sunset is at 8:09 pm."</span> <span class="n">을</span> <span class="n">출력합니다</span><span class="o">.</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">ServerResponse</code> 와 ‘switch (스위치)’ 구문에 세 번째 ‘경우 값 (case)’ 을 추가해 봅시다.</p>
</blockquote>

<p>해당하는 ‘switch cases (스위치 경우 값)’ 을 맞춰볼 때 어떻게 <code class="highlighter-rouge">ServerResponse</code> 값에서 일출 시간과 일몰 시간을 추출하고 있는지 주목하기 바랍니다.</p>

<p>구조체를 만들려면 <code class="highlighter-rouge">struct</code> 를 사용합니다. 구조체는 메소드와 초기자를 포함하여, 클래스에서 지원하는 것과 같은 동작들을 많이 지원합니다. 이런 구조체와 클래스의 가장 중요한 차이점 중 하나는 코드내에서 구조체는 항상 복사에 의해 전달된다는 것으로, 클래스는 참조에 의해 전달된다는 것에서 차이가 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Card</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">rank</span><span class="p">:</span> <span class="kt">Rank</span>
    <span class="k">var</span> <span class="nv">suit</span><span class="p">:</span> <span class="kt">Suit</span>
    <span class="kd">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"The </span><span class="se">\(</span><span class="n">rank</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span><span class="se">)</span><span class="s"> of </span><span class="se">\(</span><span class="n">suit</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">threeOfSpades</span> <span class="o">=</span> <span class="kt">Card</span><span class="p">(</span><span class="nv">rank</span><span class="p">:</span> <span class="o">.</span><span class="n">three</span><span class="p">,</span> <span class="nv">suit</span><span class="p">:</span> <span class="o">.</span><span class="n">spades</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">threeOfSpadesDescription</span> <span class="o">=</span> <span class="n">threeOfSpades</span><span class="o">.</span><span class="nf">simpleDescription</span><span class="p">()</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>개별 카드가 ‘계급 (rank)’ 과 ‘패 (suit)’<sup id="fnref:suit" role="doc-noteref"><a href="#fn:suit" class="footnote">4</a></sup> 의 조합인, 온전한 카드 한 벌을 담고 있는 배열을 반환하는 함수를 만들어 봅시다.</p>
</blockquote>

<h3 id="protocols-and-extensions-프로토콜-규약-과-확장">Protocols and Extensions (프로토콜-규약-과 확장)</h3>

<p>‘프로토콜 (protocol; 규약)’ 을 선언하려면 <code class="highlighter-rouge">protocol</code> 를 사용하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">ExampleProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">simpleDescription</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">adjust</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>‘클래스 (classes)’, ‘열거체 (enumerations)’, 그리고 ‘구조체 (structs)’ 모두 ‘프로토콜’ 을 ‘채택 (adopt)’<sup id="fnref:adopt" role="doc-noteref"><a href="#fn:adopt" class="footnote">5</a></sup> 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SimpleClass</span><span class="p">:</span> <span class="kt">ExampleProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">simpleDescription</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"A very simple class."</span>
    <span class="k">var</span> <span class="nv">anotherProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">69105</span>
    <span class="kd">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">simpleDescription</span> <span class="o">+=</span> <span class="s">"  Now 100% adjusted."</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="kt">SimpleClass</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="nf">adjust</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">aDescription</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">simpleDescription</span>

<span class="kd">struct</span> <span class="kt">SimpleStructure</span><span class="p">:</span> <span class="kt">ExampleProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">simpleDescription</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"A simple structure"</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">simpleDescription</span> <span class="o">+=</span> <span class="s">" (adjusted)"</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">b</span> <span class="o">=</span> <span class="kt">SimpleStructure</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="nf">adjust</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">bDescription</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">simpleDescription</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">ExampleProtocol</code> 에 또 다른 ‘필수 조건 (requirement)’ 을 추가해 봅시다. <code class="highlighter-rouge">SimpleClass</code> 와 <code class="highlighter-rouge">SimpleStructure</code> 가 여전히 이 프로토콜을 ‘준수 (conform)’ 하도록 하려면 무엇을 바꿔야 할까요?</p>
</blockquote>

<p><code class="highlighter-rouge">SimpleStructure</code> 선언 내부에서 메소드가 구조체를 수정하고 있음을 표시하기 위해 <code class="highlighter-rouge">mutating</code> 키워드를 사용함에 주목하기 바랍니다. <code class="highlighter-rouge">SimpleClass</code> 선언에서는 어떤 메소드도 ‘mutating (변경)’ 표시를 할 필요가 없는데 이는 클래스 메소드는 항상 클래스를 수정할 수 있기 때문입니다.</p>

<p>기존 타입에 <code class="highlighter-rouge">extension</code> 을 사용하면 새 기능, 가령 새로운 메소드나 ‘계산 속성 (computed properties)’ 을 추가할 수 있습니다. ‘extension (확장)’ 을 사용하면 다른 곳에서 선언된 타입이나, 또는 라이브러리나 프레임웍에서 ‘import (불러온)’ 타입 까지도, 특정 ‘프로토콜을 따르도록 (protocol conformance)’ 만들 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Int</span><span class="p">:</span> <span class="kt">ExampleProtocol</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">simpleDescription</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"The number </span><span class="se">\(</span><span class="k">self</span><span class="se">)</span><span class="s">"</span>
    <span class="p">}</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span> <span class="o">+=</span> <span class="mi">42</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="mi">7</span><span class="o">.</span><span class="n">simpleDescription</span><span class="p">)</span>
<span class="s">"The number 7"</span> <span class="n">을</span> <span class="n">출력합니다</span><span class="o">.</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">Double</code> 타입에 대한 ‘extension (확장)’ 을 만들어서 <code class="highlighter-rouge">absoluteValue</code> 속성을 추가해 봅시다.</p>
</blockquote>

<p>프로토콜 이름은 마치 또 다른 ‘이름있는 타입 (named type)’ 인 것처럼 사용할 수 있습니다-예를 들어, 서로 다른 타입을 가지지만 모두 단일한 프로토콜을 준수하는 객체들의 ‘컬렉션 (집합체)’ 를 만드는데 사용할 수도 있습니다. 값의 타입이 프로토콜 타입인 경우에는, 프로토콜 정의 밖의 메소드를 사용할 수 없습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">protocolValue</span><span class="p">:</span> <span class="kt">ExampleProtocol</span> <span class="o">=</span> <span class="n">a</span>
<span class="nf">print</span><span class="p">(</span><span class="n">protocolValue</span><span class="o">.</span><span class="n">simpleDescription</span><span class="p">)</span>
<span class="c1">// "A very simple class.  Now 100% adjusted." 를 출력합니다.</span>
<span class="c1">// print(protocolValue.anotherProperty)  // 주석을 제거하면 에러가 발생합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">protocolValue</code> 변수의 ‘실행 시간 타입 (runtime type)’ 이 <code class="highlighter-rouge">SimpleClass</code> 일지라도, 컴파일러는 주어진 타입을 <code class="highlighter-rouge">ExampleProtocol</code> 로 취급합니다. 이것은 프로토콜을 준수하게 되면 클래스 구현부의 메소드나 속성에 실수로라도 접근할 수 없다는 것을 의미합니다.</p>

<h3 id="error-handling-에러-처리">Error Handling (에러 처리)</h3>

<p>‘에러 (errors)’ 를 나타내려면 <code class="highlighter-rouge">Error</code> 프로토콜을 ‘채택 (adopt)’ 한 타입을 사용하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">PrinterError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">outOfPaper</span>
    <span class="k">case</span> <span class="n">noToner</span>
    <span class="k">case</span> <span class="n">onFire</span>
<span class="p">}</span>
</code></pre></div></div>

<p>에러를 던지려면 <code class="highlighter-rouge">throw</code> 를 사용하고 에러를 던질 수 있는 함수라고 표시하려면 <code class="highlighter-rouge">throws </code>를 사용하면 됩니다. 함수에서 에러를 던지면, 그 함수는 즉시 반환되며 함수를 호출한 코드에서 그 에러를 처리하게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="nv">job</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">toPrinter</span> <span class="nv">printerName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">printerName</span> <span class="o">==</span> <span class="s">"Never Has Toner"</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">PrinterError</span><span class="o">.</span><span class="n">noToner</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">"Job sent"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>에러 처리에는 여러 가지 방법이 있습니다. 한 가지 방법은 <code class="highlighter-rouge">do-catch</code> 문를 사용하는 것입니다. <code class="highlighter-rouge">do</code> 블럭 안에서, 에러를 던질 수 있는 코드를 표시하려면 그 앞에 <code class="highlighter-rouge">try</code> 를 써주면 됩니다. <code class="highlighter-rouge">catch</code> 블럭 안에서는, 다른 이름을 주지 않았을 경우 에러가 자동으로 <code class="highlighter-rouge">error</code> 라는 이름을 가지게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">printerResponse</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">send</span><span class="p">(</span><span class="nv">job</span><span class="p">:</span> <span class="mi">1040</span><span class="p">,</span> <span class="nv">toPrinter</span><span class="p">:</span> <span class="s">"Bi Sheng"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">printerResponse</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Job sent" 를 츨력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p>프린터 이름을 <code class="highlighter-rouge">"Never Has Toner"</code> 로 바꿔서, <code class="highlighter-rouge">send(job:toPrinter:)</code> 함수가 에러를 던지도록 해 봅시다.</p>
</blockquote>

<p>여러 개의 <code class="highlighter-rouge">catch</code> 블럭을 제공해서 지정된 에러들을 처리할 수 있습니다. ‘switch (스위치)’ 의 <code class="highlighter-rouge">case</code> 뒤에서 하듯 <code class="highlighter-rouge">catch</code> 뒤에 ‘유형 (pattern)’ 을 작성하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">printerResponse</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">send</span><span class="p">(</span><span class="nv">job</span><span class="p">:</span> <span class="mi">1440</span><span class="p">,</span> <span class="nv">toPrinter</span><span class="p">:</span> <span class="s">"Gutenberg"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">printerResponse</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">PrinterError</span><span class="o">.</span><span class="n">onFire</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"I'll just put this over here, with the rest of the fire."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="k">let</span> <span class="nv">printerError</span> <span class="k">as</span> <span class="kt">PrinterError</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Printer error: </span><span class="se">\(</span><span class="n">printerError</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Job sent" 를 츨력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">do</code> 블럭 내부에 에러를 던지는 코드를 추가해 봅시다. 에러가 첫 번째 <code class="highlighter-rouge">catch</code> 블럭에서 처리되도록 하려면 어떤 종류의 에러를 던지면 됩니까? 두 번째와 세 번째 블럭에서 되게 하려면요?</p>
</blockquote>

<p>에러를 처리하는 또 다른 방법은 <code class="highlighter-rouge">try?</code> 를 사용하여 결과를 옵셔널로 변환하는 것입니다. 함수가 에러를 던지면, 지정된 그 에러를 버리고 결과를 <code class="highlighter-rouge">nil</code> 이 됩니다. 다른 경우라면, 결과는 함수가 반환한 값을 가지고 있는 옵셔널이 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">printerSuccess</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="nf">send</span><span class="p">(</span><span class="nv">job</span><span class="p">:</span> <span class="mi">1884</span><span class="p">,</span> <span class="nv">toPrinter</span><span class="p">:</span> <span class="s">"Mergenthaler"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">printerFailure</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="nf">send</span><span class="p">(</span><span class="nv">job</span><span class="p">:</span> <span class="mi">1885</span><span class="p">,</span> <span class="nv">toPrinter</span><span class="p">:</span> <span class="s">"Never Has Toner"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">defer</code> 를 사용하여 작성된 코드 블럭은, 함수 반환의 바로 직전, 함수 내의 모든 다른 코드의 이후에 실행됩니다. 이 코드는 함수가 에러를 던지는 것과는 상관없이 실행됩니다. <code class="highlighter-rouge">defer</code> 를 사용하면, 서로 다른 시간에 실행될 필요가 있는, ‘설정 (setup)’ 코드와 ‘정리 (cleanup)’ 코드도 서로 이웃하게 작성할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">fridgeIsOpen</span> <span class="o">=</span> <span class="kc">false</span>
<span class="k">let</span> <span class="nv">fridgeContent</span> <span class="o">=</span> <span class="p">[</span><span class="s">"milk"</span><span class="p">,</span> <span class="s">"eggs"</span><span class="p">,</span> <span class="s">"leftovers"</span><span class="p">]</span>

<span class="kd">func</span> <span class="nf">fridgeContains</span><span class="p">(</span><span class="n">_</span> <span class="nv">food</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="n">fridgeIsOpen</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">defer</span> <span class="p">{</span>
        <span class="n">fridgeIsOpen</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">fridgeContent</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">food</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
<span class="nf">fridgeContains</span><span class="p">(</span><span class="s">"banana"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">fridgeIsOpen</span><span class="p">)</span>
<span class="c1">// "false" 를 출력합니다.</span>
</code></pre></div></div>

<h3 id="generics-일반화">Generics (일반화)</h3>

<p>‘일반화된 함수 (generic function)’ 나 ‘일반화된 타입 (generic type)’ 을 만들려면 ‘꺽쇠 괄호 (angle brackets)’ 안에 이름을 적으면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">makeArray</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;</span><span class="p">(</span><span class="n">repeating</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">Item</span><span class="p">,</span> <span class="nv">numberOfTimes</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Item</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Item</span><span class="p">]()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">numberOfTimes</span> <span class="p">{</span>
        <span class="n">result</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
<span class="nf">makeArray</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="s">"knock"</span><span class="p">,</span> <span class="nv">numberOfTimes</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>‘클래스 (classes)’, ‘열거체 (enumerations)’, 그리고 ‘구조체 (structures)’ 뿐만 아니라 함수와 메소드도 ‘일반화된 양식 (generic forms)’ 으로 만들 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스위프트 표준 라이브러리의 옵셔널 타입을 재구현한 것임</span>
<span class="kd">enum</span> <span class="kt">OptionalValue</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">case</span> <span class="k">none</span>
    <span class="k">case</span> <span class="nf">some</span><span class="p">(</span><span class="kt">Wrapped</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">possibleInteger</span><span class="p">:</span> <span class="kt">OptionalValue</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">.</span><span class="k">none</span>
<span class="n">possibleInteger</span> <span class="o">=</span> <span class="o">.</span><span class="nf">some</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<p>본문 바로 앞에 <code class="highlighter-rouge">where</code> 를 사용하면 ‘필수 조건들의 목록 (a list of requirements)’ 을 지정할 수 있습니다-예를 들어, 이 타입은 필수적으로 어떤 프로토콜을 구현해야 한다거나, 두 타입은 반드시 필수적으로 같아야 한다거나, 또는 이 클래스는 필수적으로 특정 ‘상위 클래스’ 를 가져야 한다거나 등을 지정할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">anyCommonElements</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Sequence</span><span class="p">,</span> <span class="kt">U</span><span class="p">:</span> <span class="kt">Sequence</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">lhs</span><span class="p">:</span> <span class="kt">T</span><span class="p">,</span> <span class="n">_</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="k">where</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span><span class="p">,</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">U</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">lhsItem</span> <span class="k">in</span> <span class="n">lhs</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">rhsItem</span> <span class="k">in</span> <span class="n">rhs</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">lhsItem</span> <span class="o">==</span> <span class="n">rhsItem</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">true</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="nf">anyCommonElements</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<blockquote>
  <p>실험</p>

  <p><code class="highlighter-rouge">anyCommonElements(_:_:)</code> 함수를 수정하여 두 개의 ‘sequence (나열값들)’ 에 공통된 원소의 배열을 반환하는 함수를 만들어 봅시다.</p>
</blockquote>

<p><code class="highlighter-rouge">&lt;T: Equatable&gt;</code> 이라고 적는 것은 <code class="highlighter-rouge">&lt;T&gt; ... where T: Equatable</code> 이라고 적는 것과 같습니다.</p>

<h3 id="참고-자료">참고 자료</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:A-Swift-Tour" role="doc-endnote">
      <p>원문은 <a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html">A Swift Tour</a> 에서 확인할 수 있습니다. <a href="#fnref:A-Swift-Tour" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:break-out" role="doc-endnote">
      <p>이 말은 스위프트의 ‘switch’ 구문에서는 각 ‘case’ 절마다 끝에 ‘break’ 를 쓸 필요는 없다는 말을 의미합니다. <a href="#fnref:break-out" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:first-class" role="doc-endnote">
      <p>프로그래밍에서 ‘일급 (first-class)’ 이라는 말은 특정 대상을 ‘객체’ 와 동급으로 사용할 수 있다는 것을 의미합니다. 예를 들어 ‘객체’ 처럼 인자로 전달할 수도 있고, 함수에서 반환할 수 있으며, 다른 변수 등에 할당할 수도 있는 대상이 있다면 이 대상을 ‘일급 (first-class)’ 이라고 할 수 있습니다. 본문 내용은 스위프트에서는 ‘함수’ 도 ‘객체’ 처럼 ‘first-class’ 라서 앞의 동작들을 모두 다 수행할 수 있다는 것을 의미합니다. 보다 자세한 내용은 위키피디아의 <a href="https://en.wikipedia.org/wiki/First-class_citizen">First-class citizen</a> 과 <a href="https://ko.wikipedia.org/wiki/일급_객체">일급 객체</a> 항목을 참고하기 바랍니다. <a href="#fnref:first-class" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:suit" role="doc-endnote">
      <p>영어로 ‘suit’ 에는 카드의 ‘패’ 라는 의미가 있으며, ‘다이아몬드’, ‘하트’ 등이 이 ‘suit’ 입니다. 서양 카드에는 4 종류의 ‘suits’ 가 있습니다. <a href="#fnref:suit" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:adopt" role="doc-endnote">
      <p>‘프로토콜을 채택한다’ 는 것의 의미는 <a href="/swift/language/grammar/protocol/2016/03/03/Protocols.html">Protocols (규약)</a> 앞 부분에 잘 설명되어 있습니다. ‘프로토콜을 준수한다’ 는 말과는 늬앙스가 조금 다른 것 같습니다. <a href="#fnref:adopt" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET