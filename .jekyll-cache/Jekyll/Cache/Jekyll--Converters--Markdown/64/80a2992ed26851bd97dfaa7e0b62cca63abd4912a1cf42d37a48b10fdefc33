I":b<blockquote>
  <p>Apple 에서 공개한 <a href="https://docs.swift.org/swift-book/">The Swift Programming Language (Swift 5.2)</a> 책의 <a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html">Collection Types</a> 부분<sup id="fnref:Collection-Types" role="doc-noteref"><a href="#fn:Collection-Types" class="footnote">1</a></sup>을 번역하고 정리한 글입니다.</p>

  <p>현재 전체 중에서 번역 완료된 목록은 <a href="/swift/programming/language/grammar/2017/02/28/The-Swift-Programming-Language.html">Swift 5.2: Swift Programming Language (스위프트 프로그래밍 언어)</a> 에서 확인할 수 있습니다.</p>
</blockquote>

<h2 id="collection-types-집합체-타입">Collection Types (집합체 타입)</h2>

<p>스위프트는 값의 집합을 저장하는 용도로 세 가지의 주요 <em>컬렉션 타입 (collection types; 집합체 타입)</em><sup id="fnref:collections" role="doc-noteref"><a href="#fn:collections" class="footnote">2</a></sup> 을 제공하는데, 이는 ‘배열 (arrays)’, ‘셋 (sets)<sup id="fnref:sets" role="doc-noteref"><a href="#fn:sets" class="footnote">3</a></sup>’, 그리고 ‘딕셔너리 (dictionaries; 사전)<sup id="fnref:dictionaries" role="doc-noteref"><a href="#fn:dictionaries" class="footnote">4</a></sup>’ 입니다. 배열은 값들이 순서에 따라 모여 있는 컬렉션이고, 셋은 값들이 순서는 없지만 각각 하나씩만 존재하는 컬렉션입니다. 딕셔너리는 ‘키-값 관련-묶음 (key-value associations)’ 들이 순서없이 모여 있는 컬렉션입니다.</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Collection-Types-array-set-dictionary.jpg" alt="Array-Set-Dictionary" /></p>

<p>스위프트에 있는 배열, 셋, 그리고 딕셔너리는 저장할 수 있는 값과 키의 타입을 명확하게 알고 있습니다. 이는 실수로 컬렉션에 잘못된 타입의 값을 넣을 가능성은 없다는 의미입니다. 또 컬렉션에서 가져오는 값의 타입을 확신할 수 있다는 의미이기도 합니다.</p>

<blockquote>
  <p>스위프트의 배열, 셋 그리고 딕셔너리 타입은 <em>일반화된 집합체 (generic collections)</em> 방식으로 구현되었습니다. 일반화된 타입과 일반화된 집합체 (generic types and collections) 에 대한 더 자세한 내용은 <a href="/swift/language/grammar/generic/2020/02/29/Generics.html">Generics (일반화)</a> 를 보도록 합니다.</p>
</blockquote>

<h3 id="mutability-of-collections-집합체의-변경-용이성">Mutability of Collections (집합체의 변경-용이성)</h3>

<p>배열, 셋 또는 딕셔너리를 하나 만들고, 이를 변수에 할당하면, 이렇게 생성된 컬렉션은 <em>변경 가능 (mutable)</em> 합니다. 이는 컬렉션이 생성된 후, 컬렉션에 요소를 추가, 제거, 또는 변경하는 등의 방법으로 컬렉션을 바꿀 (즉 <em>변경할</em>) 수 있다는 의미입니다. 배열, 셋 또는 딕셔너리를 상수에 할당하면 이 컬렉션은 <em>변경 불가능 (immutable)</em> 해져서 크기와 내용을 변경할 수 없습니다.</p>

<blockquote>
  <p>컬렉션을 변경할 필요가 없을 때는 항상 변경 불가능한 컬렉션으로 만드는 습관을 가지도록 합시다. 이렇게 하면 코드를 파악하기 쉬워지며 스위프트 컴파일러가 이 컬렉션의 성능을 최적화할 수 있게 만듭니다.</p>
</blockquote>

<h3 id="arrays-배열">Arrays (배열)</h3>

<p><em>배열 (array)</em> 은 같은 타입의 값들을 순서에 따라 줄지어 저장합니다. 값끼리 같아도 한 배열 안에서 위치가 다르면 여러 번 나타날 수 있습니다.</p>

<blockquote>
  <p>스위프트의 <code class="highlighter-rouge">Array</code> 타입은 ‘Foundation’ 프레임웍에 있는 <code class="highlighter-rouge">NSArray</code> 클래스와 연동되어 (bridged) 있습니다.</p>

  <p>‘Foundation’ 및 ‘Cocoa’ 프레임웍과 <code class="highlighter-rouge">Array</code> 를 같이 사용하는 방법에 대해서는 <a href="https://developer.apple.com/documentation/swift/array#2846730">Bridging Between Array and NSArray</a> 에서 더 자세히 알 수 있습니다.</p>
</blockquote>

<h4 id="array-type-shorthand-syntax-배열-타입-약칭-구문-표현">Array Type Shorthand Syntax (배열 타입 약칭 구문 표현)</h4>

<p>스위프트의 배열 타입을 온전하게 작성하는 방법은 <code class="highlighter-rouge">Array&lt;Element&gt;</code> 이며, 여기서 <code class="highlighter-rouge">Element</code> 는 배열에 저장하는 값의 타입입니다. 또한 배열 타입은 약칭으로 <code class="highlighter-rouge">[Element]</code> 와 같은 형태로 작성할 수도 있습니다. 두 양식의 기능은 동일하지만, 약칭 형태를 권장하며 이 책의 전체에서도 배열 타입은 약칭 형태로 사용하도록 합니다.</p>

<h4 id="creating-an-empty-array-빈-배열-생성하기">Creating an Empty Array (빈 배열 생성하기)</h4>

<p>특정 타입의 빈 배열을 생성하려면 초기자 문법을 사용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">someInts</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>
<span class="nf">print</span><span class="p">((</span><span class="s">"someInts is of type [Int] with </span><span class="se">\(</span><span class="n">someInts</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s"> items."</span><span class="p">)</span>
<span class="c1">// "someInts is of type [Int] with 0 items." 를 출력합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">someInts</code> 변수의 타입은 초기자의 타입으로부터 <code class="highlighter-rouge">[Int]</code> 로 추론할 수 있음을 기억하기 바랍니다.</p>

<p>다른 방법으로, 영역 내에서 이미 타입 정보를 제공하는 경우, 예를 들면 함수 인자에서나 이미 타입이 알려진 변수 또는 상수일 경우에, ‘빈 배열 글자표현 (empty array literal)’ 을 써서 빈 배을을 생성할 수도 있으며, 이 때는 <code class="highlighter-rouge">[]</code> (빈 대괄호 쌍) 만 써주면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">someInts</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1">// someInts 는 이제 Int 타입 값 1 개를 갖습니다.</span>
<span class="n">someInts</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">// someInts 는 이제 빈 배열이 됐지만, 타입은 여전히 [Int] 입니다.</span>
</code></pre></div></div>

<h4 id="creating-an-array-with-a-default-value-기본-설정-값을-가진-배열-생성하기">Creating an Array with a Default Value (기본 설정 값을 가진 배열 생성하기)</h4>

<p>스위프트의 <code class="highlighter-rouge">Array</code> 타입에는 특정 크기의 배열을 생성하면서 모든 값을 동일한 기본 설정 값으로 설정할 수 있는 초기자도 있습니다. 이 초기자에 적절한 타입의 기본 설정 값 (명칭은 <code class="highlighter-rouge">repeating</code>): 과 이 값이 배열에서 반복되야할 횟수 (명칭은 <code class="highlighter-rouge">count</code>): 를 전달하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">threeDoubles</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// threeDoubles 의 타입은 [Double] 이고, 값은 [0.0, 0.0, 0.0] 과 같습니다.</span>
</code></pre></div></div>

<h4 id="creating-an-array-by-adding-two-arrays-together-두-배열을-서로-더해서-하나의-배열-생성하기">Creating an Array by Adding Two Arrays Together (두 배열을 서로 더해서 하나의 배열 생성하기)</h4>

<p>두 개의 기존 배열이 더하기 연산자 (<code class="highlighter-rouge">+</code>) 에 대해 ‘호환성을 가지는 (compatible)’<sup id="fnref:compatible" role="doc-noteref"><a href="#fn:compatible" class="footnote">5</a></sup> 타입들인 경우 서로 더해서 새로운 배열을 생성할 수 있습니다. 새 배열의 타입은 서로 더한 두 배열의 타입으로부터 추론합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">anotherThreeDoubles</span> <span class="o">=</span> <span class="kt">Array</span><span class="p">(</span><span class="nv">repeating</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">,</span> <span class="nv">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// anotherThreeDoubles 의 타입은 [Double] 이고, 값은 [2.5, 2.5, 2.5] 와 같습니다.</span>

<span class="k">var</span> <span class="nv">sixDoubles</span> <span class="o">=</span> <span class="n">threeDoubles</span> <span class="o">+</span> <span class="n">anotherThreeDoubles</span>
<span class="c1">// sixDoubles 의 타입은 [Double] 로 추론되며, 값은 [0.0, 0,0, 0.0, 2.5, 2.5, 2.5] 와 같습니다.</span>
</code></pre></div></div>

<h4 id="creating-an-array-with-an-array-literal-배열-글자표현-을-사용해서-배열-생성하기">Creating an Array with an Array Literal (‘배열 글자표현’ 을 사용해서 배열 생성하기)</h4>

<p><em>배열 글자표현 (array literal)</em><sup id="fnref:literal" role="doc-noteref"><a href="#fn:literal" class="footnote">6</a></sup> 을 써서 배열을 초기화 할 수도 있는데, 이는 하나 이상의 값을 가진 배열 집합체 (array collection) 를 ‘약칭 (shorthand)’ 으로 만들 수 있는 방법입니다. ‘배열 글자표현’ 을 작성하려면 값을 나열하면서, 쉼표로 나누고, 대괄호 쌍으로 감싸면 됩니다.</p>

<p>[<code class="highlighter-rouge">value 1</code>, <code class="highlighter-rouge">value 2</code>, <code class="highlighter-rouge">value 3</code>]</p>

<p>아래 예제는 <code class="highlighter-rouge">shoppingList</code> 라는 배열을 만들어 <code class="highlighter-rouge">String</code> 값을 저장하고 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">shoppingList</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Eggs"</span><span class="p">,</span> <span class="s">"Milk"</span><span class="p">]</span>
<span class="c1">// shoppingList 가 두 초기 요소로 초기화 되었습니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">shoppingList</code> 변수는 <code class="highlighter-rouge">[String]</code> 을 써서 “문자열 값의 배열” 로 선언했습니다. 이 배열은 <code class="highlighter-rouge">String</code> 타입의 값만 갖도록 지정됐으므로, 이제 <code class="highlighter-rouge">String</code> 값만 저장할 수 있습니다. 여기서, <code class="highlighter-rouge">shoppingList</code> 배열은 ‘배열 글자표현 (array literal)’ 에 있는 두 개의 <code class="highlighter-rouge">String</code> 값인 (<code class="highlighter-rouge">"Eggs"</code> 와 <code class="highlighter-rouge">"Milk"</code>) 로 초기화 되었습니다.</p>

<blockquote>
  <p><code class="highlighter-rouge">shoppingList</code> 배열은 (<code class="highlighter-rouge">var</code> 소개자를 쓰는) 변수로 선언되었지 (<code class="highlighter-rouge">let</code> 소개자를 쓰는) 상수로 선언된 것이 아닙니다. 이는 아래 예제에서 이 <code class="highlighter-rouge">shoppingList</code> 에 더 많은 요소를 추가할 것이기 때문입니다.</p>
</blockquote>

<p>이 경우, ‘배열 글자표현 (array literal)’ 에는 두 개의 <code class="highlighter-rouge">String</code> 값만 있지 다른 건 전혀 없습니다. 이는 <code class="highlighter-rouge">shoppingList</code> 변수를 선언할 때의 타입 (<code class="highlighter-rouge">String</code> 값만 담을 수 있는 배열) 과 들어 맞으므로, ‘배열 글자표현’ 을 할당하는 것이 허용되어 두 개의 초기 요소로 <code class="highlighter-rouge">shoppingList</code> 를 초기화할 수 있습니다.</p>

<p>스위프트의 타입 추론 덕분에, 배열의 타입을 안써도 되는 경우가 있는데, 초기화할 때 ‘배열 글자표현’ 이 같은 타입의 값만 가지고 있으면 그렇습니다. 따라서 <code class="highlighter-rouge">shoppingList</code> 의 초기화는 앞에서보다 더 짧은 형태로도 작성할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">shoppingList</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Eggs"</span><span class="p">,</span> <span class="s">"Milk"</span><span class="p">]</span>
</code></pre></div></div>

<p>‘배열 글자표현’ 의 모든 값이 같은 타입이므로, 스위프트는 <code class="highlighter-rouge">shoppingList</code> 변수가 정확하게 <code class="highlighter-rouge">[String]</code> 타입임을 추론할 수 있습니다.</p>

<h4 id="accessing-and-modifying-an-array-배열에-접근하고-수정하기">Accessing and Modifying an Array (배열에 접근하고 수정하기)</h4>

<p>배열은 메소드 (methods) 와 속성 (properties), 또는 ‘첨자 연산 문법 (subscript syntax)’ 을 사용하여 접근하고 수정할 수 있습니다.</p>

<p>배열에 있는 요소의 개수를 알고 싶으면, 읽기-전용 속성인 <code class="highlighter-rouge">count</code> 를 검사하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"The shopping list contains </span><span class="se">\(</span><span class="n">shoppingList</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s"> items."</span><span class="p">)</span>
<span class="c1">// "The shopping list contains 2 items." 를 출력합니다.</span>
</code></pre></div></div>

<p>불린 (Boolean) 속성인 <code class="highlighter-rouge">isEmpty</code> 를 사용하면, <code class="highlighter-rouge">count</code> 속성이 <code class="highlighter-rouge">0</code> 과 같은 지를 더 간단하게 검사할 수 있습니다<sup id="fnref:isEmpty-count" role="doc-noteref"><a href="#fn:isEmpty-count" class="footnote">7</a></sup>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">shoppingList</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The shopping list is empty."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The shopping list is not empty."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "The shopping list is not empty." 를 출력합니다.</span>
</code></pre></div></div>

<p>배열에 있는 <code class="highlighter-rouge">append(_:)</code> 메소드를 호출하여 배열의 끝에 새로운 요소를 추가할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"Flour"</span><span class="p">)</span>
<span class="c1">// shoppingList 는 이제 3 개의 요소를 가지며, 누군가 팬케이크를 만들 수 있게 됐습니다.</span>
</code></pre></div></div>

<p>다른 방법으로, 배열에 ‘더하기 할당 연산자 (addition assignment operator)’ (<code class="highlighter-rouge">+=</code>) 를 사용하여 하나 이상의 호환성 있는 요소를 덧붙일 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span> <span class="o">+=</span> <span class="p">[</span><span class="s">"Baking Powder"</span><span class="p">]</span>
<span class="c1">// shoppingList 는 이제 4 개의 요소를 가집니다.</span>
<span class="n">shoppingList</span> <span class="o">+=</span> <span class="p">[</span><span class="s">"Chocolate Spread"</span><span class="p">,</span> <span class="s">"Cheese"</span><span class="p">,</span> <span class="s">"Butter"</span><span class="p">]</span>
<span class="c1">// shoppingList 는 이제 7 개의 요소를 가집니다.</span>
</code></pre></div></div>

<p>배열에서 값을 가져오려면 <em>첨자 연산 문법 (subscript syntax)</em> 을 사용하며, 이는 배열 이름 바로 뒤의 대괄호 안에 가져올 값의 <em>색인 (index)</em> 을 넣으면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">firstItem</span> <span class="o">=</span> <span class="n">shoppingList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">// firstItem 은 "Eggs" 가 됩니다.</span>
</code></pre></div></div>

<blockquote>
  <p>배열의 첫 번째 요소는 색인으로 <code class="highlighter-rouge">0</code> 을 갖습니다. <code class="highlighter-rouge">1</code> 이 아닙니다. 스위프트에 있는 배열은 항상 ‘영-기준 색인 (zero-indexed)’ 입니다.</p>
</blockquote>

<p>‘첨자 연산 문법 (subscript syntax)’ 을 사용하면 주어진 색인 위치의 값을 바꿀 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Six eggs"</span>
<span class="c1">// 이제 목록에 있는 첫 번째 요소는 단순히 "Eggs" 가 아니라 "Six eggs" 입니다.</span>
</code></pre></div></div>

<p>첨자 연산 문법을 사용할 때는, 지정한 인덱스가 유효해야만 합니다. 예를 들어, 배열 끝에 요소를 추가한답시고 <code class="highlighter-rouge">shoppingList[shoppingList.count] = "Salt"</code> 라고 하면 ‘실행 시간에 에러 (runtime error)’ 를 띄웁니다.<sup id="fnref:count-concurrent" role="doc-noteref"><a href="#fn:count-concurrent" class="footnote">8</a></sup></p>

<p>첨자 연산 문법을 사용해서 일정 범위의 값들을 한 번에 바꿀 수도 있는데, 이 때 대체될 값들의 범위와 대체할 범위의 길이가 달라도 문제 없습니다. 다음 예제는 <code class="highlighter-rouge">"Chocolate Spread"</code>, <code class="highlighter-rouge">"Cheese"</code>, 그리고 <code class="highlighter-rouge">"Butter"</code> 를 <code class="highlighter-rouge">"Bananas"</code> 와 <code class="highlighter-rouge">"Apples"</code> 로 바꾸는 것을 보여줍니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span><span class="p">[</span><span class="mi">4</span><span class="o">...</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Bananas"</span><span class="p">,</span> <span class="s">"Apples"</span><span class="p">]</span>
<span class="c1">// shoppingList 는 이제 6 개의 요소를 가집니다.</span>
</code></pre></div></div>

<p>배열에 요소를 넣을 때 특정 색인 위치에 넣고 싶으면, 배열의 <code class="highlighter-rouge">insert(_:at:)</code> 메소드를 호출하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shoppingList</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="s">"Maple Syrup"</span><span class="p">,</span> <span class="nv">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// shoppingList 는 이제 7 개의 요소를 가집니다.</span>
<span class="c1">// "Maple Syrup" 이 이제 목록의 첫 번째 요소입니다.</span>
</code></pre></div></div>

<p>여기서는 <code class="highlighter-rouge">insert(_:at:)</code> 메소드를 호출하여 <code class="highlighter-rouge">"Maple Syrup"</code> 이라는 새 요소를 ‘쇼핑 목록 (shopping list)’ 의 맨 처음 위치-색인 <code class="highlighter-rouge">0</code> 으로 지시한 곳-에 집어 넣었습니다.</p>

<p>비슷하게, 배열에 요소를 제거하려면 <code class="highlighter-rouge">remove(at:)</code> 메소드를 사용합니다. 이 메소드는 특정 색인 위치의 요소를 제거한 후 이 제거한 요소를 반환합니다. (반환 값이 필요 없다면 무시해도 됩니다):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">mapleSyrup</span> <span class="o">=</span> <span class="n">shoppingList</span><span class="o">.</span><span class="nf">remove</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// 색인 0 위치의 값이 방금 제거되었습니다.</span>
<span class="c1">// shoppingList 는 이제 6 개의 요소를 가지며, Maple Syrup 은 더이상 없습니다.</span>
<span class="c1">// 이제 상수 mapleSyrup 은 제거된 문자열인 "Maple Syrup" 이 됩니다.</span>
</code></pre></div></div>

<blockquote>
  <p>배열 범위를 벗어난 색인으로 값에 접근하려고 하거나 수정하려고 하면 ‘실행 시간에 에러 (runtime error)’ 를 띄웁니다. 색인을 사용하기 전에 유효한 지를 검사하고 싶으면 배열의 <code class="highlighter-rouge">count</code> 속성과 비교하면 됩니다. 배열에서 유효한 색인으로 가장 큰 것은 <code class="highlighter-rouge">count - 1</code> 인데, 배열의 ‘색인은 영-기준 (indexed from zero)’ 이기 때문입니다 - 하지만, <code class="highlighter-rouge">count</code> 가 <code class="highlighter-rouge">0</code> (즉 배열이 비어있으면) 이면, 유효한 색인이 아예 없습니다.</p>
</blockquote>

<p>배열에 요소를 제거할 때 발생하는 틈은 모조리 메꿔지므로, 색인 <code class="highlighter-rouge">0</code> 에 있는 값은 이제 다시 <code class="highlighter-rouge">"Six eggs"</code> 와 같아집니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firstItem</span> <span class="o">=</span> <span class="n">shoppingList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">// firstItem 은 다시 "Six eggs" 입니다.</span>
</code></pre></div></div>

<p>배열에서 마지막 요소를 제거하려면, <code class="highlighter-rouge">remove(at:)</code> 메소드 대신 <code class="highlighter-rouge">removeLast()</code> 메소드를 사용하는 것이 좋은데, 이는 배열의 <code class="highlighter-rouge">count</code> 속성을 조회할 필요가 없기 때문입니다. <code class="highlighter-rouge">remove(at:)</code> 메소드 처럼, <code class="highlighter-rouge">removeLast()</code> 메소드도 제거된 요소를 반환합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">apples</span> <span class="o">=</span> <span class="n">shoppingList</span><span class="o">.</span><span class="nf">removeLast</span><span class="p">()</span>
<span class="c1">// 배열의 마지막 요소가 바금 제거되었습니다.</span>
<span class="c1">// shoppingList 는 이제 5 개의 요소를 가지며, Apples 은 더이상 없습니다.</span>
<span class="c1">// 이제 상수 apples 는 제거된 문자열인 "Apples" 가 됩니다.</span>
</code></pre></div></div>

<h4 id="iterating-over-an-array-배열에-동작을-반복-적용하기">Iterating Over an Array (배열에 동작을 반복 적용하기)</h4>

<p><code class="highlighter-rouge">for-in</code> 반복문 (loop) 을 사용하면 배열에 있는 전체 값들에 ‘동작을 반복 적용 (iterate over)’<sup id="fnref:iterate-over" role="doc-noteref"><a href="#fn:iterate-over" class="footnote">9</a></sup> 할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">shoppingList</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Six eggs</span>
<span class="c1">// Milk</span>
<span class="c1">// Flour</span>
<span class="c1">// Baking Powder</span>
<span class="c1">// Bananas</span>
</code></pre></div></div>

<p>각 요소에 대해 값 뿐만 아니라 정수 색인도 필요하다면, 배열에 동작을 반복 적용시킬 때 <code class="highlighter-rouge">enumerated()</code><sup id="fnref:enumerate" role="doc-noteref"><a href="#fn:enumerate" class="footnote">10</a></sup> 메소드도 같이 사용하면 됩니다. <code class="highlighter-rouge">enumerated()</code> 메소드는 배열의 각 요소에 대해서 정수와 요소의 조합으로 된 ‘튜플 (tuple)’<sup id="fnref:tuple" role="doc-noteref"><a href="#fn:tuple" class="footnote">11</a></sup> 을 반환합니다. 이 정수는 0 에서 시작해서 각 요소마다 하나씩 증가합니다; 배열 전체를 열거하게 되면, 이 정수들은 결국 요소들의 색인이 됩니다. 반복 적용하는 구문 내에서 ‘튜플’ 을 임시 상수나 변수로 분해 (decompose) 할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">shoppingList</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Item </span><span class="se">\(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="se">)</span><span class="s">: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Item 1: Six eggs</span>
<span class="c1">// Item 2: Milk</span>
<span class="c1">// Item 3: Flour</span>
<span class="c1">// Item 4: Baking Powder</span>
<span class="c1">// Item 5: Bananas</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">for-in</code> 반복문에 대한 더 자세한 정보는 <a href="">For-In Loop</a> 를 보기 바랍니다.</p>

<h3 id="sets-셋-집합">Sets (셋; 집합)</h3>

<p><em>셋 (set)</em> 은 같은 타입이지만 서로 다른 값들을 순서는 따로 정의하지 않은채 컬렉션에 저장합니다. 배열 대신 셋을 사용할 때는, 요소의 순서가 중요하지 않거나, 요소가 단 한 번만 나타나도록 해야할 경우 등이 있습니다.</p>

<blockquote>
  <p>스위프트의 <code class="highlighter-rouge">Set</code> 타입은 ‘Foundation’ 프레임웍에 있는 <code class="highlighter-rouge">NSSet</code> 클래스와 연동되어 (bridged) 있습니다.</p>

  <p>‘Foundation’ 및 ‘Cocoa’ 프레임웍과 <code class="highlighter-rouge">Set</code> 을 같이 사용하는 방법에 대해서는 <a href="https://developer.apple.com/documentation/swift/set#2845530">Bridging Between Set and NSSet</a> 에서 더 자세히 알 수 있습니다.</p>
</blockquote>

<h4 id="hash-values-for-set-types-셋-타입의-해쉬-값">Hash Values for Set Types (셋 타입의 해쉬 값)</h4>

<p>셋에 저장하는 타입은 반드시 <em>해쉬 가능 (hashable)</em><sup id="fnref:hashable" role="doc-noteref"><a href="#fn:hashable" class="footnote">12</a></sup> 해야 합니다 - 이것은, 이 타입은 반드시 자체적으로 <em>해쉬 값 (hash value)</em><sup id="fnref:hash-value" role="doc-noteref"><a href="#fn:hash-value" class="footnote">13</a></sup> 을 계산할 수 있어야 한다는 말입니다. 여기서 해시 값이란, 하나의 <code class="highlighter-rouge">Int</code> 값으로서, 비교했을 때 같다고 판단되는 객체들은 모두 같아야 하는 값을 말하는 것으로, 가령 <code class="highlighter-rouge">a == b</code> 인 경우, 이는 필연적으로 <code class="highlighter-rouge">a.hashValue == b.hashValue</code> 이라는 말이 됩니다.</p>

<p>스위프트의 모든 기본 타입 (가령 <code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code> 그리고 <code class="highlighter-rouge">Bool</code>) 은 기본적으로 해시 가능하므로, ‘셋 (set)’ 의 값 타입과 ‘딕셔너리 (dictionary)’ 의 키 (key) 타입으로 사용할 수 있습니다. ‘관련 값 (associated values)’ 이 없는 열거체<sup id="fnref:enumeration" role="doc-noteref"><a href="#fn:enumeration" class="footnote">14</a></sup>의 경우 값 (enumeration case value; <a href="">Enumerations</a> 에 설명되어 있습니다) 역시 기본적으로 해시 가능합니다.</p>

<blockquote>
  <p>자신이 만든 타입을 셋의 값 타입이나 딕셔너리의 키 타입으로 사용하고 싶으면, 스위프트 표준 라이브러리에 있는 <code class="highlighter-rouge">Hashable</code> 프로토콜을 준수하도록 하면 됩니다. <code class="highlighter-rouge">Hashable</code> 프로토콜을 준수하는 타입은 반드시 <code class="highlighter-rouge">hashValue</code> 라는 읽을 수 있는 (gettable) <code class="highlighter-rouge">Int</code> 속성을 제공해야 합니다. 같은 프로그램을 다른 시점에 실행할 때나 다른 프로그램을 실행할 때, 이 타입의 <code class="highlighter-rouge">hashValue</code> 속성이 반환하는 값을 같도록 만들 필요는 없습니다.</p>

  <p><code class="highlighter-rouge">HashValue</code> 프로토콜은 <code class="highlighter-rouge">Equatable</code><sup id="fnref:equtable" role="doc-noteref"><a href="#fn:equtable" class="footnote">15</a></sup> 을 준수하므로, (‘Hashable’ 을) ‘준수하는 타입 (conforming types)’ 은 반드시 ‘같음 연산자 (<code class="highlighter-rouge">==</code>)’ 도 구현해야 합니다. <code class="highlighter-rouge">Equatable</code> 프로토콜은 ‘같은 값을 가진 관계 (equivalent relation)’ 임을 알기 위해서 어떤 형태로든 <code class="highlighter-rouge">==</code> 의 구현이 필요하기 때문입니다. 좀 더 정확하게 말하면, 모든 <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">c</code> 값에서, <code class="highlighter-rouge">==</code> 의 구현은  다음의 세 가지를 반드시 만족해야 합니다:</p>

  <ul>
    <li><code class="highlighter-rouge">a == a</code> (Reflexivity; 반사성<sup id="fnref:reflexivity" role="doc-noteref"><a href="#fn:reflexivity" class="footnote">16</a></sup>)</li>
    <li><code class="highlighter-rouge">a == b</code> 는 곧 <code class="highlighter-rouge">b == a</code> (Symmetry; 대칭성<sup id="fnref:symmetry" role="doc-noteref"><a href="#fn:symmetry" class="footnote">17</a></sup>)</li>
    <li><code class="highlighter-rouge">a == b &amp;&amp; b == c</code> 는 곧 <code class="highlighter-rouge">a == c</code> (Transitivity; 추이성<sup id="fnref:transitivity" role="doc-noteref"><a href="#fn:transitivity" class="footnote">18</a></sup>)</li>
  </ul>

  <p>프로토콜 준수에 대한 더 자세한 내용은 <a href="/swift/language/grammar/protocol/2016/03/03/Protocols.html">Protocols</a> 을 보도록 합니다.</p>
</blockquote>

<h4 id="set-type-syntax-셋-타입-문법">Set Type Syntax (셋 타입 문법)</h4>

<p>스위프트의 ‘셋’ 타입은 <code class="highlighter-rouge">Set&lt;Element&gt;</code> 라고 작성하며, 여기서 <code class="highlighter-rouge">Element</code> 는 셋에 저장할 수 있는 타입을 말합니다. ‘배열’ 과 달리, ‘셋’ 은 약칭으로 쓸 수 있는 형태가 없습니다.</p>

<h4 id="creating-and-initializing-an-empty-set-빈-셋-생성하고-초기화하기">Creating and Initializing an Empty Set (빈 셋 생성하고 초기화하기)</h4>

<p>특정 타입의 빈 ‘셋’ 을 만들려면 초기자 문법을 사용하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">letters</span> <span class="o">=</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">Character</span><span class="o">&gt;</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"letters is of type Set&lt;Character&gt; with </span><span class="se">\(</span><span class="n">letters</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s"> items."</span><span class="p">)</span>
<span class="c1">// "letters is of type Set&lt;Character&gt; with 0 items." 을 출력합니다.</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">letters</code> 변수의 타입은 초기자의 타입에 의해 <code class="highlighter-rouge">Set&lt;Character&gt;</code> 로 추론됩니다.</p>
</blockquote>

<p>다른 방법으로는, 영역 내에서 타입 정보를 제공하는 경우, 가령 함수 인자이거나 이미 타입이 알려진 변수 또는 상수인 경우, 빈 배열은 ‘빈 배열 글자표현’ 을 써서 생성할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">letters</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>
<span class="c1">// letters 는 이제 Character 타입 값 1 개를 갖고 있습니다.</span>
<span class="n">letters</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">// letters 는 이제 빈 셋이 됐지만, 타입은 여전히 Set&lt;Character&gt; 입니다.</span>
</code></pre></div></div>

<h4 id="creating-a-set-with-an-array-literal-배열-글자표현을-써서-셋-생성하기">Creating a Set with an Array Literal (배열 글자표현을 써서 셋 생성하기)</h4>

<p>‘배열 글자표현’ 으로 ‘셋 (set)’ 을 초기화할 수도 있는데, 이는 ‘셋 컬렉션 (set collection)’ 에 하나 이상의 값을 할당하는 ‘약칭법 (shorthand way)’ 입니다.</p>

<p>아래 예제는 <code class="highlighter-rouge">favoriteGenres</code> 라는 셋을 만든 후 <code class="highlighter-rouge">String</code> 값을 저장하는 방법을 보여줍니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">favoriteGenres</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Rock"</span><span class="p">,</span> <span class="s">"Classical"</span><span class="p">,</span> <span class="s">"Hip Hop"</span><span class="p">]</span>
<span class="c1">// favoriteGenres 는 3 개의 초기 요소를 가지고 초기화 되었습니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">favoriteGenres</code> 변수는 <code class="highlighter-rouge">Set&lt;String&gt;</code> 을 써서 “<code class="highlighter-rouge">String</code> 값의 셋” 으로 선언되었습니다. 이 셋은 <code class="highlighter-rouge">String</code> 타입의 값을 지정했기 때문에, <code class="highlighter-rouge">String</code> 값만 저장할 수 있습니다. 여기서 <code class="highlighter-rouge">favoriteGenres</code> 셋은 ‘배열 글자표현’ 에 있는 세 개의 <code class="highlighter-rouge">String</code> 값인 (<code class="highlighter-rouge">"Rock"</code>, <code class="highlighter-rouge">"Classical"</code>, 그리고 <code class="highlighter-rouge">"Hip hop"</code>) 으로 초기화 됩니다.</p>

<blockquote>
  <p><code class="highlighter-rouge">favoriteGenres</code> 셋은 (<code class="highlighter-rouge">var</code> 소개자를 써서) 변수로 선언되었으며, (<code class="highlighter-rouge">let</code> 소개자를 쓴) 상수가 아닙니다. 이는 아래 예제에서 요소를 추가하거나 제거할 것이기 때문입니다.</p>
</blockquote>

<p>셋 타입은 ‘배열 글자표현 (array literal)’ 만으로는 추론할 수 없으므로<sup id="fnref:set-array-literal" role="doc-noteref"><a href="#fn:set-array-literal" class="footnote">19</a></sup>, <code class="highlighter-rouge">Set</code> 이라는 타입은 반드시 명시적으로 선언해야 합니다. 그러나 스위프트의 타입 추론 기능에 의해서, ‘배열 글자표현’ 이 하나의 타입만 갖고 있는 경우, 셋 요소 (set’s elements) 의 타입은 쓸 필요가 없습니다. 따라서 <code class="highlighter-rouge">favoriteGenres</code> 의 초기화는 다음 처럼 더 짧은 양식으로 작성 할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">favoriteGenres</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Rock"</span><span class="p">,</span> <span class="s">"Classical"</span><span class="p">,</span> <span class="s">"Hip Hop"</span><span class="p">]</span>
</code></pre></div></div>

<p>‘배열 글자표현’ 에 있는 모든 값들이 같은 타입이므로, 스위프트는 <code class="highlighter-rouge">favoriteGenres</code> 변수가 <code class="highlighter-rouge">Set&lt;String&gt;</code> 임을 올바르게 추론할 수 있습니다.</p>

<h4 id="accessing-and-modifying-a-set-셋에-접근하고-수정하기">Accessing and Modifying a Set (셋에 접근하고 수정하기)</h4>

<p>You access and modify a set through its methods and properties.</p>

<p>To find out the number of items in a set, check its read-only count property:</p>

<p>셋은 메소드 (methods) 와 속성 (properties) 을 사용하여 접근하고 수정할 수 있습니다.</p>

<p>셋에 있는 요소의 개수를 알고 싶으면, 읽기-전용 속성인 <code class="highlighter-rouge">count</code> 를 검사하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"I have </span><span class="se">\(</span><span class="n">favoriteGenres</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s"> favorite music genres."</span><span class="p">)</span>
<span class="c1">// "I have 3 favorite music genres." 를 출력합니다.</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">count</code> 속성이 <code class="highlighter-rouge">0</code> 인지를 검사해야할 때는 더 간단한 방법으로 불린 (Boolean) 속성인 <code class="highlighter-rouge">isEmpty</code> 를 사용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">favoriteGenres</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"As far as music goes, I'm not picky."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"I have particular music preferences."</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// "I have particular music preferences." 를 출력합니다.</span>
</code></pre></div></div>

<p>셋에 새로운 요소를 추가할 때는 <code class="highlighter-rouge">insert(_:)</code> 메소드를 호출하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">favoriteGenres</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="s">"Jazz"</span><span class="p">)</span>
<span class="c1">// favoriteGenres 는 이제 4 개의 요소를 갖고 있습니다.</span>
</code></pre></div></div>

<p>셋에서 특정 요소를 제거할 때는 셋의 <code class="highlighter-rouge">remove(_:)</code> 메소드를 호출하는데, 그 요소가 셋의 멤버면 제거한 후 제거된 값을 반환하며, 만약 셋의 요소가 아니면 <code class="highlighter-rouge">nil</code> 을 반환합니다. 다른 방법으로, 셋의 모든 요소를 제거하려면 <code class="highlighter-rouge">removeAll()</code> 메소드를 사용합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">removeGenres</span> <span class="o">=</span> <span class="n">favoriteGenres</span><span class="o">.</span><span class="nf">remove</span><span class="p">(</span><span class="s">"Rock"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">removeGenres</span><span class="se">)</span><span class="s">? I'm over it."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"I never much cared for that."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Rock? I'm over it." 를 출력합니다.</span>
</code></pre></div></div>

<p>셋이 특정한 요소를 가지고 있는지를 검사하려면 <code class="highlighter-rouge">contain(_:)</code> 메소드를 사용합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">favoriteGenres</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"Funk"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"I get up on the good foot."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"It's too funky in here."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "It's too funky in here." 를 출력합니다.</span>
</code></pre></div></div>

<h4 id="iterating-over-a-set-셋에-동작을-반복-적용하기">Iterating Over a Set (셋에 동작을 반복 적용하기)</h4>

<p><code class="highlighter-rouge">for-in</code> 반복문 (loop) 을 사용하면 셋에 있는 값들에 ‘동작을 반복 적용 (iterate over)’ 할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">genre</span> <span class="k">in</span> <span class="n">favoriteGenres</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">genre</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Classical</span>
<span class="c1">// Jazz</span>
<span class="c1">// Hip Hop</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">for-in</code> 반복문에 대한 자세한 내용은 <a href="">For-In Loops</a> 를 참조하기 바랍니다.</p>

<p>스위프트의 셋 타입에는 정의된 순서란 것이 없습니다. 지정된 순서대로 셋의 값에 ‘동작을 반복 적용’ 하려면, 먼저 <code class="highlighter-rouge">sorted()</code> 메소드를 사용해야 합니다. 이 함수는 셋의 요소들을 정렬된 배열 형태로 바꿔서 반환하는데, 정렬할 때 <code class="highlighter-rouge">&lt;</code> 연산자를 사용합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">genre</span> <span class="k">in</span> <span class="n">favoriteGenres</span><span class="o">.</span><span class="nf">sort</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">genre</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Classical</span>
<span class="c1">// Hip Hop</span>
<span class="c1">// Jazz</span>
</code></pre></div></div>

<h3 id="performing-set-operations-집합-셋-연산-수행하기">Performing Set Operations (집합-셋 연산 수행하기)</h3>

<p>(셋으로) 기본 ‘(집합) 연산’<sup id="fnref:set-operations" role="doc-noteref"><a href="#fn:set-operations" class="footnote">20</a></sup> 을 효율적으로 수행할 수 있습니다. 이에는 두 집합-셋-을 서로 합하는 것, 두 집합-셋-에 공통인 값을 결정하는 것, 또는 두 집합-셋-에 있는 값이 모두 같은 지, 일부만 같은 지, 아니면 같은 게 전혀 없는 지를 결정하는 것 등이 있습니다.</p>

<h3 id="fundamental-set-operations-기본-집합-셋-연산">Fundamental Set Operations (기본 집합-셋 연산)</h3>

<p>아래 그림은 두 개의 셋-<code class="highlighter-rouge">a</code> 와 <code class="highlighter-rouge">b</code>-에 대해 다양한 집합-셋 연산을 수행한 결과를 음영으로 보여줍니다.</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Collection-Types-fundamental-set-operations.jpg" alt="Fundamental-Set-Operations" /></p>

<ul>
  <li><code class="highlighter-rouge">intersect(_:)</code> 메소드를 사용하여 생성한 새 집합-셋은 두 집합-셋에 공통된 값만 담고 있습니다.</li>
  <li><code class="highlighter-rouge">exclusiveOr(_:)</code> 메소드를 사용하여 생성한 새 집합-셋은 각각의 집합-셋에는 있지만 공통되지는 않는 값만 담고 있습니다.</li>
  <li><code class="highlighter-rouge">union(_:)</code> : 메소드를 사용하여 생성한 새 집합-셋은 두 집합-셋에 있는 모든 값을 담고 있습니다.</li>
  <li><code class="highlighter-rouge">subtract(_:)</code> 메소드를 사용하여 생성한 새 집합-셋은 특정한 집합-셋에는 없는 값만을 답고 있습니다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">oddDigits</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">evenDigits</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">singleDigitPrimeNumbers</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>

<span class="n">oddDigits</span><span class="o">.</span><span class="nf">union</span><span class="p">(</span><span class="n">evenDigits</span><span class="p">)</span><span class="o">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="n">oddDigits</span><span class="o">.</span><span class="nf">intersect</span><span class="p">(</span><span class="n">evenDigits</span><span class="p">)</span><span class="o">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// []</span>
<span class="n">oddDigits</span><span class="o">.</span><span class="nf">subtract</span><span class="p">(</span><span class="n">singleDigitPrimeNumbers</span><span class="p">)</span><span class="o">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [1, 9]</span>
<span class="n">oddDigits</span><span class="o">.</span><span class="nf">exclusiveOr</span><span class="p">(</span><span class="n">singleDigitPrimeNumbers</span><span class="p">)</span><span class="o">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="c1">// [1, 2, 9]</span>
</code></pre></div></div>

<h3 id="set-membership-and-equality-집합-셋의-포함-및-동등-비교">Set Membership and Equality (집합-셋의 포함 및 동등 비교)</h3>

<p>아래 그림은 세 개의 셋-<code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, 와 <code class="highlighter-rouge">c</code>-에서 공유되는 요소를 겹침 영역 (overlapping regions) 으로 보여줍니다. 여기서 집합-셋 <code class="highlighter-rouge">a</code> 는 집합-셋 <code class="highlighter-rouge">b</code> 의 <em>상위집합 (superset)</em> 이며, 이는 <code class="highlighter-rouge">a</code> 가 <code class="highlighter-rouge">b</code> 의 모든 요소를 포함하기 때문입니다. 반대로, 집합-셋 <code class="highlighter-rouge">b</code> 는 집합-셋 <code class="highlighter-rouge">a</code> 의 <em>하위집합 (subset; 부분 집합)</em> 으로, <code class="highlighter-rouge">b</code> 의 모든 요소가 <code class="highlighter-rouge">a</code> 에 포함되기 때문입니다. 집합-셋 <code class="highlighter-rouge">b</code>와 집합-셋 <code class="highlighter-rouge">c</code>는 서로 <em>분리 (disjoint)</em><sup id="fnref:disjoint" role="doc-noteref"><a href="#fn:disjoint" class="footnote">21</a></sup> 되었다고 하며, 이는 서로 어떤 요소도 공유하고 있지 않기 때문입니다.</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Collection-Types-set-membership-and-equality.jpg" alt="Set-Membership-and-Equality" /></p>

<ul>
  <li>“같음 (is equal)” 연산자 (<code class="highlighter-rouge">==</code>) 를 사용하여 두 집합-셋이 모두 같은 값을 가지고 있는지를 확인합니다.</li>
  <li><code class="highlighter-rouge">isSubset(of:)</code> 메소드를 사용하여 한 집합-셋에 있는 모든 값들이 지정된 집합-셋에 포함되어 있는지를 확인합니다.</li>
  <li><code class="highlighter-rouge">isSuperset(of:)</code> 메소드를 사용하여 한 집합-셋이 지정된 집합-셋에 있는 모든 값을 포함하는지를 확인합니다.</li>
  <li><code class="highlighter-rouge">isStrictSubset(of:)</code> 또는 <code class="highlighter-rouge">isStrictSuperset(of:)</code> 메소드를 사용하여 한 집합-셋이 지정된 집합-셋의 하위집합 (부분집합) 또는 상위집합이면서, 같지는 않은 관계인지를 확인합니다.</li>
  <li><code class="highlighter-rouge">isDisjoint(with:)</code> 메소드를 사용하여 두 집합-셋이 공통된 값을 가지고 있지 않은 것을 확인합니다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">houseAnimals</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"🐶"</span><span class="p">,</span> <span class="s">"🐱"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">farmAnimals</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"🐮"</span><span class="p">,</span> <span class="s">"🐔"</span><span class="p">,</span> <span class="s">"🐑"</span><span class="p">,</span> <span class="s">"🐶"</span><span class="p">,</span> <span class="s">"🐱"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">cityAnimals</span><span class="p">:</span> <span class="kt">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">"🐦"</span><span class="p">,</span> <span class="s">"🐭"</span><span class="p">]</span>

<span class="n">houseAnimals</span><span class="o">.</span><span class="nf">isSubset</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">farmAnimals</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="n">farmAnimals</span><span class="o">.</span><span class="nf">isSuperset</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">houseAnimals</span><span class="p">)</span>
<span class="c1">// true</span>
<span class="n">farmAnimals</span><span class="o">.</span><span class="nf">isDisjoint</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">cityAnimals</span><span class="p">)</span>
<span class="c1">// true</span>
</code></pre></div></div>

<h2 id="dictionaries-딕셔너리-사전">Dictionaries (딕셔너리; 사전)</h2>

<p>딕셔너리는 ‘키-값 관련-묶음 (key-value associations)’ 들이 순서없이 모여 있는 컬렉션입니다.</p>

<p><em>딕셔너리 (dictionary; 사전)</em> 는 동일한 타입의 키들과 동일한 타입의 값들 사이의 ‘관련-묶음 (associations)’ 을 컬렉션에 순서없이 저장합니다. 각각의 값은 유일한 <em>키 (key)</em> 와 관련지어지며, 이 키는 딕셔너리에서 그 값에 대한 식별자 (identifier) 역할을 합니다. 배열에 있는 요소와는 달리, 딕셔너리에 있는 요소들은 지정된 순서가 없습니다. 딕셔너리는 식별자를 기반으로 하여 값을 찾을 때 쓸 수 있는데, 이는 실제-세계의 사전 (딕셔너리) 이 특정 단어로 정의된 뜻을 찾는 것과 사실상 같은 것입니다.</p>

<blockquote>
  <p>스위프트의 <code class="highlighter-rouge">Dictionary</code> 타입은 ‘Foundation’ 프레임웍에 있는 <code class="highlighter-rouge">NSDictionary</code> 클래스와 연동되어 (bridged) 있습니다.</p>

  <p>‘Foundation’ 및 ‘Cocoa’ 프레임웍과 <code class="highlighter-rouge">Dictionary</code> 를 같이 사용하는 방법에 대해서는 <a href="https://developer.apple.com/documentation/swift/dictionary#2846239">Bridging Between Dictionary and NSDictionary</a> 에서 더 자세히 알 수 있습니다.</p>
</blockquote>

<h3 id="dictionary-type-shorthand-syntax-딕셔너리-타입-약칭-구문-표현">Dictionary Type Shorthand Syntax (딕셔너리 타입 약칭 구문 표현)</h3>

<p>스위프트의 딕셔너리 타입을 온전하게 작성하는 방법은 <code class="highlighter-rouge">Dictionary&lt;Key, Value&gt;</code> 이며, 여기서 <code class="highlighter-rouge">Key</code> 는 딕셔너리에서 키로 사용되는 값의 타입이고, <code class="highlighter-rouge">Value</code> 이 키로 딕셔너리에 저장되는 값의 타입입니다.</p>

<blockquote>
  <p>‘딕셔너리’ 의 <code class="highlighter-rouge">Key</code> 타입은 ‘셋’ 의 값 타입처럼 반드시 <code class="highlighter-rouge">Hashable</code> 프로토콜을 준수해야 합니다.</p>
</blockquote>

<p>또한 딕셔너리 타입은 약칭으로 <code class="highlighter-rouge">[Key : Value]</code> 와 같은 형태로 작성할 수도 있습니다. 두 양식의 기능은 동일하지만 약칭 형태를 권장하며, 이 책에서도 딕셔너리 타입은 약칭 형태로 참조하도록 합니다.</p>

<h3 id="creating-an-empty-dictionary-빈-딕셔너리-생성하기">Creating an Empty Dictionary (빈 딕셔너리 생성하기)</h3>

<p>빈 <code class="highlighter-rouge">Dictionary</code> 를 만들려면 배열 처럼 ‘초기자 문법 (initializer syntax)’ 을 사용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">namesOfIntegers</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span> <span class="kt">String</span><span class="p">]()</span>
<span class="c1">// namesOfIntegers 는 [Int: String] 타입의 빈 딕셔너리입니다.</span>
</code></pre></div></div>

<p>아래 예제는 <code class="highlighter-rouge">[Int: String]</code> 타입의 빈 딕셔너리를 생성해서 사람이 읽을 수 있는 정수의 이름을 저장합니다. 키는 <code class="highlighter-rouge">Int</code> 타입이고, 값은 <code class="highlighter-rouge">String</code> 타입입니다.</p>

<p>영역 내에서 이미 타입 정보를 제공하는 경우, 빈 딕셔너리는 ‘빈 딕셔너리 글자표현 (empty dictionary literal)’ 으로 생성할 수도 있는데, 이는 <code class="highlighter-rouge">[:]</code> 처럼 (대괄호 쌍 안에 콜론) 을 써 주면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">namesOfIntegers</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">"sixteen"</span>
<span class="c1">// namesOfIntegers 는 이제 1 개의 키-값 쌍을 갖고 있습니다.</span>
<span class="n">namesOfIntegers</span> <span class="o">=</span> <span class="p">[:]</span>
<span class="c1">// namesOfIntegers 는 다시 빈 딕셔너리가 됐으며 타입은 [Int: String] 입니다.</span>
</code></pre></div></div>

<h3 id="creating-a-dictionary-with-a-dictionary-literal-딕셔너리-글자표현을-써서-딕셔너리-생성하기">Creating a Dictionary with a Dictionary Literal (딕셔너리 글자표현을 써서 딕셔너리 생성하기)</h3>

<p><em>딕셔너리 글자표현 (dictionary literal)</em> 을 써서 딕셔너리를 초기화할 수도 있는데, 이는 앞서 본 ‘배열 글자표현’ 과 문법이 비슷합니다. 딕셔너리 글자표현은 하나 이상의 키-값 쌍을 가진 <code class="highlighter-rouge">Dictionary</code> 컬렉션을 약칭 (shorthand) 으로 만들 수 있는 방법입니다.</p>

<p><em>키-값 쌍 (key-value pair)</em> 은 키와 값의 조합입니다. 딕셔너리 글자표현의 각 ‘키-값 쌍’ 에 있는 키와 값은 콜론으로 구분됩니다. ‘키-값 쌍들’[^key-value-pairs] 을 작성하려면 값을 나열하면서, 쉼표로 나누고, 대괄호 쌍으로 감싸면 됩니다:</p>

<p>[<code class="highlighter-rouge">key 1</code>: <code class="highlighter-rouge">value 1</code>, <code class="highlighter-rouge">key 2</code>: <code class="highlighter-rouge">value 2</code>, <code class="highlighter-rouge">key 3</code>: <code class="highlighter-rouge">value 3</code>]</p>

<p>아래 예제는 국제 공항의 이름을 저장하는 딕셔너리를 생성합니다. 이 딕셔너리에서, 키는 3-글자로 된 국제 항공운송협회 코드이며, 값은 공항의 이름입니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">airports</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">"YYZ"</span><span class="p">:</span> <span class="s">"Toronto Pearson"</span><span class="p">,</span> <span class="s">"DUB"</span><span class="p">:</span> <span class="s">"Dublin"</span><span class="p">]</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">airport</code> 딕셔너리는 <code class="highlighter-rouge">[String: String]</code> 타입으로 선언되었는데, 이는 “키가 <code class="highlighter-rouge">String</code> 타입이고 값이 <code class="highlighter-rouge">String</code> 타입인 <code class="highlighter-rouge">Dictionary</code>” 임을 의미합니다.</p>

<blockquote>
  <p><code class="highlighter-rouge">airport</code> 딕셔너리는 (<code class="highlighter-rouge">var</code> 소개자를 쓰는) 변수로 선언되었지 (<code class="highlighter-rouge">let</code> 소개자를 쓰는) 상수로 선언된 것이 아닙니다. 이는 아래 예제에서 이 딕셔너리에 더 많은 공항을 추가할 것이기 때문입니다.</p>
</blockquote>

<p><code class="highlighter-rouge">airport</code> 딕셔너리는 두 개의 키-값 쌍을 가지는 ‘딕셔너리 글자표현’ 으로 초기화되었습니다. 첫 번째 쌍의 키는 <code class="highlighter-rouge">"YYZ"</code> 이고, 값은 <code class="highlighter-rouge">"Toronto Pearson"</code> 입니다. 두 번째 쌍은 키가 <code class="highlighter-rouge">"DUB"</code> 이고, 값은 <code class="highlighter-rouge">"Dublin"</code> 입니다.</p>

<p>이 ‘딕셔너리 글자표현’ 은 두 개의 <code class="highlighter-rouge">String: String</code> 쌍을 갖고 있습니다. 이 키-값 타입은 <code class="highlighter-rouge">airport</code> 변수를 선언할 때의 타입 (<code class="highlighter-rouge">String</code> 키와 <code class="highlighter-rouge">String</code> 값만 가지는 딕셔너리) 과 들어 맞으므로, ‘딕셔너리 글자표현’ 에 있는 두 요소로 <code class="highlighter-rouge">airport</code> 딕셔너리를 초기화 하는 것이 허용됩니다.</p>

<p>배열에서 처럼, 딕셔너리도 초기화할 때 타입을 안써도 되는 경우가 있으며, 이는 딕셔너리 글자표현에 있는 키와 값들의 타입이 일관성이 있는 경우입니다. <code class="highlighter-rouge">airport</code> 의 초기화는 아래 처럼 더 짧게 작성할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">airports</span> <span class="o">=</span> <span class="p">[</span><span class="s">"YYZ"</span><span class="p">:</span> <span class="s">"Toronto Pearson"</span><span class="p">,</span> <span class="s">"DUB"</span><span class="p">:</span> <span class="s">"Dublin"</span><span class="p">]</span>
</code></pre></div></div>

<p>‘글자표현 (literals)’ 에 있는 모든 키들이 서로 같은 타입이면서 모든 값들도 같은 타입이므로, 스위프트는 <code class="highlighter-rouge">airport</code> 딕셔너리의 타입이 정확하게 <code class="highlighter-rouge">[String: String]</code> 타입임을 추론할 수 있습니다.</p>

<h3 id="accessing-and-modifying-a-dictionary-딕셔너리에-접근하고-수정하기">Accessing and Modifying a Dictionary (딕셔너리에 접근하고 수정하기)</h3>

<p>딕셔너리는 메소드 (methods) 와 속성 (properties), 또는 ‘첨자 연산 문법 (subscript syntax)’ 을 사용하여 접근하고 수정할 수 있습니다.</p>

<p>딕셔너리에 있는 요소의 개수를 알고 싶으면, 배열과 마찬가지로 읽기-전용 속성인 <code class="highlighter-rouge">count</code> 를 검사하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"The airports dictionary contains </span><span class="se">\(</span><span class="n">airports</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s"> items."</span><span class="p">)</span>
<span class="c1">// "The airports_2 dictionary contains 2 items." 를 출력합니다.</span>
</code></pre></div></div>

<p>불린 (Boolean) 속성인 <code class="highlighter-rouge">isEmpty</code> 를 사용하면, <code class="highlighter-rouge">count</code> 속성이 <code class="highlighter-rouge">0</code> 과 같은 지를 더 간단하게 검사할 수 있습니다<sup id="fnref:isEmpty-count:1" role="doc-noteref"><a href="#fn:isEmpty-count" class="footnote">7</a></sup>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">airports</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The airports dictionary is empty."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The airports dictionary is not empty."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "The airports dictionary is not empty." 를 출력합니다.</span>
</code></pre></div></div>

<p>딕셔너리에 새 요소를 추가할 때 ‘첨자 연산 문법 (subscript syntax)’ 을 사용할 수 있습니다. 타입에 맞는 새 키를 첨자 연산의 색인으로 두고, 타입에 맞는 새 값을 할당하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">airports</span><span class="p">[</span><span class="s">"LHR"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"London"</span>
<span class="c1">// airports 딕셔너리는 이제 3 개의 요소를 가집니다.</span>
</code></pre></div></div>

<p>첨자 연산 문법을 사용해서 특정한 키와 관련되어 있는 값을 바꿀 수도 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">airports</span><span class="p">[</span><span class="s">"LHR"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"London Heathrow"</span>
<span class="c1">// "LHR" 에 해당하는 값이 "London Heathrow" 로 바뀌었습니다.</span>
</code></pre></div></div>

<p>첨자 연산의 대안으로, 딕셔너리에 있는 <code class="highlighter-rouge">updateValue(_:forKey:)</code> 메소드를 사용하여 특정 키에 대한 값을 설정하고 업데이트하도록 합니다. 위의 첨자 연산 예제와 같이, <code class="highlighter-rouge">updateValue(_:forKey:)</code> 메소드는 해당 키가 존재하지 않으면 키의 값을 설정하고, 키가 이미 존재하면 값을 업데이트합니다. 하지만 첨자 연산과는 달리, <code class="highlighter-rouge">updateValue(_:forKey:)</code> 메소드는 업데이트를 수행한 다음 <em>예전 (old)</em> 값을 반환합니다. 이것으로 업데이트가 실제로 일어났는지를 검사할 수 있습니다.</p>

<p><code class="highlighter-rouge">updateValue(_:forKey:)</code> 메소드는 딕셔너리 값 타입에 대한 옵셔널 값 (optional value)<sup id="fnref:optional-value" role="doc-noteref"><a href="#fn:optional-value" class="footnote">22</a></sup> 을 반환합니다. 예를 들어, <code class="highlighter-rouge">String</code> 값을 저장하는 딕셔너리의 경우, 이 메소드는 (“옵셔널 <code class="highlighter-rouge">String</code>” 이라고 하는) <code class="highlighter-rouge">String?</code> 타입의 값을 반환합니다. 이 옵셔널 값은 업데이트 이전에 값이 있었으면 해당 키에 대한 예전 값을 가지고, 없었으면 <code class="highlighter-rouge">nil</code> 을 가집니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">oldValue</span> <span class="o">=</span> <span class="n">airports</span><span class="o">.</span><span class="nf">updateValue</span><span class="p">(</span><span class="s">"Dublin Airport"</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="s">"DUB"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The old value for DUB was </span><span class="se">\(</span><span class="n">oldValue</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "The old value for DUB was Dublin." 를 출력합니다.</span>
</code></pre></div></div>

<p>첨자 연산 문법을 사용하여 딕셔너리에서 특정 키에 대한 값을 가져올 수도 있습니다. 요청한 키에 대해서 값이 없을 수도 있으므로, 딕셔너리의 첨자 연산은 딕셔너리의 값 타입에 대한 옵셔널 값을 반환합니다. 딕셔너리가 요청한 키에 대한 값을 가지고 있는 경우, 첨자 연산은 그 키에 대한 값을 담고 있는 옵셔널 값을 반환합니다. 그렇지 않는 경우, 첨자 연산은 <code class="highlighter-rouge">nil</code> 을 반환합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">airportName</span> <span class="o">=</span> <span class="n">airports</span><span class="p">[</span><span class="s">"DUB"</span><span class="p">]</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The name of the airport is </span><span class="se">\(</span><span class="n">airportName</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"That airport is not in the airports dictionary."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "The name of the airport is Dublin Airport." 를 출력합니다.</span>
</code></pre></div></div>

<p>첨자 연산 문법을 사용하여 키에 대한 값으로 <code class="highlighter-rouge">nil</code> 을 할당하면 딕셔너리에서 ‘키-값 쌍’ 을 제거할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">airports</span><span class="p">[</span><span class="s">"APL"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Apple International"</span>
<span class="c1">// APL 및 "Apple International" 은 실제 공항이 아닙니다, 이제 지워봅시다.</span>
<span class="n">airports</span><span class="p">[</span><span class="s">"APL"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="c1">// APL 이 방금 딕셔너리에서 지워졌습니다.</span>
</code></pre></div></div>

<p>다른 방법으로, 딕셔너리에서 키-값 쌍을 제거하려면 <code class="highlighter-rouge">removeValue(_:forKey)</code> 메소드를 사용합니다. 이 메소드는 해당 키-값 쌍이 있으면 제거하고나서 그 제거한 값을 반환하고, 없으면 <code class="highlighter-rouge">nil</code> 을 반환합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">removedValue</span> <span class="o">=</span> <span class="n">airports</span><span class="o">.</span><span class="nf">removeValue</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="s">"DUB"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The removed airport's name is </span><span class="se">\(</span><span class="n">removedValue</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The airports dictionary does not contain a value for DUB."</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "The removed airport's name is Dublin Airport." 를 출력합니다.</span>
</code></pre></div></div>

<h3 id="iterating-over-a-dictionary-배열에-동작을-반복-적용하기">Iterating Over a Dictionary (배열에 동작을 반복 적용하기)</h3>

<p><code class="highlighter-rouge">for-in</code> 반복문을 사용하면 딕셔너리에 있는 전체 키-값 쌍들에 ‘동작을 반복 적용 (iterate over)’ 할 수 있습니다. 딕셔너리의 각 요소는 <code class="highlighter-rouge">(key, value)</code> 튜플의 형태로 반환되며, 튜플의 멤버는 동작 반복 과정에서 임시 상수나 변수로 분해할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">airportCode</span><span class="p">,</span> <span class="n">airportName</span><span class="p">)</span> <span class="k">in</span> <span class="n">airports</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">airportCode</span><span class="se">)</span><span class="s">: </span><span class="se">\(</span><span class="n">airportName</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// YYZ: Toronto Pearson</span>
<span class="c1">// LHR: London Heathrow               </span>
</code></pre></div></div>

<p><code class="highlighter-rouge">for-in</code> 반복문에 대한 더 자세한 내용은 <a href="">For-In Loops</a> 를 보도록 합니다.</p>

<p>딕셔너리의 키와 값들에 대해서 ‘동작을 반복 적용할 수 있는 컬렉션 (iterable collection)’ 을 가질 수도 있는데, 이는 딕셔너리의 <code class="highlighter-rouge">keys</code> 와 <code class="highlighter-rouge">properties</code> 속성을 사용하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">airportCode</span> <span class="k">in</span> <span class="n">airports</span><span class="o">.</span><span class="n">keys</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Airport code: </span><span class="se">\(</span><span class="n">airportCode</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Airport code: YYZ</span>
<span class="c1">// Airport code: LHR</span>

<span class="k">for</span> <span class="n">airportName</span> <span class="k">in</span> <span class="n">airports</span><span class="o">.</span><span class="n">values</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Airport name: </span><span class="se">\(</span><span class="n">airportName</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Airport name: Toronto Pearson</span>
<span class="c1">// Airport name: London Heathrow</span>
</code></pre></div></div>

<p>딕셔너리의 키와 값을 <code class="highlighter-rouge">Array</code> 인스턴스를 요구하는 API 에 전달하려면, <code class="highlighter-rouge">keys</code> 와 <code class="highlighter-rouge">properties</code> 속성으로 새 배열을 초기화하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">airportCodes</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">](</span><span class="n">airports</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
<span class="c1">// airportCodes 는 ["YYZ", "LHR"] 가 됩니다.</span>

<span class="k">let</span> <span class="nv">airportNames</span> <span class="o">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">](</span><span class="n">airports</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="c1">// airportNames 은 ["Toronto Pearson", "London Heathrow"] 가 됩니다.</span>
</code></pre></div></div>

<p>스위프트의 <code class="highlighter-rouge">Dictionary</code> 타입에는 따로 정의된 순서가 없습니다. 딕셔너리의 키와 값에 동작을 반복 적용할 때 특정 순서를 따르게 하고 싶으면, <code class="highlighter-rouge">sort()</code> 를 <code class="highlighter-rouge">keys</code> 와 <code class="highlighter-rouge">values</code> 속성에 사용하면 됩니다.</p>

<h3 id="참고-자료">참고 자료</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:Collection-Types" role="doc-endnote">
      <p>원문은 <a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html">Collection Types</a> 에서 확인할 수 있습니다. <a href="#fnref:Collection-Types" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:collections" role="doc-endnote">
      <p>‘collection’ 은 ‘집합’, ‘묶음’ 등의 말로 옮길 수 있는데, 여기서는 보통의 경우 ‘컬렉션’ 이라고 발음대로 사용하다가, 필요한 경우는 의미를 살려서 ‘집합체’ 라는 말을 사용합니다. 이는 ‘class’ 를 ‘객체’, ‘structure’ 를 ‘구조체’, ‘enumeration’ 을 ‘열거체’ 라고 하는 것과의 통일성을 유지하기 위한 것입니다. 모두다 하나의 ‘타입’ 이 될 수 있는 것들입니다. <a href="#fnref:collections" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:sets" role="doc-endnote">
      <p>‘Sets’ 은 수학 용어로는 그 자체로 ‘집합’ 이라는 뜻을 가지고 있는데, ‘집합’ 이라고 하면 프로그래밍에서 다른 의미로 해석될 수도 있으므로, 여기서는 스위프트의 자료 타입을 의미하도록 ‘셋’ 이라고 발음 그대로 옮기도록 합니다. <a href="#fnref:sets" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:dictionaries" role="doc-endnote">
      <p>‘dictionaries’ 는 ‘사전’ 으로 옮길 수 있는데, 타입의 요소가 실제 사전처럼 ‘키’ 와 ‘값’ 의 두 가지 성분으로 되어있습니다. 다만 ‘사전’ 이라고 옮기면 다른 의미로 해석될 수도 있으므로, 여기서는 스위프트의 자료 타입을 의미하도록 ‘딕셔너리’ 라고 발음 그대로 옮기도록 합니다. <a href="#fnref:dictionaries" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:compatible" role="doc-endnote">
      <p>‘compatible’ 은 컴퓨터 용어에서 ‘호환성이 있는’ 것을 말하며, 이는 서로 같이 사용하거나 교체가 가능한 것을 말합니다. 예를 들어, 스위프트에서 <code class="highlighter-rouge">Float</code> 과 <code class="highlighter-rouge">Double</code> 타입은 서로 ‘호환성이 있는’ 데, 이로써 두 값은 서로 같이 연산할 수 있습니다. 그리고 이 때의 연산 결과는 <code class="highlighter-rouge">Double</code> 타입이 됩니다. 사실 스위프트에서는 특별한 경우가 아니면 <code class="highlighter-rouge">Float</code> 타입을 따로 쓸 필요가 없긴 합니다. <a href="#fnref:compatible" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:literal" role="doc-endnote">
      <p>‘literal’ (리터럴) 은 ‘문자로 표현된 실제 의미’ 를 뜻합니다. 예를 들어 <code class="highlighter-rouge">let a = 10</code> 이라고 하면 여기서 <code class="highlighter-rouge">10</code> 은 ASCII 코드로 된 문자 <code class="highlighter-rouge">1</code> 과 <code class="highlighter-rouge">0</code> 의 조합이지만 ‘문자로 표현된 실제 의미’ 는 정수 <code class="highlighter-rouge">10</code> 을 의미하고 있고 따라서 <code class="highlighter-rouge">a</code> 는 <code class="highlighter-rouge">Int</code> 타입으로 추론됩니다. <a href="#fnref:literal" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:isEmpty-count" role="doc-endnote">
      <p>실제로 스위프트에서는 배열에 값이 있는지 없는지를 검사할 때는 <code class="highlighter-rouge">isEmpty</code> 를 사용할 것을 권장합니다. <code class="highlighter-rouge">count</code> 는 값의 개수가 몇 개인지를 알고 싶을 때 사용하는 것입니다. 즉, 단순히 편리하기 때문에만 <code class="highlighter-rouge">isEmpty</code> 를 사용하는 것은 아닙니다. 이에 대한 이유는 <a href="https://medium.com/better-programming/strings-comparison-isempty-vs-count-0-be80d701901b">isEmpty vs. count == 0</a> 이라는 글을 읽어보길 바랍니다. <a href="#fnref:isEmpty-count" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:isEmpty-count:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:count-concurrent" role="doc-endnote">
      <p><code class="highlighter-rouge">shippingList.count</code> 는 현재 배열의 요소 전체 개수를 나타내는데, 이 값을 사용해서 요소를 새로 추가하게 되면 그 자ㅔ로 <code class="highlighter-rouge">count</code> 가 변경돼야 합니다. 즉 <code class="highlighter-rouge">count</code> 변수에 값을 읽는 작업과 쓰는 작업을 동시에 진행하는 문제가 발생할 수 있습니다. <a href="#fnref:count-concurrent" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:iterate-over" role="doc-endnote">
      <p>‘iterate over’ 는 그냥 ‘반복하다’ 만으로는 의미가 정확한 것 같지 않아서 ‘동작을 반복 적용하기’ 라는 말로 옮깁니다. <a href="#fnref:iterate-over" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:enumerate" role="doc-endnote">
      <p>‘enumerate’ 에는 ‘열거하다, 헤아리다’ 라는 의미가 있으며, 스위프트에서 ‘enumeration (열거체)’ 는 하나의 타입이기도 합니다. <a href="#fnref:enumerate" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:tuple" role="doc-endnote">
      <p>‘tuple’ 은 ‘두 개로 짝을 이룬 것’ 을 나타내는 데, 스위프트의 타입 중 하나를 나타내기 위해 ‘튜플’ 이라는 발음 그대로 사용하기로 합니다. <a href="#fnref:tuple" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:hashable" role="doc-endnote">
      <p>‘hash’ 는 ‘고기와 감자를 잘게 다져서 마구잡이로 섞어놓은 음식’ 에서 유래한 말로 ‘많은 것들이 마구잡이로 뒤섞인 것’ 을 말합니다. ‘hashable’ 은 이렇게 ‘hash 를 만들 수 있는’ 이라는 의미를 가진 단어입니다. 이것을 컴퓨터 용어로 이해하면 타입이 ‘hashable’ 이라는 말은 ‘많은 양의 정보를 잘게 쪼개서 마구 뒤섞어 놓은 형태로 저장할 수 있는’ 기능을 가지고 있다는 의미가 됩니다. 용어 자체는 맞는 말이 없으므로 ‘해쉬’ 라고 발음 그대로 사용하도록 합니다. <a href="#fnref:hashable" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:hash-value" role="doc-endnote">
      <p>‘hash value’ 란 앞서 ‘hashable’ 에서 살펴본 바와 같이, ‘잘게 쪼개지고 뒤섞일 수 있게 재가공된 값’ 정도로 이해할 수 있을 것 같습니다. <a href="#fnref:hash-value" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:enumeration" role="doc-endnote">
      <p>‘enumeration’ 은 ‘열거체’ 라는 말로 옮깁니다. 이는 ‘class’ 를 ‘객체’, ‘structure’ 를 ‘구조체’ 라고 하는 것과 맞추기 위함입니다. <a href="#fnref:enumeration" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:equtable" role="doc-endnote">
      <p>‘equtable’ 은 ‘서로 같은 지를 비교할 수 있는’ 지를 의미합니다. <a href="#fnref:equtable" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:reflexivity" role="doc-endnote">
      <p>여기서 말하는 ‘반사성’ 은 수학에서 말하는 ‘반사 관계’ 를 말하는 것 같습니다. ‘반사 관계’ 에 대해서는 위키피디아의 <a href="https://en.wikipedia.org/wiki/Reflexive_relation">Reflexive relation</a> 문서를 보도록 합니다. <a href="#fnref:reflexivity" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:symmetry" role="doc-endnote">
      <p>여기서 말하는 ‘대칭성’ 은 수학에서 말하는 ‘대칭 관계’ 를 말하는 것 같습니다. ‘대칭 관계’ 에 대해서는 위키피디아의 <a href="https://en.wikipedia.org/wiki/Symmetric_relation">Symmetric relation</a> 문서를 보도록 합니다. <a href="#fnref:symmetry" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:transitivity" role="doc-endnote">
      <p>여기서 말하는 ‘추이성’ 은 수학에서 말하는 ‘추이 관계’ 를 말하는 것 같습니다. ‘추이 관계’ 에 대해서는 위키피디아의 <a href="https://en.wikipedia.org/wiki/Transitive_relation">Transitive relation</a> 문서를 보도록 합니다. <a href="#fnref:transitivity" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:set-array-literal" role="doc-endnote">
      <p>이것은 ‘배열 글자표현 (array literal)’ 만 사용할 경우, <code class="highlighter-rouge">Array</code> 로 추론되기 때문일 것입니다. <a href="#fnref:set-array-literal" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:set-operations" role="doc-endnote">
      <p>‘셋’ 은 실제로 수학에서 ‘집합’ 을 가리키는 용어인데, 스위프트의 ‘셋’ 타입은 배열이나 딕셔너리보다 좀 더 수학적인 연산에 사용하는 타입이라 이해할 수 있습니다. 따라서 여기서의 ‘set operations’ 은 ‘집합 연산’의 의미로 이해하는 것이 맞을 것 같습니다. <a href="#fnref:set-operations" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:disjoint" role="doc-endnote">
      <p>이를 수학 용어로는 ‘분리 집합 (disjoint sets)’ 이라고 하는 것 같습니다. 분리 집합에 대해서는 위키피디아의 <a href="https://en.wikipedia.org/wiki/Disjoint_sets">Disjoint sets</a>문서를 보도록 합니다. 한글로는 ‘<a href="https://ko.wikipedia.org/wiki/서로소_집합">서로 소 집합</a>’ 이라는 용어가 있는데, 프로그래밍 분야에서는 ‘분리 집합’ 이라는 표현도 같이 사용하고 있는 듯 합니다. <a href="#fnref:disjoint" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:optional-value" role="doc-endnote">
      <p>‘optional value’ 는 ‘선택적 값’ 이라고도 옮길 수 있겠지만, 여기서는 스위프트의 타입임을 드러내기 위해서 발음을 따라서 ‘옵셔널 값’ 으로 옮깁니다. <a href="#fnref:optional-value" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET