I"l<blockquote>
  <p>Apple 에서 공개한 <a href="https://docs.swift.org/swift-book/">The Swift Programming Language (Swift 5.2)</a> 책의 <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html">Basic Operators</a> 부분<sup id="fnref:Basic-Operators" role="doc-noteref"><a href="#fn:Basic-Operators" class="footnote">1</a></sup>을 번역하고 정리한 글입니다.</p>

  <p>현재 전체 중에서 번역 완료된 목록은 <a href="http://xho95.github.io/swift/programming/language/grammar/2017/02/27/The-Swift-Programming-Language.html">Swift 5.2: Swift Programming Language (스위프트 프로그래밍 언어)</a> 에서 확인할 수 있습니다.</p>
</blockquote>

<h2 id="basic-operators-기본-연산자">Basic Operators (기본 연산자)</h2>

<p><em>연산자 (operator)</em> 는 값을 검사하고, 바꾸거나 결합하는 데 사용하는 특수한 기호 또는 구절을 말합니다. 예를 들어, ‘더하기 연산자 (<code class="highlighter-rouge">+</code>)’ 는 <code class="highlighter-rouge">let i = 1 + 2</code> 에서 처럼 두 수를 더하고, ‘논리 곱 (logical AND) 연산자 (<code class="highlighter-rouge">&amp;&amp;</code>)’ 는 <code class="highlighter-rouge">if enterDoorCode &amp;&amp; passedRetinaScan</code> 에서 처럼 두 불린 (Boolean) 값을 결합합니다.</p>

<p>스위프트는 C 언어에서 제공하는 거의 대부분의 표준 연산자를 지원하며서, 거기다 일반적인 코딩 에러를 없애기 위해 몇가지 기능을 개선했습니다. ‘할당 연산자 (<code class="highlighter-rouge">=</code>)’ 는 값을 반환하지 않아서, ‘같음 연산자 (<code class="highlighter-rouge">==</code>)’ 를 의도한 곳에서 실수로 사용되는 것을 막았습니다. 산술 연산자들 (<code class="highlighter-rouge">+</code>,<code class="highlighter-rouge">-</code>, <code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">%</code> 등) 은 ‘값 넘침 (value overflow)’ 을 감지해서 막아주기 때문에, 타입의 허용 범위보다 크거나 작아진 값을 계산하는 바람에 예상하지 못한 결과가 발생하는 것을 막아줍니다. 스위프트의 ‘overflow (값 넘침) 연산자’ 를 사용해서 값을 넘치는 동작을 하도록 선택할 수도 있으며, 이는 <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID37">Overflow Operator (값 넘침 연산자)</a> 에서 설명합니다.</p>

<p>스위프트에는 C 언어에는 없는 ‘범위 (range) 연산자’ 도 제공하는데, 가령 <code class="highlighter-rouge">a..&lt;b</code> 와 <code class="highlighter-rouge">a...b</code> 가 있으며, 이를 쓰면 아주 간단하게 값의 범위를 표현할 수 있습니다.</p>

<p>이번 장은 스위프트의 일반적인 연산자에 대해 설명합니다. 스위프트의 고급 연산자는 <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html">Advanced Operators (고급 연산자)</a> 에서 다루는데, 직접 연산자를 정의하는 방법과 자기가 만든 타입에 대한 표준 연산자 구현 방법에 대해서 설명합니다.</p>

<h3 id="terminology-용어">Terminology (용어)</h3>

<p>연산자에는 단항, 이항, 삼항 연산자가 있습니다:</p>

<ul>
  <li><em>단항 (Unary)</em> 연산자는 (<code class="highlighter-rouge">-a</code> 처럼) 단일 대상에 작용합니다. ‘단항 <em>접두 (prefix)</em> 연산자’ 는 (<code class="highlighter-rouge">!b</code> 처럼) 대상의 바로 앞에 위치하고 , ‘단항 <em>접미 (suffix)</em> 연산자’ 는 (<code class="highlighter-rouge">c!</code> 처럼) 대상 바로 뒤에 위치합니다.</li>
  <li><em>이항 (Binary)</em> 연산자는 (<code class="highlighter-rouge">2 + 3</code> 처럼) 두 대상에 작용하며, 두 대상 사이에 위치하므로 <em>infix (중위))</em> 라고 합니다. [^infix]</li>
  <li><em>삼항 (Ternary)</em> 연산자는 세 개의 대상에 작용합니다. C 언어 처럼, 스위프트도 삼항 연산자는 한 개 뿐인데, 이는 ‘삼항 조건 연산자 (<code class="highlighter-rouge">a ? b : c</code>)’ 입니다.</li>
</ul>

<p>연산자가 영향을 주는 값을 <em>피연산자 (operands)</em> 라고 합니다. <code class="highlighter-rouge">1 + 2</code> 라는 식이 있을 때, <code class="highlighter-rouge">+</code> 기호는 ‘이항 연산자’ 이고, 이것의 피연산자 두 개는 값 <code class="highlighter-rouge">1</code> 과 값 <code class="highlighter-rouge">2</code> 입니다.</p>

<h3 id="assignment-operator-할당-연산자">Assignment Operator (할당 연산자)</h3>

<p><em>할당 연산자 (assignment operator)</em> (<code class="highlighter-rouge">a = b</code>) 는 <code class="highlighter-rouge">a</code> 의 값을 <code class="highlighter-rouge">b</code> 의 값으로 초기화하거나 갱신 (update) 합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
<span class="c1">// a 는 이제 10 과 같습니다.</span>
</code></pre></div></div>

<p>할당할 때 오른쪽이 ‘튜플 (tuple)’ 이라 여러 값을 가지고 있을 경우, 그 요소들을 한번에 여러 개의 상수나 변수로 분해할 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="nv">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// x 는 1 과 같고, y 는 2 와 같아집니다.</span>
</code></pre></div></div>

<p>C 언어나 오브젝티브-C 언어의 할당 연산자와는 다르게, 스위프트의 할당 연산자는 스스로 값을 반환하지 않습니다. 즉, 아래의 구문은 유효하지 않습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="p">{</span>
    <span class="c1">// 이것은 유효하지 않는데, x = y 는 값을 반환하지 않기 때문입니다.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이러한 특징은 실제로는 ‘같음 연산자 (<code class="highlighter-rouge">==</code>)’ 를 쓰려고 했는데 우연히 ‘할당 연산자 (<code class="highlighter-rouge">=</code>)’ 를 써버리는 것을 막아줍니다. <code class="highlighter-rouge">if x = y</code> 를 유효하지 않게 만드는 것으로써, 스위프트는 코드에서 이런 종류의 에러를 피하도록 해줍니다.</p>

<h3 id="arithmetic-operators-산술-연산자">Arithmetic Operators (산술 연산자)</h3>

<p>스위프트는 모든 수치 타입에 대해 다음의 네 가지 표준 <em>산술 연산자 (arithmetic operators)</em> 를 지원합니다:</p>

<ul>
  <li>더하기 (<code class="highlighter-rouge">+</code>)</li>
  <li>빼기 (<code class="highlighter-rouge">-</code>)</li>
  <li>곱하기 (<code class="highlighter-rouge">*</code>)</li>
  <li>나누기 (<code class="highlighter-rouge">/</code>)</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>       <span class="c1">// 3 과 같습니다.</span>
<span class="mi">5</span> <span class="o">-</span> <span class="mi">3</span>       <span class="c1">// 2 와 같습니다.</span>
<span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span>       <span class="c1">// 6 과 같습니다.</span>
<span class="mf">10.0</span> <span class="o">/</span> <span class="mf">2.5</span>  <span class="c1">// 4.0 과 같습니다.</span>
</code></pre></div></div>

<p>C 언어나 오브젝티브-C 언어의 산술 연산자와는 다르게, 스위프트의 산술 연산자는 기본적으로 ‘값 넘침 (overflow)’ 을 허용하지 않습니다. 값 넘침을 허용하려면 스위프트의 ‘값 넘침 연산자 (overflow operators)’ 를 사용하면 됩니다. (<code class="highlighter-rouge">a &amp;+ b</code> 같은 것이 있습니다.) 이에 대해서는 <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID37">Overflow Operator (값 넘침 연산자)</a> 를 보도록 합니다.</p>

<p>‘더하기 연산자 (addition operator)’ 로는 <code class="highlighter-rouge">String</code> 을 연결할 수도 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"hello, "</span> <span class="o">+</span> <span class="s">"world"</span>  <span class="c1">// "hello, world" 와 같아집니다.</span>
</code></pre></div></div>

<h4 id="remainder-operator-나머지-연산자">Remainder Operator (나머지 연산자)</h4>

<p><em>나머지 연산자 (remainder operator)</em> (<code class="highlighter-rouge">a % b</code>) 는 <code class="highlighter-rouge">a</code> 안을 <code class="highlighter-rouge">b</code> 의 배수로 채운 다음에 그래도 남는 값을 반환합니다. (이를 <em>나머지 (remainder)</em> 라고 합니다.)</p>

<blockquote>
  <p>다른 언어에서는 ‘나머지 연산자 (remainder operator)’ (<code class="highlighter-rouge">%</code>) 를 ‘<em>모듈러 연산자 (modulo operator)</em>’ 라고도 합니다. 하지만, 음수에 대한 연산 방식을 보면, 스위프트에서는 엄밀히 말해서, <em>모듈러 연산 (modulo operation)</em><sup id="fnref:modulo-opartion" role="doc-noteref"><a href="#fn:modulo-opartion" class="footnote">2</a></sup> 이라기 보다는 나머지라고 하는 것이 맞습니다.</p>
</blockquote>

<p>이제 ‘나머지 연산자’ 의 작동 방식을 알아봅시다. <code class="highlighter-rouge">9 % 4</code> 를 계산하면, 일단 <code class="highlighter-rouge">4</code> 의 배수로 <code class="highlighter-rouge">9</code> 를 채웁니다:</p>

<p><img src="/assets/Swift/Swift-Programming-Language/Basic-Operators-remainder-operator-works.jpg" alt="Indentation" /></p>

<p><code class="highlighter-rouge">4</code> 2 개로 <code class="highlighter-rouge">9</code> 를 채우고 나면, 나머지는 <code class="highlighter-rouge">1</code> 이 됩니다. (주황색 부분입니다.)</p>

<p>스위프트로는, 이를 다음 처럼 작성합니다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>9 % 4    // 1 과 같습니다.
</code></pre></div></div>

<p><code class="highlighter-rouge">a % b</code> 의 답을 결정하기 위해, ‘<code class="highlighter-rouge">%</code> 연산자’ 는 다음 식을 계산한 후 그 결과로 <code class="highlighter-rouge">remainder</code> 를 반환합니다:</p>

<p><code class="highlighter-rouge">a</code> = (<code class="highlighter-rouge">b</code> x <code class="highlighter-rouge">some multiplier</code>) + <code class="highlighter-rouge">remainder</code></p>

<p>여기서 <code class="highlighter-rouge">some multiplier</code> 는 <code class="highlighter-rouge">a</code> 내부를 채울 수 있는 <code class="highlighter-rouge">b</code> 의 가장 큰 배수입니다.</p>

<p><code class="highlighter-rouge">9</code> 와 <code class="highlighter-rouge">4</code> 를 넣으면 다음 식이 도출됩니다:</p>

<p><code class="highlighter-rouge">9</code> = (<code class="highlighter-rouge">4</code> x <code class="highlighter-rouge">2</code>) + <code class="highlighter-rouge">1</code></p>

<p>같은 방법으로 <code class="highlighter-rouge">a</code> 가 음수일 때도 나머지를 계산할 수 있습니다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-9 % 4   // -1 과 같습니다.
</code></pre></div></div>

<p><code class="highlighter-rouge">9</code> 와 <code class="highlighter-rouge">4</code> 를 넣으면 다음 식이 도출됩니다:</p>

<p><code class="highlighter-rouge">-9</code> = (<code class="highlighter-rouge">4</code> x <code class="highlighter-rouge">-2</code>) + <code class="highlighter-rouge">-1</code></p>

<p>주어진 식의 나머지 값은 <code class="highlighter-rouge">-1</code> 입니다.</p>

<p>여기서 <code class="highlighter-rouge">b</code> 가 음수 값일 때라도 <code class="highlighter-rouge">b</code> 의 부호를 무시합니다. 이는 <code class="highlighter-rouge">a % b</code> 와 <code class="highlighter-rouge">a % -b</code> 의 답이 항상 같다는 것을 의미합니다.</p>

<h4 id="unary-minus-operator-단항-음수-연산자">Unary Minus Operator (단항 음수 연산자)</h4>

<p>수치 값의 부호를 전환하려면 접두사 <code class="highlighter-rouge">-</code> 를 붙이며, 이를 ‘<em>단항 음수 연산자 (unary minus operator)</em>’ 라고 합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">three</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">let</span> <span class="nv">minusThree</span> <span class="o">=</span> <span class="o">-</span><span class="n">three</span>       <span class="c1">// minusThree 는 -3 과 같습니다.</span>
<span class="k">let</span> <span class="nv">plusThree</span> <span class="o">=</span> <span class="o">-</span><span class="n">minusThree</span>   <span class="c1">// plusThree 는 3 과 같으며, "minus minus three" 라고도 합니다.</span>
</code></pre></div></div>

<p>‘단항 음수 연산자 (<code class="highlighter-rouge">-</code>)’ 는 빈 공백없이 연산될 값 바로 앞에 위치합니다.</p>

<h4 id="unary-plus-operator-단항-양수-연산자">Unary Plus Operator (단항 양수 연산자)</h4>

<p>‘<em>단항 양수 연산자 (unary plus operator)</em>’ (<code class="highlighter-rouge">+</code>) 는 단순히 연산 값을 그대로 반환하며, 어떤 변경도 하지 않습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">minusSix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span>
<span class="k">let</span> <span class="nv">alsoMinusSix</span> <span class="o">=</span> <span class="o">+</span><span class="n">minusSix</span>  <span class="c1">// alsoMinusSix 는 -6 과 같습니다.</span>
</code></pre></div></div>

<p>‘단항 양수 연산자’ 가 실제로 하는 일은 없지만, 이것을 양수에 사용하면 ‘단항 음수 연산자’ 로 표현한 음수와 나란하게 코드를 배치할 수 있습니다.</p>

<h3 id="compound-assignment-operators-복합-할당-연산자">Compound Assignment Operators (복합 할당 연산자)</h3>

<p>C 언어처럼, 스위프트는 <em>복합 할당 연산자 (compound assignment operators)</em> 를 제공하며 이는 ‘할당 연산 (<code class="highlighter-rouge">=</code>)’ 을 다른 연산과 결합합니다. 한 가지 예로는 ‘더하기 할당 연산자 (addition assignment operator)’ (<code class="highlighter-rouge">+=</code>)  가 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="c1">// a 는  3 과 같습니다.</span>
</code></pre></div></div>

<p>표현식 <code class="highlighter-rouge">a += 2</code> 는 <code class="highlighter-rouge">a = a + 2</code> 의 약칭입니다. 효과적으로, 더하기와 할당 연산을 하나의 연산자로 결합하여 한번에 두 작업을 동시에 수행합니다.</p>

<blockquote>
  <p>‘복합 할당 연산자’ 는 값을 반환하지 않습니다. 예를 들어 <code class="highlighter-rouge">let b = a += 2</code> 라고 작성할 수 없습니다.</p>
</blockquote>

<p>스위프트 표준 라이브러리에서 제공하는 연산자에 대한 정보는 <a href="https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations">Operator Declaration (연산자 선언)</a> 을 보기 바랍니다.</p>

<h3 id="comparison-operators-비교-연산자">Comparison Operators (비교 연산자)</h3>

<p>스위프트는 C 언어에 있는 모든 표준 <em>비교 연산자 (comparison operators)</em> 를 지원합니다:</p>

<ul>
  <li>같음 (<code class="highlighter-rouge">a == b</code>) - 등호</li>
  <li>같지 않음 (<code class="highlighter-rouge">a != b</code>) - 부등호</li>
  <li>보다 큼 (<code class="highlighter-rouge">a &gt; b</code>)</li>
  <li>보다 작음 (<code class="highlighter-rouge">a &lt; b</code>)</li>
  <li>크거나 같음 (<code class="highlighter-rouge">a &gt;= b</code>)</li>
  <li>작거나 같음 (<code class="highlighter-rouge">a &lt;= b</code>)</li>
</ul>

<blockquote>
  <p>스위프트는 두 개의 ‘<em>식별 연산자 (identity operators)</em>’ (<code class="highlighter-rouge">===</code> 와 <code class="highlighter-rouge">!==</code>) 도 제공하여, 두 객체에 대한 참조 모두 동일한 객체 인스턴스를 참조하고 있는지를 검사할 수 있습니다. 더 자세한 내용은 <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html#ID90">Identity Operators (식별 연산자)</a> 를 보기 바랍니다.</p>
</blockquote>

<p>각각의 ‘비교 연산자’ 는 <code class="highlighter-rouge">Bool</code> 값을 반환하여 그 구문이 참인지 아닌지를 나타냅니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>   <span class="c1">// true (참), 1 은 1 과 같기 때문입니다.</span>
<span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span>   <span class="c1">// true (참), 2 는 1 과 같지 않기 때문입니다.</span>
<span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">1</span>    <span class="c1">// true (참b, 2 는 1 보다 크기 때문입니다.</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span>    <span class="c1">// true (참), 1 은 2 보다 작기 때문입니다.</span>
<span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">1</span>   <span class="c1">// true (참), 1 은 1 보다 크거가 같기 때문입니다.</span>
<span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span>   <span class="c1">// false (거짓), 2 는 1 보다 작거나 같지 않기 때문입니다.</span>
</code></pre></div></div>

<p>비교 연산자 주로 ‘조건 구문 (conditional statements)’ 에서 사용되며, 여기에는 <code class="highlighter-rouge">if</code> 구문 등이 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">name</span> <span class="o">=</span> <span class="s">"world"</span>
<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">"world"</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"hello, world"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"I'm sorry </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">, but I don't recognize you"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "hello, world" 를 출력합니다. name 이 진짜 "world" 와 같기 때문입니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">if</code> 구문에 대해서는, <a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html">Control Flow</a> 를 보기 바랍니다.</p>

<p>두 개의 ‘튜플 (tuples)’ 이 같은 타입에 같은 개수의 값을 가지고 있으면 서로 비교할 수 있습니다. 튜플을 비교할 때는 왼쪽에서 오른쪽으로, 한번에 한 값씩, 두 값이 같지 않을 때까지 비교합니다. 두 값을 비교하면, 이 비교의 결과가 튜플 비교 연산의 전체 결과를 결정합니다. 모든 요소가 같으면, 튜플 자체가 같은 것입니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"zebra"</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"apple"</span><span class="p">)</span>   <span class="c1">// true (참), 1 은 2 보다 작기 때문입니다; "zebra" 와 "apple" 은 서로 비교되지 않습니다.</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"apple"</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"bird"</span><span class="p">)</span>    <span class="c1">// true (참), 3 은 3 과 같고, "apple" 은 "bird" 보다 작기 때문입니다.</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">"dog"</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">"dog"</span><span class="p">)</span>      <span class="c1">// true (참), 4 는 4 와 같고, "dog" 도 "dog" 과 같기 때문입니다.</span>
</code></pre></div></div>

<p>위 예의 첫 번째 줄에서, ‘왼쪽에서-오른쪽 순으로 (left-to-right)’ 비교 동작이 진행되는 것을 볼 수 있습니다. <code class="highlighter-rouge">1</code> 이 <code class="highlighter-rouge">2</code> 보다 작으므로, <code class="highlighter-rouge">(1, "zebra")</code> 는 <code class="highlighter-rouge">(2, "apple")</code> 보다 작은 것으로 간주되며, 튜플의 나머지 값들은 상관이 없습니다. <code class="highlighter-rouge">"zebra"</code> 가 <code class="highlighter-rouge">"apple"</code> 보다 작지 않아도 상관이 없는 것은, 비교가 이미 튜플의 첫 번째 요소에 의해 결정되었기 때문입니다. 하지만, 튜플의 첫 번째 요소들이 같으면, 두 번째 요소들이 <em>이제 (are)</em> 비교됩니다-두 번째 줄과 세 번째 줄에서 일어난 것이 이것입니다.</p>

<p>주어진 연산자로 튜플을 비교하려면 그 연산자는 해당 튜플의 각각의 값에 대해 적용할 수 있어야만 합니다.</p>

<p>예를 들어, 아래에 나타낸 코드처럼, 타입이 <code class="highlighter-rouge">(String, Int)</code> 인 두 개의 튜플을 비교할 수 있는 것은 <code class="highlighter-rouge">String</code> 과 <code class="highlighter-rouge">Int</code> 값 모두 <code class="highlighter-rouge">&lt;</code> 연산자를 써서 비교할 수 있기 때문입니다. 이와는 다르게, 타입이 <code class="highlighter-rouge">(String, Bool)</code> 인 두 개의 튜플은 <code class="highlighter-rouge">&lt;</code> 연산자로 비교할 수 없는데 이는 <code class="highlighter-rouge">&lt;</code> 연산자를 <code class="highlighter-rouge">Bool</code> 값에 적용할 수 없기 때문입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="s">"blue"</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="s">"purple"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>        <span class="c1">// OK, true (참) 으로 평가합니다.</span>
<span class="p">(</span><span class="s">"blue"</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="s">"purple"</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>  <span class="c1">// Error, &lt; 는 불린 값을 비교할 수 없습니다.</span>
</code></pre></div></div>

<blockquote>
  <p>스위프트 표준 라이브러리에 있는 튜플 비교 연산자는 7개 미만의 요소를 가진 튜플만 비교할 수 있습니다. 7개 이상의 요소를 가진 튜플을 비교하려면 비교 연산자를 직접 구현해야만 합니다.</p>
</blockquote>

<h3 id="ternary-conditional-operator-삼항-조건-연산자">Ternary Conditional Operator (삼항 조건 연산자)</h3>

<p><em>삼항 조건 연산자 (ternary conditional operator)</em> 는 세 부분으로 구성된 특수한 연산자로, 양식은 <code class="highlighter-rouge">question ? answer1 : answer2</code> 와 같습니다. 이는 <code class="highlighter-rouge">question</code> 이 참인지 거짓인지에 따라서 두 표현식 중 하나의 값을 평가하는 ‘간략한 표기법 (shortcut)’ 입니다. <code class="highlighter-rouge">question</code> 이 참이면, <code class="highlighter-rouge">answer1</code> 을 평가한 값을 반환하고; 그렇지 않으면, <code class="highlighter-rouge">answer2</code> 를 평가한 값을 반환합니다.</p>

<p>‘삼항 조건 연산자’ 는 아래 코드의 약칭에 해당합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">question</span> <span class="p">{</span>
    <span class="n">answer1</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">answer2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>다음은 테이블에서 행의 높이를 계산하는 예제입니다. 행에 ‘헤더 (header)’ 가 있으면 ‘행 높이 (row height)’ 가 ‘내용물 높이 (content height)’ 보다 50 포인트 만큼 더 높고, 헤더가 없으면 20 포인트 만큼 더 높습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">contentHeight</span> <span class="o">=</span> <span class="mi">40</span>
<span class="k">let</span> <span class="nv">hasHeader</span> <span class="o">=</span> <span class="kc">true</span>
<span class="k">let</span> <span class="nv">rowHeight</span> <span class="o">=</span> <span class="n">contentHeight</span> <span class="o">+</span> <span class="p">(</span><span class="n">hasHeader</span> <span class="p">?</span> <span class="mi">50</span> <span class="p">:</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">// rowHeight 는 90 과 같습니다.</span>
</code></pre></div></div>

<p>위 예제는 아래 코드의 약칭에 해당합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">contentHeight</span> <span class="o">=</span> <span class="mi">40</span>
<span class="k">let</span> <span class="nv">hasHeader</span> <span class="o">=</span> <span class="kc">true</span>
<span class="k">let</span> <span class="nv">rowHeight</span><span class="p">:</span> <span class="kt">Int</span>
<span class="k">if</span> <span class="n">hasHeader</span> <span class="p">{</span>
    <span class="n">rowHeight</span> <span class="o">=</span> <span class="n">contentHeight</span> <span class="o">+</span> <span class="mi">50</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">rowHeight</span> <span class="o">=</span> <span class="n">contentHeight</span> <span class="o">+</span> <span class="mi">20</span>
<span class="p">}</span>
<span class="c1">// rowHeight 는 90 과 같습니다.</span>
</code></pre></div></div>

<p>첫 번째 예제에서 ‘삼항 조건 연산자’ 를 사용함으로써 <code class="highlighter-rouge">rowHeight</code> 의 값을 코드 한 줄로 올바르게 설정할 수 있었으며, 이는 두 번째 예제의 코드보다 훨씬 더 간결합니다.</p>

<p>‘삼항 조건 연산자’ 는 두 표현식 중 하나를 고르는 구문에 대한 효율적인 약칭을 제공합니다. 하지만, 삼항 조건 연산자는 주의해서 사용하기 바랍니다. 간결함을 추구한 나머지 너무 과용하다보면 코드를 이해하기가 어려워집니다. 여러 개의 삼항 조건 연산자 구문를 결합해서 하나의 복합 구문을 만드는 것은 피하는 것이 좋습니다.</p>

<h3 id="nil-coalescing-operator-nil-통합-연산자">Nil-Coalescing Operator (Nil-통합 연산자)</h3>

<p><em>nil-통합 연산자 (nil-coalescing operator)</em> (<code class="highlighter-rouge">a ?? b</code>) 는 옵셔널 <code class="highlighter-rouge">a</code> 에 값이 있으면 <code class="highlighter-rouge">a</code> 를 풀고, <code class="highlighter-rouge">a</code> 가 <code class="highlighter-rouge">nil</code> 이면 기본 설정 값인 <code class="highlighter-rouge">b</code> 를 반환합니다. 표현식 <code class="highlighter-rouge">a</code> 는 항상 옵셔널 타입이어야 합니다. 표현식 <code class="highlighter-rouge">b</code> 는 반드시 <code class="highlighter-rouge">a</code> 에 저장된 것과 타입이 일치해야 합니다.</p>

<p>‘nil-통합 연산자 (nil-coalescing operator) 는 아래 코드의 약칭에 해당합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">?</span> <span class="n">a</span><span class="o">!</span> <span class="p">:</span> <span class="n">b</span>
</code></pre></div></div>

<p>위의 코드는 ‘삼항 조건 연산자’ 와 ‘강제 풀기 (forced unwrapping)’ (<code class="highlighter-rouge">a!</code>) 를 사용하여 <code class="highlighter-rouge">a</code> 가 <code class="highlighter-rouge">nil</code> 이 아니면 <code class="highlighter-rouge">a</code> 안에 쌓여진 값에 접근하고, 그 외의 경우면 <code class="highlighter-rouge">b</code> 를 반환합니다. 이와 같이 ‘nil-통합 연산자’ 가 제공하는 우아한 방법을 사용하면 조건 검사 및 풀기 연산을 간결하고 이해하기 쉬운 양식으로 작성할 수 있습니다.</p>

<blockquote>
  <p><code class="highlighter-rouge">a</code> 의 값이 <code class="highlighter-rouge">nil</code> 이 아닐 경우, <code class="highlighter-rouge">b</code> 의 값을-평가하는 일은 일어나지 않습니다. 이를 ‘<em>최소 평가 (short-circuit evaluation)</em>’ 이라고 합니다. <sup id="fnref:short-circuit" role="doc-noteref"><a href="#fn:short-circuit" class="footnote">3</a></sup></p>
</blockquote>

<p>아래 예제는 ‘nil-통합 연산자’ 를 사용하여 ‘기본 색상 이름’ 과 ‘사용자가 정의한 옵셔널 색상 이름’ 중 하나를 선택합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">defaultColorName</span> <span class="o">=</span> <span class="s">"red"</span>
<span class="k">var</span> <span class="nv">userDefinedColorName</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>   <span class="c1">// 기본으로 nil 이 됩니다.</span>

<span class="k">var</span> <span class="nv">colorNameToUse</span> <span class="o">=</span> <span class="n">userDefinedColorName</span> <span class="p">??</span> <span class="n">defaultColorName</span>
<span class="c1">// userDefinedColorName 이 nil 이므로, colorNameToUse 는 기본 설정 값인 "red" 입니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">userDefinedColorName</code> 변수는 옵셔널 <code class="highlighter-rouge">String</code> 으로 정의되었으며, 기본 설정 값은 <code class="highlighter-rouge">nil</code> 입니다. <code class="highlighter-rouge">userDefinedColorName</code> 이 옵셔널 타입이므로, 해당 값에 <code class="highlighter-rouge">nil-통합 연산자</code> 를 적용할 수 있습니다. 위 예에서는, 이 연산자를 사용하여 <code class="highlighter-rouge">colorNameToUse</code> 라는 <code class="highlighter-rouge">String</code> 변수의 기본 설정 값을 결정합니다. <code class="highlighter-rouge">userDefinedColorName</code> 이 <code class="highlighter-rouge">nil</code> 이기 때문에, 표현식 <code class="highlighter-rouge">userDefinedColorName ?? defaultColorName</code> 은 <code class="highlighter-rouge">defaultColorName</code> 의 값을 반환하며, 이는 <code class="highlighter-rouge">"red"</code> 입니다.</p>

<p>만약 ‘<code class="highlighter-rouge">nil</code> 이 아닌 값’ 을 <code class="highlighter-rouge">userDefinedColorName</code> 에 할당한 다음에 ‘nil-통합 연산자 (nil-coalescing operator)’ 검사를 다시 수행하면, 기본 설정 값 대신 <code class="highlighter-rouge">userDefinedColorName</code> 로 감싼 값을 사용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">userDefinedColorName</span> <span class="o">=</span> <span class="s">"green"</span>
<span class="n">colorNameToUse</span> <span class="o">=</span> <span class="n">userDefinedColorName</span> <span class="p">??</span> <span class="n">defaultColorName</span>
<span class="c1">// userDefinedColorName 이 nil 이 아니므로, colorNameToUse 는 "green" 으로 설정됩니다.</span>
</code></pre></div></div>

<h3 id="range-operators-범위-연산자">Range Operators (범위 연산자)</h3>

<p>스위프트는 값의 범위를 간단하게 표현할 수 있는 여러 가지의 <em>범위 연산자 (range operators)</em> 를 포함하고 있습니다.</p>

<h4 id="closed-range-operator-닫힌-범위-연산자">Closed Range Operator (닫힌 범위 연산자)</h4>

<p>‘닫힌 범위 연산자 (closed range operator)’ (<code class="highlighter-rouge">a...b</code>) 는 <code class="highlighter-rouge">a</code> 에서 <code class="highlighter-rouge">b</code> 에 이르는 범위를 정의하면서, <code class="highlighter-rouge">a</code> 와 <code class="highlighter-rouge">b</code> 의 값을 포함합니다. 여기서 <code class="highlighter-rouge">a</code> 의 값은 <code class="highlighter-rouge">b</code> 보다 절대로 크면 안됩니다.</p>

<p>‘닫힌 범위 연산자’ 는 범위 내에 있는 모든 값에 동작을 반복 적용할 때 유용하며, 보통 <code class="highlighter-rouge">for-in</code> 반복문과 같이 사용하게 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">5</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">index</span><span class="se">)</span><span class="s"> times 5 is </span><span class="se">\(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">5</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 1 times 5 is 5</span>
<span class="c1">// 2 times 5 is 10</span>
<span class="c1">// 3 times 5 is 15</span>
<span class="c1">// 4 times 5 is 20</span>
<span class="c1">// 5 times 5 is 25</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">for-in</code> 반복문 대해서는, <a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html">Control Flow</a> 를 보기 바랍니다.</p>

<h4 id="half-open-range-operator-반-열린-범위-연산자">Half-Open Range Operator (반-열린 범위 연산자)</h4>

<p>‘<em>반-열린 범위 연산자 (half-open range operator)</em>’ (<code class="highlighter-rouge">a..&lt;b</code>) 는 <code class="highlighter-rouge">a</code> 에서 <code class="highlighter-rouge">b</code> 에 이르는 범위를 정의하면서, <code class="highlighter-rouge">b</code> 는 포함하지 않습니다. <em>반-열린 (half-open)</em> 이라는 말은 이것이 첫 번째 값은 갖지만, 마지막 값은 갖지 않기 때문입니다. ‘닫힌 범위 연산자’ 와 마찬가지로, <code class="highlighter-rouge">a</code> 의 값은 <code class="highlighter-rouge">b</code> 보다 절대로 크면 안됩니다. 만약 <code class="highlighter-rouge">a</code> 의 값이 <code class="highlighter-rouge">b</code> 와 같을 경우, 그 결과는 빈 범위가 됩니다.</p>

<p>‘반-열린 범위 연산자’ 는 배열처럼 ‘0-시작 목록 (zero-based lists)’ 과 작업할 때 특히 더 유용한데, 이는 목록 전체를 반복하면서 마지막 수를 포함하지 않기 때문입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Anna"</span><span class="p">,</span> <span class="s">"Alex"</span><span class="p">,</span> <span class="s">"Brian"</span><span class="p">,</span> <span class="s">"Jack"</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">count</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">count</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">count</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Person </span><span class="se">\(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="se">)</span><span class="s"> is called </span><span class="se">\(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Person 1 is called Anna</span>
<span class="c1">// Person 2 is called Alex</span>
<span class="c1">// Person 3 is called Brian</span>
<span class="c1">// Person 4 is called Jack</span>
</code></pre></div></div>

<p>이 배열은 4 개의 항목을 갖지만, <code class="highlighter-rouge">0..&lt;count</code> 는 (배열 마지막 요소의 색인인) <code class="highlighter-rouge">3</code> 까지만 헤아리며, 이는 ‘반-열린 연산자’ 이기 때문입니다. 배열에 대해서는 <a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html#ID107">Arrays</a> 를 보기 바랍니다.</p>

<h4 id="one-sided-ranges-한-쪽-범위">One-Sided Ranges (한-쪽 범위)</h4>

<p>‘닫힌 범위 연산자’ 는 한 방향으로 가능한 멀리 계속되는 범위를 나타낼 수 있는 ‘대체 양식 (alternative form)’ 을 갖고 있습니다-예를 들어, 한 배열에 대해 2 에서 부터 끝까지의 모든 배열 요소를 포함하는 범위가 있을 수 있습니다. 이 경우, 범위 연산자의 한-쪽 값을 생략할 수 있습니다. 이러한 종류의 범위를 <em>한-쪽 범위 (one-sided range)</em> 라고 부르며, 이는 연산자가 오직 한 쪽 값만을 갖고 있기 때문입니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">name</span> <span class="k">in</span> <span class="n">names</span><span class="p">[</span><span class="mi">2</span><span class="o">...</span><span class="p">]</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Brian</span>
<span class="c1">// Jack</span>

<span class="k">for</span> <span class="n">name</span> <span class="k">in</span> <span class="n">names</span><span class="p">[</span><span class="o">...</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Anna</span>
<span class="c1">// Alex</span>
<span class="c1">// Brian</span>
</code></pre></div></div>

<p>‘반-열린 범위 연산자’ 도 ‘한-쪽 양식 (one-sided form)’ 을 갖고 있지만 대신 한-쪽 값은 반드시 마지막 값이어야 합니다. 값을 양쪽에 적어줄 때와 마찬가지로, 마지막 값은 범위에 포함되지 않습니다. 예를 들면 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">name</span> <span class="k">in</span> <span class="n">names</span><span class="p">[</span><span class="o">..&lt;</span><span class="mi">2</span><span class="p">]</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Anna</span>
<span class="c1">// Alex</span>
</code></pre></div></div>

<p>‘한-쪽 범위 (one-sided range)’ 는 ‘첨자 연산 (subscript)’ 뿐만 아니라, 다른 곳에서도 사용할 수 있습니다. ‘한-쪽 범위’ 가 생략한 값이 첫 번째 값이면 동작을 반복 적용시킬 수 없는데, 이는 동작을 어디서부터 반복해야할 지 명확하지 않기 때문입니다. ‘한-쪽 범위’ 가 마지막 값을 생략했을 때는 동작을 반복 적용시키는 것이 <em>가능 (can)</em> 합니다; 다만, 범위가 무한정 계속되므로, 반복문에 명시적으로 종료 조건을 추가해야 합니다. ‘한-쪽 범위’ 가 특정 값을 갖고 있는지를 검사할 수도 있는데, 이는 아래 코드 처럼 하면 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">range</span> <span class="o">=</span> <span class="o">...</span><span class="mi">5</span>
<span class="n">range</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>   <span class="c1">// false (거짓)</span>
<span class="n">range</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>   <span class="c1">// true (참)</span>
<span class="n">range</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">// true (참)</span>
</code></pre></div></div>

<h3 id="logical-operators-논리-연산자">Logical Operators (논리 연산자)</h3>

<p><em>논리 연산자 (logical operators)</em> 는 ‘불린 논리 (Boolean logic)’ 값인 <code class="highlighter-rouge">true</code> 와 <code class="highlighter-rouge">false</code> 를 수정하거나 결합합니다. 스위프트는 C-기반 언어가 제공하는 세 가지 표준 논리 연산자를 지원합니다:</p>

<ul>
  <li>Logical NOT ‘논리 부정’ (<code class="highlighter-rouge">!a</code>)</li>
  <li>Logical AND ‘논리 곱’ (<code class="highlighter-rouge">a &amp;&amp; b</code>)</li>
  <li>Logical OR ‘논리 합’ (<code class="highlighter-rouge">a || b</code>)</li>
</ul>

<h4 id="logical-not-operator-논리-부정-연산자">Logical NOT Operator (논리 부정 연산자)</h4>

<p><em>논리 부정 연산자 (logical NOT operator)</em> (<code class="highlighter-rouge">!a</code>) 는 불린 (Boolean) 값을 반전하므로 <code class="highlighter-rouge">true</code> 는 <code class="highlighter-rouge">false</code> 가 되고, <code class="highlighter-rouge">false</code> 는 <code class="highlighter-rouge">true</code> 가 됩니다.</p>

<p>‘논리 부정 연산자’ 는 ‘접두 연산자 (prefix operator)’ 라서, 연산할 값 바로 앞에 붙여주며, 공백이 있으면 안됩니다. “Not <code class="highlighter-rouge">a</code>” (<code class="highlighter-rouge">a</code> 가 아님) 이라고 읽으며, 아래에 예를 보였습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">allowedEntry</span> <span class="o">=</span> <span class="kc">false</span>
<span class="k">if</span> <span class="o">!</span><span class="n">allowedEntry</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ACCESS DENIED"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "ACCESS DENIED" 를 출력합니다.</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">if !allowedEntry</code> 구절은 “허가된 입장이 아니면 (if not allowed entry)” 으로 읽을 수 있습니다. 그 다음 행은 “허가된 입장이 아니면” 이 참일 때만 실행됩니다; 그것은 곧, <code class="highlighter-rouge">allowedEntry</code> 가 <code class="highlighter-rouge">false</code> 일 때입니다.</p>

<p>이 예제와 같이, 불린 (Boolean) 상수와 변수의 이름을 정할 때는 주의 깊에 선택해야 코드를 이해하기 슆고 간결하게 만들 수 있으며, 이중 부정을 하거나 논리 구문을 혼동하는 것을 막을 수 있습니다.</p>

<h4 id="logical-and-operator-논리-곱-연산자">Logical AND Operator (논리 곱 연산자)</h4>

<p><em>논리 곱 연산자 (logical AND operator)</em> (<code class="highlighter-rouge">a &amp;&amp; b</code>) 는 두 값이 모두 <code class="highlighter-rouge">true</code> (참) 일 때만 전체 표현식이 <code class="highlighter-rouge">true</code> (참) 이 되는 ‘논리 표현식 (logical expressions)’ 을 생성합니다.</p>

<p>한 값이라도 <code class="highlighter-rouge">false</code> 면, 전체 표현식도 <code class="highlighter-rouge">false</code> 가 됩니다. 사실, <em>첫 번째 (first)</em> 값이 <code class="highlighter-rouge">false</code> 면, 두 번째 값은 평가조차 하지 않으며, 이는 그래봐야 전체 표현식을 <code class="highlighter-rouge">true</code> 로 만들 수가 없기 때문입니다. 이것을 ‘최소 평가 (short-circuit evaluation)’<sup id="fnref:short-circuit:1" role="doc-noteref"><a href="#fn:short-circuit" class="footnote">3</a></sup> 라고 합니다.</p>

<p>아래 예제는 두 <code class="highlighter-rouge">Bool</code> 값을 고려해서 두 값이 모두 <code class="highlighter-rouge">true</code> 일 때만 접근을 허용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">enteredDoorCode</span> <span class="o">=</span> <span class="kc">true</span>
<span class="k">let</span> <span class="nv">passedRetinaScan</span> <span class="o">=</span> <span class="kc">false</span>
<span class="k">if</span> <span class="n">enteredDoorCode</span> <span class="o">&amp;&amp;</span> <span class="n">passedRetinaScan</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Welcome!"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ACCESS DENIED"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "ACCESS DENIED" 를 출력합니다.</span>
</code></pre></div></div>

<h4 id="logical-or-operator-논리-합-연산자">Logical OR Operator (논리 합 연산자)</h4>

<p><em>논리 합 연산자 (logical OR operator)</em> (<code class="highlighter-rouge">a || b</code>) 는 두 ‘파이프 문자 (<code class="highlighter-rouge">|</code>)’ 를 붙여서 만든 ‘infix (중위) 연산자’ 입니다. 이를 사용하면 두 값 중에서 <em>하나 (one)</em> 만 <code class="highlighter-rouge">true</code> (참) 이면 전체 표현식이 <code class="highlighter-rouge">true</code> (참) 이 되는 ‘논리 표현식 (logical expressions)’ 를 생성할 수 있습니다.</p>

<p>앞서의 ‘논리 곱 연산자 (logical AND operator)’ 와 마찬가지로, ‘논리 합 연산자 (logical OR operator)’ 는 표현식을 평가할 때 ‘최소 평가 (short-circuit evaluation)’<sup id="fnref:short-circuit:2" role="doc-noteref"><a href="#fn:short-circuit" class="footnote">3</a></sup> 방식을 사용합니다. ‘논리 합 표현식 (logical OR expressions)’ 의 왼쪽이 <code class="highlighter-rouge">true</code> 면, 오른쪽은 평가하지 않으며, 이는 전체 표현식의 결과가 달라질 일이 없기 때문입니다.</p>

<p>아래 예제에서, 첫 번째 <code class="highlighter-rouge">Bool</code> 값 (<code class="highlighter-rouge">hasDoorKey</code>) 은 <code class="highlighter-rouge">false</code> 지만, 두 번째 값 (<code class="highlighter-rouge">knowsOverridePassword</code>) 은 <code class="highlighter-rouge">true</code> 입니다. 한 값이 <code class="highlighter-rouge">true</code> 이므로, 전체 표현식도 <code class="highlighter-rouge">true</code> 로 평가되어, 접근을 허용합니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">hasDoorKey</span> <span class="o">=</span> <span class="kc">false</span>
<span class="k">let</span> <span class="nv">knowsOverridePassword</span> <span class="o">=</span> <span class="kc">true</span>
<span class="k">if</span> <span class="n">hasDoorKey</span> <span class="o">||</span> <span class="n">knowsOverridePassword</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Welcome!"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ACCESS DENIED"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Welcome!" 을 출력합니다.</span>
</code></pre></div></div>

<h4 id="combining-logical-operators-논리-연산자-결합하기">Combining Logical Operators (논리 연산자 결합하기)</h4>

<p>여러 개의 논리 연산자를 결합하여 더 긴 ‘복합 표현식 (compound expressions)’ 을 만들 수 있습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">enteredDoorCode</span> <span class="o">&amp;&amp;</span> <span class="n">passedRetinaScan</span> <span class="o">||</span> <span class="n">hasDoorKey</span> <span class="o">||</span> <span class="n">knowsOverridePassword</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Welcome!"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ACCESS DENIED"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Welcome!" 을 출력합니다.</span>
</code></pre></div></div>

<p>이 예제에서는 여러 개의 <code class="highlighter-rouge">&amp;&amp;</code> 와 <code class="highlighter-rouge">||</code> 연산자를 써서 더 긴 ‘복합 표현식 (compound expressions)’ 을 만들었습니다. 하지만, <code class="highlighter-rouge">&amp;&amp;</code> 와 <code class="highlighter-rouge">||</code> 연산자는 여전히 두 값에 대해서만 동작하므로, 실제로는 세 개의 작은 식이 서로 줄줄이 이어져 있는 형태입니다. 이 예제는 다음과 같이 이해할 수 있습니다:</p>

<p>올바른 출입문 코드를 입력하고 망막 스캔을 통과했거나, 알맞은 출입문 키를 갖고 있거나, ‘비상시 수동해제 비밀번호 (emergency override password)’ 를 알고 있는 경우라면, 접근을 허용합니다.</p>

<p><code class="highlighter-rouge">enterDoorCode</code>, <code class="highlighter-rouge">passedRetinaScan</code> 그리고 <code class="highlighter-rouge">hasDoorKey</code> 의 값에 의해서, 처음 두 개의 ‘하위표현식 (subexpressions)’ 은 <code class="highlighter-rouge">false</code> 입니다. 하지만, ‘비상시 수동해제 비밀번호’ 를 알고 있으므로, 전체 복합 표현식은 여전히 <code class="highlighter-rouge">true</code> 가 됩니다.</p>

<blockquote>
  <p>스위프트의 논리 연산자인 <code class="highlighter-rouge">&amp;&amp;</code> 와 <code class="highlighter-rouge">||</code> 는 ‘왼쪽 우선-결합 (left-associative)’<sup id="fnref:left-associative" role="doc-noteref"><a href="#fn:left-associative" class="footnote">4</a></sup> 으로, 이는 여러 개의 논리 연산자를 가지는 ‘복합 표현식’ 이 있을 때 가장 왼쪽에 있는 ‘하위표현식’ 부터 먼저 평가한다는 의미입니다.</p>
</blockquote>

<h4 id="explicit-parentheses-괄호-명시하기">Explicit Parentheses (괄호 명시하기)</h4>

<p>반드시 넣어야 하는 것은 아니지만, 그래도 ‘괄호 (parentheses)’ 를 넣어주면, 복합한 표현식의 의도를 이해하기가 훨씬 쉬어집니다. 위에 있는 ‘출입문 접근’ 예제에서도, ‘복합 표현식’ 의 첫 부분에 괄호를 추가하면 그 의도를 더 명확하게 알 수 있게 됩니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">enteredDoorCode</span> <span class="o">&amp;&amp;</span> <span class="n">passedRetinaScan</span><span class="p">)</span> <span class="o">||</span> <span class="n">hasDoorKey</span> <span class="o">||</span> <span class="n">knowsOverridePassword</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Welcome!"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"ACCESS DENIED"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// "Welcome!" 를 출력합니다.</span>
</code></pre></div></div>

<p>괄호를 사용하면 처음 두 값들이 전체 논리에서 별도로 검토할 수 있음을 분명하게 보여줍니다. 복합 표현식의 결과에는 전혀 영향이 없으면서도, 전체 의도를 이해하기는 훨씬 더 쉽습니다. 가독성을 간결함보다 더 우선하기 바랍니다; 괄호가 의도를 분명히 드러내는데 도움이 된다면 사용하는 것이 좋습니다.</p>

<h3 id="참고-자료">참고 자료</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:Basic-Operators" role="doc-endnote">
      <p>원문은 <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html">Basic Operators</a> 에서 확인할 수 있습니다. <a href="#fnref:Basic-Operators" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:modulo-opartion" role="doc-endnote">
      <p>‘modulo operation’ 은 수학적으로 엄밀한 ‘나머지 연산’ 과 연관되어 있는 것 같습니다. 보다 자세한 내용은 위키피디아의 <a href="https://en.wikipedia.org/wiki/Modulo_operation">Modulo operation</a> 글을 참고하기 바랍니다. 이와 연관된 한글 자료가 거의 없는 거 같은데, 한글로는 <a href="https://ko.wikipedia.org/wiki/합동_산술">합동 산술</a> 부분을 보면 도움이 될 것 같습니다. <a href="#fnref:modulo-opartion" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:short-circuit" role="doc-endnote">
      <p>‘short-circuit evaluation’ 를 직역하면 ‘짧은-회로 평가’ 가 되는데, ‘minimal evaluation’ 이라는 용어도 같이 사용하므로 ‘최소 평가’ 라고 옮깁니다. 컴퓨터 공학에서 계산량을 줄이는 알고리즘이라고 볼 수 있을 것 같습니다. 더 자세한 정보는 위키피디아의 <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">Short-circuit evaluation</a> 항목을 참고하기 바랍니다. <a href="#fnref:short-circuit" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:short-circuit:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:short-circuit:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:left-associative" role="doc-endnote">
      <p>‘left-associative’ 를 ‘왼쪽 우선-결합’ 이라고 옮겼습니다. 이에 대한 더 자세한 정보는 위키피디아의 <a href="https://en.wikipedia.org/wiki/Operator_associativity">Operator associativity</a> 항목을 참고하기 바랍니다. <a href="#fnref:left-associative" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET