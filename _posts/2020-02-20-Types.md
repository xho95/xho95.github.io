---
layout: post
comments: true
title:  "Swift 5.3: Types (타입)"
date:   2020-02-20 11:30:00 +0900
categories: Swift Language Grammar Types Self
redirect_from: "/swift/language/grammar/self/type/2020/02/20/"
---

> Apple 에서 공개한 [The Swift Programming Language (Swift 5.3)](https://docs.swift.org/swift-book/) 책의 [Types](https://docs.swift.org/swift-book/ReferenceManual/Types.html) 부분[^Types]을 번역하고, 설명이 필요한 부분은 주석을 달아서 정리한 글입니다.
>
> 현재 번역이 진행 중인데, 2020-06-22 에 Swift 5.3 이 발표되어, 이미 번역된 부분과 남은 부분 모두 Swift 5.3 을 기준으로 옮기도록 합니다. 완료된 목록은 [Swift 5.3: Swift Programming Language (스위프트 프로그래밍 언어)]({% post_url 2017-02-28-The-Swift-Programming-Language %}) 에서 확인할 수 있으며, 일부는 Swift 5.2 기준일 수 있습니다.

## Types (타입)

스위프트에는, 두 가지 종류의 타입이 있습니다: '이름 있는 타입 (named types)' 과 '복합 타입 (compound types)' 이 그것입니다. _이름 있는 타입 (named type)_ 은 정의할 때 특정한 이름을 부여할 수 있는 타입입니다. 이름 있는 타입에는 클래스, 구조체, 열거체, 그리고 프로토콜이 포함됩니다. 예를 들어, `MyClass` 라고 이름 지은 사용자-정의 클래스의 인스턴스들은 `MyClass` 라는 타입을 가집니다. 사용자-정의 이름 있는 타입에 더하여, 스위프트 표준 라이브러리는, 배열, 딕셔너리, 및 옵셔널 값을 표현하는 것들을 포함하여, 공통으로 많이 사용하는 이름 있는 타입을 정의하고 있습니다.

다른 언어에서는 보통 기본이나 근원이라고 여겨지는 데이터 타입-가령 숫자, 문자, 그리고 문자열을 표현하는 타입-이 실제로, 스위프트 표준 라이브러리에서는 구조체를 사용하여 정의하고 구현한, 이름 있는 타입입니다. 이름 있는 타입이기 때문에, [Extensions (익스텐션; 확장)]({% post_url 2016-01-19-Extensions %}) 과 [Extension Declaration](https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID378) 에서 설명한 대로, 익스텐션 선언을 사용하여, 프로그램의 필요에 적합하도록 작동 방식을 확장할 수 있습니다.

_복합 타입 (compound types)_ 은 이름이 없는 타입으로, 스위프트 언어 자체에서 정의된 것입니다. 두 가지의 복합 타입이 있습니다: 함수 타입과 튜플 타입입니다. 복합 타입은 이름 있는 타입과 다른 복합 타입을 가질 수도 있습니다. 예를 들어, 튜플 타입인 `(Int, (Int, Int))` 는 두 개의 원소를 가지고 있습니다: 첫 번째는 이름 있는 타입인 `Int` 이고, 두 번째는 또 다른 복합 타입인 `(Int, Int)` 입니다.

이름 있는 타입 또는 복합 타입 주위에 괄호를 둘 수 있습니다. 하지만, 타입 주위에 괄호를 추가하는 것은 아무런 효과가 없습니다. 예를 들어, `(Int)` 는 `Int` 와 '동치 (equivalent)' 입니다.

이 장에서는 스위프트 언어 자체에서 정의한 타입에 대해서 논의하며 스위프트의 타입 추론 작동 방식에 대해서 설명합니다.

> GRAMMAR OF A TYPE 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html)

### Type Annotation (타입 보조 설명)

_타입 보조 설명 (type annotation)_ 은 변수나 표현식의 타입을 명시적으로 지정합니다. 타입 보조 설명은, 다음 예제에서 보인 것처럼, '콜론 (`:`)' 으로 시작해서 타입으로 끝납니다:

```swift
let someTuple: (Double, Double) = (3.14159, 2.71828)
func someFunction(a : Int) { /* ... */ }
```

첫 번째 예제에서, `someTuple` 표현식은 `(Double, Double)` 이라는 튜플 타입을 가지도록 지정했습니다. 두 번째 예제에서, `someFunction` 함수의 매개 변수인 `a` 는 `Int` 타입을 가지도록 지정했습니다.

타입 보조 설명은 타입 앞에 선택 사항으로 '타입 특성 (type attributes)' 목록을 가질 수 있습니다.

> GRAMMAR OF A TYPE ANNOTATION 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID446)

### Type Identifier (타입 식별자)

_타입 식별자 (type identifier)_ 는 이름 있는 타입 및 복합 타입의 '이름 있는 타입 (named type)' 또는 '타입 별명 (type alias)' 을 참조합니다.

대부분의 시간 동안, 타입 식별자는 식별자와 이름이 같은 '이름 있는 타입' 을 직접 참조합니다. 예를 들어, `Int` 는 `Int` 라는 이름 있는 타입을 직접 참조하는 타입 식별자이며, `Dictionary <String, Int>` 라는 타입 식별자는 `Dictionary <String, Int>` 라는 이름 있는 타입을 직접 참조합니다.

타입 식별자가 이름이 같은 타입을 참조하지 않는 경우에는 두 가지가 있습니다. 첫 번째 경우는, 타입 식별자가 이름 있는 타입이나 복합 타입에 대한 '타입 별명' 을 참조하는 것입니다. 예를 들어 보면, 아래 예제의, '타입 보조 설명' 에서 사용한 `Point` 는 `(Int, Int)` 라는 튜플 타입을 참조합니다.

```swift
typealias Point = (Int, Int)
let origin: Point = (0, 0)
```

두 번째 경우는, 타입 식별자가 '점 구문 표현 (dot syntax; `.`)' 을 사용하여 다른 모듈에서 선언하거나 다른 타입 내에 중첩된 '이름 있는 타입' 을 참조하는 것입니다. 예를 들어, 다음 코드에 있는 타입 식별자는 `ExampleModule` 이라는 모듈에서 선언한 `MyType` 이라는 '이름 있는 타입' 을 참조합니다.

```swift
var someValue: ExampleModule.MyType
```

> GRAMMAR OF A TYPE IDENTIFIER 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID447)

### Tuple Type (튜플 타입)

_튜플 타입 (tuple type)_ 은 쉼표로 구분된 타입 목록을, 괄호로 감싼 것입니다.

튜플 타입을 함수의 반환 타입으로 사용하면 함수가 다중 값을 가지는 단일 튜플을 반환하도록 해줍니다. 튜플 타입의 원소에도 이름을 붙일 수 있으며 이 이름을 사용하여 개별 원소의 값을 참조할 수도 있습니다. 원소 이름은 식별자와 그 바로 뒤의 '콜론 (`:`)' 으로 구성됩니다. 이러한 두 개의 특성을 모두 증명해 보이는 예제는, [Functions with Multiple Return Values (반환 값이 여러 개인 함수)]({% post_url 2020-06-02-Functions %}#functions-with-multiple-return-values-반환-값이-여러-개인-함수) 를 참고하기 바랍니다.

튜플 타입의 원소가 이름을 가질 때, 해당 이름은 타입의 일부입니다.

```swift
var someTuple = (top: 10, bottom: 12)  // someTuple 의 타입은 (top: Int, bottom: Int) 입니다.
someTuple = (top: 4, bottom: 42) // OK: 이름이 일치합니다.
someTuple = (9, 99)              // OK: 이름이 추론됩니다.
someTuple = (left: 5, right: 5)  // Error: 이름이 일치하지 않습니다.
```

모든 튜플 타입은 둘 이상의 타입을 가지는데, `()` 라는, 빈 튜플 타입에 대한 '타입 별명 (type alias)' 인 `Void` 는 가질 수 없습니다.

> GRAMMAR OF A TUPLE TYPE 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID448)

### Function Type (함수 타입)

_함수 타입 (funtion type)_ 은 함수, 메소드, 또는 클로저의 타입을 나타내는 것으로 '화살표 (`->`)' 로 구분된 매개 변수 타입과 반환 타입으로 구성됩니다:

(`parameter type`) -> `return type`

_매개 변수 타입 (parameter type)_ 은 쉼표로-구분된 타입의 목록입니다. _반환 타입 (return type)_ 은 튜플 타입일 수 있기 때문에, 함수 타입은 다중 값을 반환하는 함수와 메소드를 지원합니다.

(`T` 가 어떤 타입도 되는) `() -> T` 라는 함수 타입의 매개 변수에 `autoclosure` 특성을 적용하면 호출 측에서 암시적으로 클로저를 생성할 수 있습니다. 이는 함수를 호출할 때 명시적인 클로저를 작성하지 않고도 표현식의 값-평가를 지연하는 구문상의 편의 방법을 제공하는 것입니다. 자동 클로저 함수 타입 매개 변수에 대한 예제는, [Autoclosures (자동 클로저)]({% post_url 2020-03-03-Closures %}#autoclosures-자동-클로저) 를 참고하기 바랍니다.

함수 타입은 _매개 변수 타입 (parameter type)_ 에 '가변 매개 변수 (variadic parameter)' 를 가질 수 있습니다. 구문 표현으로 보면, 가변 매개 변수는, `Int...` 에서와 같이, 기본 타입 이름과 그 바로 뒤의 세 점 (`...`) 으로 구성됩니다. 가변 매개 변수는 기본 타입 이름의 원소를 가지고 있는 배열인 것처럼 취급합니다. 예를 들어 보면, 가변 매개 변수 `Int...` 는 `[Int]` 인 것으로 취급합니다. 가변 매개 변수를 사용하는 예제에 대해서는, [Variadic Parameters (가변 매개 변수)]({% post_url 2020-06-02-Functions %}#variadic-parameters-가변-매개-변수) 를 참고하기 바랍니다.

'입-출력 매개 변수 (in-out parameter)' 를 지정하려면, 매개 변수 타입에 `inout` 키워드로 접두사를 붙입니다. 가변 매개 변수나 반환 타입을  `inout` 키워드로 표시할 수는 없습니다. 입-출력 매개 변수는 [In-Out Parameters (입-출력 매개 변수)]({% post_url 2020-06-02-Functions %}#in-out-parameters-입-출력-매개-변수) 에서 설명합니다.

함수 타입이 단 하나의 매개 변수를 가지는데 그 매개 변수의 타입이 튜플 타입인 경우라면, 함수 타입을 작성할 때 그 튜플 타입은 반드시 괄호로 묶어야 합니다. 예를 들어, `((Int, Int)) -> Void` 는 튜플 타입 `(Int, Int)` 라는 단일 매개 변수를 받아서 어떤 값도 반환하지 않는 함수의 타입입니다. 이와 대조해서, 괄호가 없는, `(Int, Int) -> Void` 는 두 개의 `Int` 매개 변수를 받아서 어떤 값도 반환하지 않는 함수의 타입입니다. 마찬가지로, `Void` 는 `()` 에 대한 '타입 별명 (type alias)' 이기 때문에, 함수 타입 `(Void) -> Void` 는-빈 튜플인 단일 인자를 받아 들이는 함수인-`(()) -> ()` 와 같습니다. 이러한 타입은-아무 인자를 받지 않는 함수인-`() -> ()` 와 같은 것이 아닙니다.

함수와 메소드에 있는 인자 이름은 연관된 함수 타입의 일부가 아닙니다.[^argument-name-in-function] 예를 들면 다음과 같습니다:

```swift
func someFunction(left: Int, right: Int) {}
func anotherFunction(left: Int, right: Int) {}
func functionWithDifferentLabels(top: Int, bottom: Int) {}

var f = someFunction // f 의 타입은 (Int, Int) -> Void 인 것으로, (left: Int, right: Int) -> Void 인 것이 아닙니다.
f = anotherFunction              // OK
f = functionWithDifferentLabels  // OK

func functionWithDifferentArgumentTypes(left: Int, right: String) {}
f = functionWithDifferentArgumentTypes     // Error

func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}
f = functionWithDifferentNumberOfArguments // Error
```

'인자 이름표 (argument labels)' 는 함수 타입의 일부가 아니기 때문에, 함수 타입을 작성할 때는 생략합니다.

```swift
var operation: (lhs: Int, rhs: Int) -> Int     // Error
var operation: (_ lhs: Int, _ rhs: Int) -> Int // OK
var operation: (Int, Int) -> Int               // OK
```

함수 타입이 하나 이상의 '화살표 (`->`)' 를 포함하는 경우, 함수 타입은 오른쪽에서 왼쪽으로 그룹을 짓습니다. 예를 들어, 함수 타입 `(Int) -> (Int) -> Int` 는 `(Int) -> ((Int) -> Int)` 라고 이해합니다-즉, `Int` 를 받아서 `Int` 를 받고 반환하는 다른 함수를 반환하는 함수라는 것입니다.

에러를 던지거나 다시 던질 수 있는 함수 타입은 반드시 `throws` 키워드로 표시해야 합니다. `throws` 키워드는 함수 타입의 일부이며, '던지지 않는 함수 (nonthrowing functions)' 은 '던지는 함수 (throwing functions)' 의 하위 타입입니다. 그 결과, '던지지 않는 함수' 를 던지는 함수와 같은 위치에 사용할 수 있습니다. '던지는 함수' 와 '다시 던지는 함수 (rethrowing functions)' 는 [Throwing Functions and Methods (던지는 함수 및 메소드)]({% post_url 2020-08-15-Declarations %}#throwing-functions-and-methods-던지는-함수-및-메소드) 및 [Rethrowing Functions and Methods (다시 던지는 함수 및 메소드)]({% post_url 2020-08-15-Declarations %}#rethrowing-functions-and-methods-다시-던지는-함수-및-메소드) 에서 설명합니다.

#### Restrictions for Nonescaping Closures (벗어나지 않는 클로저에 대한 제약 조건)

매개 변수가 '벗어나지 않는 함수' 이면 속성이나, 변수, 또는 `Any` 타입의 상수에 저장할 수 없는데, 이는 값이 벗어날 수 있기 때문입니다.

매개 변수가 '벗어나지 않는 함수' 이면 다른 '벗어나지 않는 함수' 매개 변수의 인자로 전달할 수 없습니다. 이러한 제약 조건은 스위프트가 실행 시간 대신에 컴파일 시간에 더 많은 메모리 접근 충돌 검사를 수행하도록 돕습니다. 예를 들면 다음과 같습니다:

```swift
let external: (() -> Void) -> Void = { _ in () }
func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {
  first { first {} }       // 에러 (Error)
  second { second {} }     // 에러 (Error)

  first { second {} }      // 에러 (Error)
  second { first {} }      // 에러 (Error)

  first { external {} }    // OK
  external { first {} }    // OK
}
```

위의 코드에서, `takesTwoFunctions(first:second:)` 의 두 매개 변수는 모두 함수입니다. 어느 매개 변수도 `@escaping` 으로 표시하지 않았으며, 그 결과 둘 다 '벗어나지 않는' 것들입니다.

위 예제에서 "에러 (Error)" 로 표시한 네 개의 함수 호출은 컴파일러 에러를 야기합니다. `first` 와 `second` 매개 변수는 '벗어나지 않는 함수' 이기 때문에, 다른 벗어나지 않는 함수 매개 변수의 인자로 전달할 수 없습니다. 이와는 대조적으로, "OK" 로 표시한 두 개의 함수 호출은 컴파일러 에러를 야기하지 않습니다. 이 함수 호출들은 `external` 이 `takesTwoFunctions(first:second:)` 의 매개 변수 중 하나가 아니기 때문에 제약 조건을 위반하지 않습니다.

이런 제약 조건을 피하고자 할 경우, 매개 변수 중 하나를 '벗어나는' 것으로 표시하거나, 아니면 `withoutActuallyEscaping(_:do:)` 함수를 사용하여 '벗어나지 않는 함수 매개 변수' 를 '벗어나는 함수' 로 임시적으로 변환하도록 합니다. 메모리 접근의 충돌을 피하는 것에 대한 정보는, [Memory Safety (메모리 안전성)]({% post_url 2020-04-07-Memory-Safety %}) 을 참고하기 바랍니다.

> GRAMMAR OF A FUNCTION TYPE 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID449)

### Array Type (배열 타입)

스위프트 언어는 스위프트 표준 라이브러리의 `Array<Element>` 타입에 대해서 다음과 같은 '수월한 구문 표현 (systatic sugar)' 을 제공합니다:

[`type`]

다르게 말해서, 다음의 두 선언은 '동치 (equivalent)' 입니다:

```swift
let someArray: Array<String> = ["Alex", "Brian", "Dave"]
let someArray: [String] = ["Alex", "Brian", "Dave"]
```

두 경우 모두, `someArray` 라는 상수를 문자열 배열로 선언합니다. 배열의 원소는 대괄호 안에 유효한 색인 값을 지정하는 첨자 연산을 통하여 접근할 수 있습니다: `someArray[0]` 은 색인이 '0' 인 원소인, `"Alex"` 를 참조합니다.

대괄호 쌍을 중첩하면 '다-차원 (multidimensional)' 배열을 생성할 수 있으며, 여기서 원소의 기본 타입 이름은 가장 안쪽의 대괄호 쌍에서 가지게 됩니다. 예를 들어, 세 쌍의 대괄호를 사용하면 삼-차원 정수 배열을 생성할 수 있습니다:

```swift
var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
```

다-차원 배열에 있는 원소에 접근할 때, 가장-왼쪽의 '첨자 연산 색인' 은 가장 바깥쪽 배열에 있는 해당 색인의 원소를 참조합니다. 오른쪽으로 그 다음의 첨자 연산 색인은 한 단계 중첩된 배열에 있는 해당 색인의 원소를 참조합니다. 이런 식으로 계속합니다. 이것이 의미하는 것은 위 예제에서, `array3D[0]` 는 `[[1, 2], [3, 4]]` 를 참조하고, `array3D[0][1]` 은 `[3, 4]` 를 참조하며, `array3D[0][1][1]` 은 값 '4' 를 참조한다는 것입니다.

스위프트 표준 라이브러리의 `Array` 타입에 대한 자세한 논의는, [Arrays (배열)]({% post_url 2016-06-06-Collection-Types %}#arrays-배열) 를 참고하기 바랍니다.

> GRAMMAR OF A ARRAY TYPE 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID450)

### Dictionary Type (딕셔너리 타입)

스위프트 언어는 스위프트 표준 라이브러리의 `Dictionary<Key, Value>` 타입에 대해서 다음과 같은 '수월한 구문 표현 (systatic sugar)' 을 제공합니다:

[`key type`: `value type`]

다르게 말해서, 다음의 두 선언은 '동치 (equivalent)' 입니다:

```swift
let someDictionary: [String: Int] = ["Alex": 31, "Paul": 39]
let someDictionary: Dictionary<String, Int> = ["Alex": 31, "Paul": 39]
```

두 경우 모두, `someDictionary` 라는 상수를 키는 문자열이고 값은 정수인 '딕셔너리' 라고 선언합니다.

딕셔너리의 값은 대괄호 안에 관련된 키를 지정하는 첨자 연산을 통하여 접근할 수 있습니다: `someDictionary["Alex"]` 는 `"Alex"` 라는 키와 결합된 값을 참조합니다. 첨자 연산은 딕셔너리의 값 타입에 대한 옵셔널 값을 반환합니다. 딕셔너리가 지정한 키를 가지고 있지 않으면, 첨자 연산이 `nil` 을 반환합니다.

딕셔너리의 키 타입은 스위프트 표준 라이브러리의 `Hashable` 프로토콜을 반드시 준수해야 합니다.

스위프트 표준 라이브러리의 `Dictionary` 타입에 대한 자세한 논의는, [Dictionaries (딕셔너리; 사전)]({% post_url 2016-06-06-Collection-Types %}#dictionaries-딕셔너리-사전) 을 참고하기 바랍니다.

> GRAMMAR OF A DICTIONARY TYPE 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID451)

### Optional Type

### Implicitly Unwrapped Optional Type

### Protocol Composition Type (프로토콜 합성 타입)

_프로토콜 합성 타입 (protocol composition type)_ 은 지정된 프로토콜 목록의 각 프로토콜을 준수하는 타입, 또는 주어진 클래스의 하위 클래스이면서 지정된 프로토콜 목록의 각 프로토콜을 준수하는 타입을 정의합니다. 프로토콜 합성 타입은 아마도 '타입 보조 설명 (type annotations)' 에 있고, '제네릭 매개 변수 구절' 에 있는, 그리고 '제네릭 `where` 절' 에 있는 타입을 지정할 때만 사용할 수도 있습니다.

'프로토콜 합성 타입' 은 다음의 양식을 가집니다:

  `Protocol 1` & `Protocol 2`

프로토콜 합성 타입은 해당 타입이 준수하고 싶은 각각의 프로토콜을 상속한 새로운, 이름 있는 프로토콜을 명시적으로 정의하지 않고도 다중 프로토콜의 필수 조건을 준수하는 타입의 값을 지정할 수 있게 해줍니다. 예를 들어, `ProtocolA`, `ProtocolB`, 및 `ProtocolC` 를 상속하는 새로운 프로토콜을 선언하는 대신 `ProtocolA & ProtocolB & ProtocolC` 라는 프로토콜 합성 타입을 사용할 수 있습니다. 마찬가지로, `SuperClass` 의 하위 클래스이면서 `ProtocolA` 를 준수하는 새로운 프로토콜을 선언하는 대신 `SuperClass & ProtocolA` 를 사용할 수 있습니다.

프로토콜 합성 목록에 있는 각각의 항목은 다음 중 하나입니다; 목록은 최대 하나의 클래스를 가질 수 있습니다:

* 클래스의 이름
* 프로토콜의 이름
* 실제 타입이 프로토콜 합성 타입, 프로토콜, 또는 클래스인 '타입 별명 (type alias)'

프로토콜 합성 타입이 타입 별명을 가지고 있을 때, 똑같은 프로토콜을 정의에 한 번 이상 나타내는 것도 가능합니다-중복된 것은 무시합니다. 예를 들어, 아래 코드에 있는 `PQR` 이라는 정의는 `P & Q & R` 과 '동치 (equivalent)' 입니다.

```swift
typealias PQ = P & Q
typealias PQR = PQ & Q & R
```

> GRAMMAR OF A PROTOCOL COMPOSITION TYPE 부분 생략 - [링크](https://docs.swift.org/swift-book/ReferenceManual/Types.html#ID454)

### Opaque Type

### Metatype Type

### Self Type (자기 자신의 타입)

`Self` (자기 자신의) 타입은 특정한 하나의 타입이 아니라, '현재 타입' 을 편리하게 참조하도록 (refer to) 만든 것으로, 반복해서 입력할 필요없이 쓸 수도 있고 타입의 이름을 몰라도 쓸 수 있도록 만든 것입니다.

프로토콜 (protocol) 선언이나 프로토콜 멤버 선언에 있는 `Self` 타입은 그 프로토콜을 준수하는 최종 타입을 가리킵니다.

구조체 (structure), 클래스(class), 그리고 열거 타입(enumeration) 선언에 있는 `Self` 타입은 그 선언이 만들어내는 타입을 가리킵니다. 타입의 멤버 선언 내에 있는 `Self` 타입은 해당 타입을 나타냅니다. class 선언의 멤버 내에서는 아래와 같은 경우에만 `Self` 를 쓸 수 있습니다:

* method 의 반환 타입으로 사용
* 읽기 전용 subscript 의 반환 타입으로 사용
* 읽기 전용 computed property 의 타입으로 사용
* method 의 내부

예를 들면, 아래의 코드는 반환 타입이 `Self` 인 멤버 함수 `f` 를 나타낸 것입니다.

```swift
class Superclass {
  func f() -> Self { return self }
}

let x = Superclass()
print(type(of: x.f()))

// Prints "Superclass"

class Subclass: Superclass { }

let y = Subclass()
print(type(of: y.f()))

// Prints "Subclass"

let z: Superclass = Subclass()
print(type(of: z.f()))

// Prints "Subclass"
```

위 예제의 마지막 부분은 `Self` 가 `z` 값의 실행 시간 타입인 `Subclass` 이며, 변수 자체의 컴파일 시간 타입인 `Superclass` 가 아님을 보여줍니다.

중첩 타입 (nested type) 선언 내에 있는 `Self` 는 가장 안쪽의 타입 (innermost) 선언이 만들어내는 타입을 가리킵니다.

`Self` 타입은 은 스위프트 표준 라이브러리에 있는 `type(of:)` 함수와 같은 타입을 가리킵니다. 현재 타입의 멤버에 접근하기 위해 `Self.someStaticMember` 라고 쓰는 것은 `type(of: self).someStaticMember` 라고 쓰는 것과 같습니다.

### 생각하기

위 내용의 마지막 부분에서 `Self` 타입과 `type(of:)` 함수의 결과가 같다는 것을 알 수 있습니다. 이대로라면 굳이 `Self` 가 있을 필요는 없어 보입니다.

하지만 `type(of:)` 함수는 특정 값의 동적 타입을 반환하는 함수로 컴파일 시간에 호출되는 것이 아닙니다.[^type-of] 한편 `f()` 함수의 정의에서는 반환 값을 지정해 줄 필요가 있는데, 반환 값이 동적 시간에 결정되므로 `type(of:)` 함수를 호출할 수 없고, 그렇다고 컴파일 시간에 특정 타입으로 지정할 수도 없습니다.

이와 같이 컴파일 시간에 타입을 지정해야 하지만 컴파일 시간에 알 수는 없는 경우가 있습니다. 이 때, Meta 타입으로 `Self` 를 지정할 수 있습니다. 즉, `Self` 는 Generic Programming 에서 현재 타입을 매개변수처럼 전달해 줄 필요가 있을 때 사용할 수 있습니다.

### Type Inheritance Clause

### Type Inference

### 참고 자료

[^Types]: 전체 원문은 [Types](https://docs.swift.org/swift-book/ReferenceManual/Types.html)에서 확인할 수 있습니다.

[^type-of]: 더 자세한 내용은 Apple 개발 문서의 [type(of:)](https://developer.apple.com/documentation/swift/2885064-type) 항목을 참고하기 바랍니다.

[^argument-name-in-function]: 이런 작동 방식은 '튜플 타입 (tuple type)' 과 다른 것입니다.
