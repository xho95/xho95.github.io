---
layout: post
comments: true
title:  "Methods (메소드)"
date:   2020-05-03 10:00:00 +0900
categories: Swift Language Grammar Method
---

{% include header_swift_book.md %}

## Methods (메소드)

_메소드 (methods)_ 는 한 특별한 타입과 결합된 함수입니다.[^method-and-function] 클래스와, 구조체, 및 열거체는 모두 인스턴스 메소드를 정의할 수 있어서, 주어진 타입의 인스턴스와 작업할 임무[^tasks] 및 기능을 감춥니다. 클래스와, 구조체, 및 열거체는 타입 메소드도 정의할 수 있는데, 이들은 타입 그 자체와 결합합니다. 타입 메소드는 **오브젝티브-C** 의 클래스 메소드[^class-methods] 와 비슷합니다.

스위프트에선 구조체와 열거체도 메소드를 정의할 수 있다는 사실은 **C** 및 **오브젝티브-C** 와 주요한 차이점입니다.[^c-structure] **오브젝티브-C** 에선, 클래스만이 메소드를 정의할 수 있는 유일한 타입입니다. 스위프트에선, 클래스나, 구조체, 또는 열거체로 정의할지 선택할 수 있으면서, 여전히 생성한 타입에 메소드를 정의하는 유연함을 가지게 됩니다.

### Instance Methods (인스턴스 메소드)

_인스턴스 메소드 (instance methods)_ 는 한 특별한 클래스나, 구조체, 또는 열거체의 인스턴스에 속하는 함수입니다. 인스턴스 속성에 접근하고 수정할 방법을 제공하거나, 인스턴스의 목적과 관련된 기능을 제공하는 걸로, 그 인스턴스의 기능을 지원합니다. [Functions (함수)]({% link docs/swift-books/swift-programming-language/functions.md %}) 에서 설명하듯, 인스턴스 메소드 구문은 함수와 정확하게 똑같습니다.

인스턴스 메소드는 자신이 속할 타입을 열고 닫는 중괄호 안에 작성합니다. 인스턴스 메소드는 그 타입의 모든 다른 인스턴스 메소드와 속성에 암시적으로 접근합니다.[^implicit-access] 인스턴스 메소드는 자신이 속한 타입의 인스턴스에서만 호출할 수 있습니다. 이미 있는 인스턴스 없이 떼어 놓은 채로 호출할 수 없습니다.

단순한 `Counter` 클래스를 정의하여, 행동이 일어난 횟수를 세는데 쓸 수 있는, 예제는 이렇습니다:

```swift
class Counter {
  var count = 0
  func increment() {
    count += 1
  }
  func increment(by amount: Int) {
    count += amount
  }
  func reset() {
    count = 0
  }
}
```

`Counter` 클래스는 세 개의 인스턴스 메소드를 정의합니다:

* `increment()` 는 횟수를 `1` 만큼 증가시킵니다.
* `increment(by : Int)` 는 횟수를 지정한 정수만큼 증가시킵니다.
* `reset()` 은 횟수를 `0` 으로 재설정합니다.

`Counter` 클래스는, `count` 라는, 변수 속성도 선언하여, 현재 횟수를 계속 추적합니다.

인스턴스 메소드는 속성과 똑같이 점 구문으로 호출합니다:

```swift
let counter = Counter()
// 초기 횟수는 0 임
counter.increment()
// 횟수는 이제 1 임
counter.increment(by: 5)
// 횟수는 이제 6 임
counter.reset()
// 횟수는 이제 0 임
```

[Function Argument Labels and Parameter Names (함수의 인자 이름표와 매개 변수 이름)]({% link docs/swift-books/swift-programming-language/functions.md %}#function-argument-labels-and-parameter-names-함수의-인자-이름표와-매개-변수-이름) 에서 설명한 것처럼, 함수 매개 변수엔 (함수 본문 안에서 사용할) 이름과 (함수 호출 때 사용할) 인자 이름표가 둘 다 있을 수 있습니다. 메소드 매개 변수도 이와 똑같은데, 메소드도 그냥 타입에 결합된 함수이기 때문입니다.

#### The self Property (self 속성)

타입의 모든 인스턴스엔 암시적인 `self` 라는 속성이 있는데, 이는 인스턴스 그 자체와 정확하게 같다고 볼 수 있습니다.[^implicit-property] `self` 속성으로 자기 자신의 인스턴스 메소드 안에서 현재 인스턴스를 참조합니다.

위 예제의 `increment()` 메소드는를 이렇게 작성할 수도 있습니다:

```swift
func increment() {
  self.count += 1
}
```

사실상, 코드에서 `self` 를 쓸 필요는 거의 없습니다. `self` 를 명시 안하면, 이미 알고 있는 속성이나 메소드 이름을 메소드에서 쓸 때마다 현재 인스턴스의 속성이나 메소드를 참조하는 거라고 스위프트가 가정합니다. 이런 가정은 `Counter` 의 세 인스턴스 메소드 안에서 (`self.count` 보단) `count` 라고 씀으로써 실제로 보여줬습니다.

이 규칙에 대한 주요 예외는 인스턴스 메소드의 매개 변수 이름이 그 인스턴스의 속성 이름과 똑같을 때 일어납니다. 이런 상황에선, 매개 변수 이름이 우선하며, 속성의 참조는 소속을 더 밝힐 필요가 있습니다.[^a-qualified-way] `self` 속성을 써서 매개 변수 이름과 속성 이름을 구별합니다.

여기선, `self` 로 `x` 라는 메소드 매개 변수와 역시 `x` 인 인스턴스 속성이 헷갈리지 않게 합니다:

```swift
struct Point {
  var x = 0.0, y = 0.0
  func isToTheRightOf(x: Double) -> Bool {
    return self.x > x
  }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOf(x: 1.0) {
  print("This point is to the right of the line where x == 1.0")
}
// "This point is to the right of the line where x == 1.0" 을 인쇄함
```

`self` 접두사가 없으면, `x`  둘 다 메소드 매개 변수인 `x` 를 참조한 거라고 가정했을 겁니다.

#### Modifying Value Types from Within Instance Methods (인스턴스 메소드 안에서 값 타입 수정하기)

구조체와 열거체는 _값 타입 (value types)_ 입니다. 기본적으로, 값 타입의 속성은 자신의 인스턴스 메소드 안에서 수정할 수 없습니다.

하지만, 한 특별한 메소드 안에서 구조체나 열거체의 속성을 수정하는게 필요하다면, 그 메소드의 _변경 (mutating)_ 동작을 직접 선택할 수도 있습니다. 그러면 메소드가 자신의 속성을 메소드 안에서 변경 (즉, 바꿀) 수 있으며, 이렇게 바꾼건 메소드가 끝날 때 원본 구조체로 되돌려 써집니다. 메소드는 완전히 새로운 인스턴스를 자신의 암시적 `self` 속성에 할당할 수도 있는데, 이 새로운 인스턴스는 메소드가 끝날 때 이미 있던 걸 교체하게 됩니다.

이런 동작을 직접 선택하려면 그 메소드의 `func` 키워드 앞에 `mutating` 키워드를 두면 됩니다:

```swift
struct Point {
  var x = 0.0, y = 0.0
  mutating func moveBy(x deltaX: Double, deltaY: Double) {
    x += deltaX
    y += deltaY
  }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y)")
// "The point is now at (3.0, 4.0)" 를 인쇄함
```

위 `Point` 구조체는 `moveBy(x:y:)` 변경 메소드를 정의하여, `Point` 인스턴스를 특정한 양만큼 이동합니다. 새로운 점을 반환하는 대신, 이 메소드는 호출된 점을 실제로 수정합니다. `mutating` 키워드를 자신의 정의에 추가하여 속성을 수정할 수 있게 합니다.

[Stored Properties of Constant Structure Instances (상수 구조체 인스턴스의 저장 속성)]({% link docs/swift-books/swift-programming-language/properties.md %}#stored-properties-of-constant-structure-instances-상수-구조체-인스턴스의-저장-속성) 에서 설명한 것처럼, 구조체 타입의 상수는, 그게 변수 속성이더라도, 자신의 속성을 바꿀 수 없기 때문에, 변경 메소드를 호출할 수 없다는 걸 알아두기 바랍니다:

```swift
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveBy(x: 2.0, y: 3.0)
// 이는 에러를 보고할 것임
```

#### Assigning to self Within a Mutating Method (변경 메소드 안에서 self 에 할당하기)

변경 메소드는 완전히 새로운 인스턴스를 암시적 `self` 속성에 할당할 수 있습니다. 위에서 본 `Point` 예제를 다음 방식으로 대신 작성할 수 있을 겁니다:

```swift
struct Point {
  var x = 0.0 y = 0.0
  mutating func moveBy(x deltaX: Double, y deltaY: Double) {
    self = Point(x: x + deltaX, y: y + deltaY)
  }
}
```

이 버전의 `moveBy(x:y:)` 변경 메소드는 `x` 와 `y` 값을 목표 장소로 설정한 새로운 구조체를 생성합니다. 이 대체 버전의 메소드를 호출한 결과는 앞선 버전을 호출한 것과 정확하게 똑같을 겁니다.

열거체의 변경 메소드는 암시적 `self` 매개 변수[^implicit-self-paramter] 를 똑같은 열거체 안의 다른 case 로 설정할 수 있습니다:

```swift
enum TriStateSwitch {
  case off, low, high
  mutating func next() {
    switch self {
    case .off:
      self = .low
    case .low:
      self = .high
    case .high:
      self = .off
    }
  }
}
var ovenLight = TriStateSwitch.low
ovenLight.next()
// ovenLight 는 이제 .high 임
ovenLight.next()
// ovenLight 는 이제 .off 임
```

이 예제는 열거체로 3-상 스위치[^three-state-switch] 를 정의합니다. `next()` 메소드를 호출할 때마다 스위치가 세 가지의 서로 다른 전력 상태인 (`off` 와, `low`, 및 `high`) 를 순환합니다.

### Type Methods (타입 메소드)

인스턴스 메소드는, 위에서 설명하듯, 한 특별한 타입의 인스턴스에 대해서 호출하는 메소드입니다. 메소드를 타입 그 자체에 대해서 호출되도록 정의할 수도 있습니다. 이런 종류의 메소드를 _타입 메소드 (type methods)_ 라고 합니다. 타입 메소드라고 지시하려면 메소드의 `func` 키워드 앞에 `static` 키워드를 쓰면 됩니다. 클래스면 그 대신 `class` 키워드를 써서, 하위 클래스가 그 메소드의 상위 클래스 구현을 재정의하게 할 수 있습니다.

> **오브젝티브-C** 에선, 타입-수준 메소드를 **오브젝티브-C** 클래스에서만 정의할 수 있습니다. 스위프트에선, 타입-수준 메소드를 클래스와, 구조체, 및 열거체 모두에서 정의할 수 있습니다. 각 타입 메소드의 시야 범위는 자신이 지원하는 타입입니다.

타입 메소드는 점 구문으로 호출하며, 이는 인스턴스 메소드와 같습니다. 하지만, 타입 메소드는 타입에 대해서 호출하는 것이지, 그 타입의 인스턴스에서가 아닙니다. `SomeClass` 라는 클래스에 대한 타입 메소드의 호출은 이렇습니다:

```swift
class SomeClass {
  class func someTypeMethod() {
    // 타입 메소드 구현은 여기에 둠
  }
}
SomeClass.someTypeMethod()
```

타입 메소드의 본문에서, 암시적 `self` 속성이 참조하는 건, 그 타입의 인스턴스라기 보단, 타입 그 자체입니다. 이것의 의미는 `self` 를 쓰면 타입 속성과 타입 메소드 매개 변수가 헷갈리지 않을 수 있다는 것으로, 인스턴스 속성과 인스턴스 메소드 매개 변수에서 그런 것과 같습니다.

좀 더 일반적으로 말해서, 타입 메소드의 본문에서 소속이 밝혀지지 않은[^unqualified] 어떤 메소드와 속성 이름을 쓰던 다른 타입-수준의 메소드와 속성을 참조할 거라는 겁니다. 타입 메소드는 다른 메소드의 이름으로 또 다른 타입 메소드를 호출할 수 있는데, 접두사에 타입 이름이 없어도 됩니다. 이와 비슷하게, 구조체와 열거체의 타입 메소드는 타입 이름 접두사 없이 타입 속성의 이름으로 타입 속성에 접근할 수 있습니다.

아래 예제는 `LevelTracker` 라는 구조체를 정의하여, 플레이어의 게임 레벨이나 스테이지 진행 상황을 추적합니다. 단일-플레이 게임이지만, 한 기기에 여러 플레이어의 정보를 저장할 수 있습니다.

게임 플레이가 최초일 땐 (레벨 1만 빼놓고) 모든 게임 레벨을 잠급니다. 플레이어가 레벨을 종료할 때마다, 기기에서 모든 참가자를 위해 그 레벨을 풉니다. `LevelTracker` 구조체는 타입 속성 및 메소드로 어느 게임 레벨이 풀렸는지를 추적합니다. 이는 개별 플레이어의 현 레벨도 추적합니다.

```swift
struct LevelTracker {
  static var highestUnlockedLevel = 1
  var currentLevel = 1

  static func unlock(_ level: Int) {
    if level > highestUnlockedLevel { highestUnlockedLevel = level }
  }

  static func isUnlocked(_ level: Int) -> Bool {
    return level <= highestUnlockedLevel
  }

  @discardableResult
  mutating func advance(to level: Int) -> Bool {
    if LevelTracker.isUnlocked(level) {
      currentLevel = level
      return true
    } else {
      return false
    }
  }
}
```

`LevelTracker` 구조체는 어떤 플레이어가 풀은 가장 높은 레벨을 추적합니다. 이 값은 `highestUnlockedLevel` 이라는 타입 속성에 저장됩니다.

`LevelTracker` 는 `highestUnlockedLevel` 속성과 작업할 타입 함수도 두 개 정의합니다. 첫 번째는 `unlock(_:)` 이라는 타입 함수로, 새 레벨을 풀 때마다 `highestUnlockedLevel` 값을 업데이트합니다. 두 번째는 `isUnlocked(_:)` 라는 편의(를 위한) 타입 함수인데, 한 특별한 레벨이 이미 풀린거면 `true` 를 반환합니다. (이 타입 메소드들은 `LevelTracker.highestUnlockedLevel` 로 쓰지 않고도 `highestUnlockedLevel` 타입 속성에 접근할 수 있다는 걸 알아두기 바랍니다.)

자신의 타입 속성과 타입 메소드에 더하여, `LevelTracker` 는 개별 플레이어의 게임 진행 상황도 추적합니다. 이는 `currentLevel` 이라는 인스턴스 속성으로 플레이어가 현재 플레이 중인 레벨을 추적합니다.

`currentLevel` 속성의 관리를 돕기 위해, `LevelTracker` 는 `advance(to:)` 라는 인스턴스 메소드를 정의합니다. `currentLevel` 을 업데이트하기 전에, 이 메소드가 새로 요청한 레벨을 이미 풀었는지 검사합니다. `advance(to:)` 메소드는 불리언 값을 반환하여 `currentLevel` 을 설정하는게 실제로 가능한지 지시합니다. `advance(to:)` 메소드를 호출한 코드가 반환 값을 무시하는게 반드시 실수는 아니기 때문에, 이 함수에 `@discardableResult` 특성을 표시합니다. 이 특성에 대한 더 많은 것은, [Attributes (특성)]({% link docs/swift-books/swift-programming-language/attributes.md %}) 을 보기 바랍니다.

`LevelTracker` 구조체를, 아래에 보듯, `Player` 클래스와 사용하여, 개별 플레이어의 진행 상황을 추적하고 업데이트합니다:

```swift
class Player {
  var tracker = LevelTracker()
  let playerName: String
  func complete(level: Int) {
    LevelTracker.unlock(level + 1)
    tracker.advance(to: level + 1)
  }
  init(name: String) {
    playerName = name
  }
}
```

`Player` 클래스는 새로운 `LevelTracker` 인스턴스를 생성하여 플레이어의 진행 상황을 추적합니다. `complete(level:)` 이라는 메소드도 제공하는데, 이는 플레이어가 한 특별한 레벨을 완료할 때마다 호출됩니다. 이 메소드는 모든 플레이어를 위해 그 다음 레벨의 잠금을 풀며 플레이어의 진행 상황을 업데이트하여 그 다음 레벨로 이동시킵니다. (`advance(to:)` 의 불리언 반환 값은 무시하는데, 이전 줄의 `LevelTracker.unlock(_:)` 호출로 레벨이 풀렸다는 걸 알고 있기 때문입니다.)

`Player` 클래스의 인스턴스로 새로운 플레이어를 생성하고, 플레이어가 레벨 1 을 완료할 땐 무슨 일이 발생하는 지를 볼 수 있습니다:

```swift
var player = Player(name: "Argyrious")
player.complete(level: 1)
print("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
// "highest unlocked level is now 2" 를 인쇄함
```

두 번째 플레이어를 생성해서, 게임 안의 어떤 플레이어도 풀지 못한 레벨로 이동하려 하면, 플레이어의 현 레벨을 설정하려는 시도가 실패하게 됩니다:

```swift
player = Player(name: "Beto")
if player.tracker.advance(to: 6) {
  print("player is now on level 6")
} else {
  print("level 6 has not yet been unlocked")
}
// "level 6 has not yet been unlocked" 를 인쇄함
```

### 다음 장

[Subscripts (첨자) >]({% link docs/swift-books/swift-programming-language/subscripts.md %})

### 참고 자료

{% include footer_swift_book.md %} 이 장의 원문은 [Methods](https://docs.swift.org/swift-book/LanguageGuide/Methods.html) 에서 볼 수 있습니다.

[^method-and-function]: '한 특별한 타입과 결합한 함수' 를 부르는 호칭은 프로그래밍 언어마다 조금씩 다르며, 스위프트에서 메소드라고 하는 걸 다른 언어에서는 '멤버 함수 (member function)' 나 '프로시져 (procedure)' 라고 하기도 합니다.

[^c-structure]: C 언어의 '구조체 (structure)' 는 '합성 (composite) 자료 타입' 이라 '메소드' 를 직접 정의할 수는 없고 '함수 포인터 (function pointers)' 의 형태로 정의할 수 있다고 합니다. 보다 자세한 정보는 위키피디아의 [struct (C programming language)](https://en.wikipedia.org/wiki/Struct_(C_programming_language)) 항목과 스택오버플로우 사이트의 [Define functions in structs](https://stackoverflow.com/questions/9871119/define-functions-in-structs) 항목을 보도록 합니다.

[^unqualified]: 소속이 밝혀지지 않은 (unqualified) 어떤 메소드와 속성 이름이란 접두사가 없어서 그 메소드와 속성의 소속을 알 수 없다는 의미입니다. 이 경우, 스위프트는 자기 나름대로 이것의 소속을 밝히려고 하는데, 자기 자신이 타입 메소드이기 때문에 다른 타입-수준의 메소드와 속성을 참조하게 된다는 겁니다.

[^static-type-property]: '타입 함수' 에는 `mutating` 키워드를 붙이지 않는 것을 알 수 있습니다. 값 타입을 복사할 때 타입 속성은 복사되지 않기 때문일 수 있습니다.

[^implicit-access]: 암시적으로 접근한다는 건 다른 인스턴스 메소드와 속성에 접근할 때 `self.` 를 붙이지 않아도 된다는 의미입니다.

[^implicit-property]: '암시적인 속성 (implicit property)' 이란 사용자가 따로 정의하지 않아도 자동으로 가지게 되는 속성입니다.

[^a-qualified-way]: 소속을 더 밝혀야 한다 (a more qualified way) 는 건 속성 앞에 `self.` 등을 붙여야 한다는 의미입니다.

[^implicit-self-paramter]: 스위프트에는 열거체에도 `self` 가 있습니다.

[^three-state-switch]: 3-상 스위치는 상태가 3 가지인 스위치를 말합니다. 