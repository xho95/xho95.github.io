---
layout: post
comments: true
title:  "Swift: API Design Guidelines (API 설계 지침)"
date:   2020-10-08 10:00:00 +0900
categories: Swift Language Grammar Revision History
---

## API Design Guidelines (API 설계 지침)

### Table of Contents (목차)

* [Fundamentals (기반)](#fundamentals-기반)
* [Naming (이름짓기)](#naming-이름짓기)
  * [Promote Clear Usage (명확한 사용법 추구하기)](#promote-clear-usage-명확한-사용법-추구하기)
  * [Strive for Fluent Usage (자연스러운 사용법이 되도록 노력하기)](#strive-for-fluent-usage-자연스러운-사용법이-되도록-노력하기)
  * [Use Terminology Well (용어를 잘 사용하기)](#use-terminology-well-용어를-잘-사용하기)
* [Conventions (협약)](#conventions-협약)
  * [General Conventions (일반적인 협약)](#general-conventions-일반적인-협약)
  * [Parameters (매개 변수)](#parameters-매개-변수)
  * [Argument Labels (인자 이름표)](#argument-labels-인자-이름표)
* [Special Instructions (특수한 지시 사항들)](#special-instructions-특수한-지시-사항들)

### Fundamentals (기반)

* **사용하는 순간에 분명한 것** 이 가장 중요한 목표입니다. 메소드와 속성 같은 '개체 (entities)' 들은 한 번 선언해서 계속 반복 _사용 (used)_ 합니다. 명확하고 간결하게 사용하도록 API 를 설계합니다. 설계가 잘 됐는지 평가할 때, 선언만 보는 것은 충분치 않습니다; 항상 실제 사용 사례를 검토해야 상황에 따라 명확한지 확인할 수 있습니다.

* **분명한 것이 간결한 것보다 더 중요합니다.** 스위프트 코드를 더 짧게 만들 수 있더라도, 최소한의 문자로 가장 작은 코드를 만드는 것이 _목표인 것은 아닙니다 (non-goal)_. 스위프트 코드에서, 발생하는, 간결함이란, '강한 타입 시스템 (strong type system)' 으로 인한 '부수적인 효과' 이며 '획일적인 코드 (boilerplate)' 를 자연스럽게 줄이는 특징을 가집니다.

* **문서화 주석 (documentation comment)[^ducumentation-comment] 을** 모든 선언마다 작성합니다. 문서화를 작성하면서 가지게 된 통찰력은 설계에 큰 영향을 줄 수 있으므로, 미루지 않도록 합니다.

  API 의 기능을 간단한 용어로 설명하는 것이 어렵다면, **잘못된 API 를 설계하고 있는 것일 수 있습니다.**

  - **스위프트의 '자체 마크 다운 ([dialect of Markdown](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/))' 을 사용합니다.**

  - **요약 (summary) 으로 시작하여** 선언 중인 '개체 (entity)' 를 설명합니다. 때때로, 선언과 요약으로 API 를 완전히 이해할 수도 있습니다.

    ```swift
    /// Returns a "view" of `self` containing the same elements in
    /// reverse order.
    /// 같은 원소를 순서를 거꾸로 하여 담고 있는 `self` 의 "view" 를 반환함.
    func reversed() -> ReverseCollection
    ```

    * **요약에 집중합니다**; 가장 중요한 부분입니다. 많은 훌륭한 '문서화 주석' 은 사실 뛰어난 요약 만으로 구성됩니다.

    * **단일 문장 구절을** 가능한 사용하며, 마침표로 끝맺도록 합니다. 완전한 문장은 사용하지 않습니다.[^fragment]

    * **함수 또는 메소드는 무엇을 _하는 (does)_ 지 무엇을 _반환하는 (returns)_ 지 설명하고**, '없는 효과 (null effects)' 와 `Void` 반환은 생략합니다:

      ```swift
      /// Inserts `newHead` at the beginning of `self`.
      /// `self` 의 맨 처음 위치에 `newHead` 를 집어 넣음.
      mutating func prepend(_ newHead: Int)

      /// Returns a `List` containing `head` followed by the elements
      /// of `self`.
      /// `head` 및 그 뒤에 `self` 의 원소들이 있는 것을 담은 `List` 를 반환함.
      func prepending(_ head: Element) -> List

      /// Removes and returns the first element of `self` if non-empty;
      /// returns `nil` otherwise.
      /// 비어 있지 않으면 `self` 의 첫 번째 원소를 제거하면서 반환함;
      /// 그 외 경우면 `nil` 을 반환함.
      mutating func popFirst() -> Element?
      ```

      참고: 드물게 위의 `popFirst` 같이, '요약' 이 세미콜론으로 구분된 여러 개의 문장으로 형성되기도 합니다.

    * **첨자 연산이 무엇에 _접근하는 (accesses)_ 지 설명합니다.**:

      ```swift
      /// Accesses the `index`th element.
      /// `index` 번째 원소에 접근함.
      subscript(index: Int) -> Element { get set }
      ```

    * **초기자가 무엇을 _생성하는 (creates)_ 지 설명합니다.**:

      ```swift
      /// Creates an instance containing `n` repetitions of `x`.
      /// `x` 를 `n` 번 반복한 것을 가지고 있는 인스턴스를 생성함.
      init(count n: Int, repeatedElement x: Element)
      ```

    * 다른 모든 선언은, **선언한 '개체' 가 무엇 _인지 (is)_ 를 설명합니다.**

      ```swift
      /// A collection that supports equally efficient insertion/removal
      /// at any position.
      /// 어떤 위치에서도 똑같은 효율의 삽입/제거를 지원하는 컬렉션.
      struct List {

      /// The element at the beginning of `self`, or `nil` if self is
      /// empty.
      /// `self` 의 맨 처음 위치에 있는 원소, 또는 `self` 가 빈 것이면 `nil`.
      var first: Element?
      ...
      ```

  - **선택 사항으로, 계속해서** 하나 이상의 문단과 '목록 항목 (bullet items)' 을 붙일 수 있습니다. 문단은 '완전한 문장 (complete sentences)' 을 사용하며 문단끼리는 빈 줄로 구분합니다.

    ```swift
    /// Writes the textual representation of each    ← Summary
    /// element of `items` to the standard output.
    ///                                              ← Blank line
    /// The textual representation for each item `x` ← Additional discussion
    /// is generated by the expression `String(x)`.
    ///
    /// - Parameter separator: text to be printed    ⎫
    ///   between items.                             ⎟
    /// - Parameter terminator: text to be printed   ⎬ Parameters section
    ///   at the end.                                ⎟
    ///                                              ⎭
    /// - Note: To print without a trailing          ⎫
    ///   newline, pass `terminator: ""`             ⎟
    ///                                              ⎬ Symbol commands
    /// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
    ///   `CustomStringConvertible`, `debugPrint`.   ⎭

    /// `items` 의 각 원소에 대한 문장화된 표현을            ← 요약
    /// 표준 출력 장치에 작성함.
    ///                                              ← 빈 줄
    /// 각 항목 `x` 에 대한 문장화된 표현은                 ← 추가적인 설명
    /// `String(x)` 라는 표현식으로 생성합니다.
    ///
    /// - 매개 변수 구분자: 항목 사이 사이에 출력되는 문장       ⎫
    /// - 매개 변수 종결자: 맨 끝에 출력되는 문장              ⎬ 매개 변수 부분
    ///                                               ⎭
    /// - 노트: 끝에 '새 줄 문자 (newline)' 없이 출력하려면   ⎫
    ///   `terminator: ""` 를 전달할 것                 ⎟
    ///                                               ⎬ 기호 명령
    /// - 같이보기: `CustomDebugStringConvertible`,     ⎟
    ///   `CustomStringConvertible`, `debugPrint`.    ⎭
    public func print(
      _ items: Any..., separator: String = " ", terminator: String = "\n")
    ```

    * **인증받은 '기호화된 문서화 마크업 ([symbol documentation markup](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW1))' 원소를 사용하여**, 적절할 때마다, 요약 이상의 정보를 추가합니다.

    * **인증받은 목록 항목을 알아보고 '기호화된 명령 구문 표현 ([symbol command syntax](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW13))'[^symbol-comman-syntax] 과 함께 사용하도록 합니다.** '엑스코드 (Xcode)' 같은 대중적인 개발 도구는 다음 키워드로 시작하는 '목록 항목 (bullet items)' 을 특수하게 취급합니다.


      ---|---|---|---|---|---|---|---|---
        | [Attention](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html)	| | [Author](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Author.html) | |  [Authors](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Authors.html) | |  [Bug](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Bug.html) |
        | [Complexity](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Complexity.html) | | [Copyright](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Copyright.html) |	| [Date](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Date.html) | | [Experiment](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Experiment.html) |
        | [Important](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Important.html)	| | [Invariant](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Invariant.html) | | [Note](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Note.html) | | [Parameter](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameter.html) |
        | [Parameters](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameters.html) | | [Postcondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Postcondition.html) | | [Precondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Precondition.html) | | [Remark](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Remark.html) |
        | [Requires](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html) | | [Returns](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Returns.html) | | [SeeAlso](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SeeAlso.html) | | [Since](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Since.html) |
        | [Throws](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Throws.html) | |  [ToDo](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Todo.html) | | [Version](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Version.html) | |  [Warning](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Warning.html) |


### Naming (이름짓기)

#### Promote Clear Usage (명확한 사용법 추구하기)

* **모호함이 없도록 필요한 모든 단어를 포함시킨** 이름으로 된 코드를 사람이 읽도록 합니다.

  예를 들어, '컬렉션 (collection)' 에서 주어진 위치의 원소를 제거하는 메소드를 생각해 봅시다.

  ```swift
  // 좋은 예제
  extension List {
    public mutating func remove(at position: Index) -> Element
  }
  employees.remove(at: x)
  ```

  이 '메소드 서명 (method signature)' 에서 `at` 이라는 단어를 생략하면, `x` 가 제거할 원소의 위치를 지시하는 것이 아니라, `x` 와 같은 원소를 찾아서 제거하는 메소드라고 생각하게 될 것입니다.

  ```swift
  // 잘못된 예제
  employee.remove(x) // 불분명함 : x를 제거하는 것입니까?
  ```

* **필요없는 단어는 생략합니다.** 이름에 있는 모든 단어는 사용하는 쪽에 중요한 정보를 전달해야 합니다.

  의도를 명확하게 하거나 의미의 모호함을 없애기 위해 더 많은 단어가 필요할 수도 있지만, 읽는 쪽에서 이미 확보해서 과잉인 정보는 생략해야 합니다. 특히, 타입 정보를 _단순하게 반복하는 (merely repeat)_ 단어는 생략합니다.

  ```swift
  // 잘못된 예제
  public mutating func removeElement(_ member: Element) -> Element?

  allViews.removeElement(cancelButton)
  ```

  이 경우, `Element` 라는 단어는 호출하는 쪽에 아무런 중요한 것도 추가하지 않습니다. 다음 API 가 더 좋을 것입니다:

  ```swift
  // 좋은 예제
  public mutating func remove(_ member: Element) -> Element?

  allViews.remove(cancelButton) // 더 명확함
  ```

  가끔씩, 타입 정보를 반복하는 것도 모호함을 피하기 위해 필요하긴 하지만, 일반적으로 타입보다는 매개 변수의 _역할 (role)_ 을 설명하는 단어를 사용하는 것이 더 좋습니다. 자세한 것은 다음 항목을 참고합니다.

* **변수, 매개 변수, 및 결합된 타입은 역할에 따라 이름을 짓도록 하며,** 타입 구속 조건으로 이름을 짓지 않도록 합니다.

  ```swift
  // 잘못된 예제
  var string = "Hello"
  protocol ViewController {
    associatedtype ViewType : View
  }
  class ProductionLine {
    func restock(from widgetFactory: WidgetFactory)
  }
  ```

  이런 식으로 타입 이름을 재사용하면 분명함과 표현력을 최적화하는데 실패하게 됩니다. 이 보다는, '개체' 의 _역할 (role)_ 을 표현하는 이름을 선택하려고 노력합니다.

  ```swift
  // 좋은 예제
  var greeting = "Hello"
  protocol ViewController {
    associatedtype ContentView : View
  }
  class ProductionLine {
    func restock(from supplier: WidgetFactory)
  }
  ```

  '결합된 타입 (associated type)' 이 프로토콜 구속 조건에 너무 밀접하게 연결되어서 프로토콜 이름이 역할 _이기도 (is)_ 한 경우라면, 프로토콜 이름에 `Protocol` 을 덧붙여서 충돌을 피하도록 합니다:

  ```swift
  protocol Sequence {
    associatedtype Iterator : IteratorProtocol
  }
  protocol IteratorProtocol { ... }
  ```

* **타입 정보가 약하면 보완하여** 매개 변수의 역할을 분명하게 밝힙니다.

  특히, 매개 변수 타입이 `NSObject`, `Any`, `AnyObject` 이거나, `Int` 및 `String` 같은 기반 타입일 때는, 사용 시점에서 타입 정보와 상황이 의도를 온전히 전달하지 못할 수도 있습니다. 다음 예제에서, 선언은 명확한 듯 하지만, 사용하는 쪽은 분명하지가 않습니다.

  ```swift
  // 잘못된 예제
  func add(_ observer: NSObject, for keyPath: String)

  grid.add(self, for: graphics) // 불분명함
  ```

  분명함을 되살리려면, 타입이 약한 각각의 매개 변수 앞에 역할을 설명하는 명사를 붙입니다.

  ```swift
  // 좋은 예제
  func addObserver(_ observer: NSObject, forKeyPath path: String)
  grid.addObserver(self, forKeyPath: graphics) // 명확함
  ```

#### Strive for Fluent Usage (자연스러운 사용법이 되도록 노력하기)

* **메소드와 함수 이름은 사용할 때 문법에 맞는 영어 구절이 되도록 만드는 것이 좋습니다.**

  ```swift
  // 좋은 예제
  x.insert(y, at: z)          // “x 는, y 를 z 위치에 집어 넣습니다”
  x.subViews(havingColor: y)  // “x 의 하위 뷰는 y 라는 색상을 가집니다”
  x.capitalizingNouns()       // “x 는 명사를 대문자로 만듭니다”
  ```

  ```swift
  // 잘못된 예제
  x.insert(y, position: z)
  x.subViews(color: y)
  x.nounCapitalize()
  ```

  첫 번째나 두 번째 인자 이후로 인자들이 호출 시에 의미상 중심 역할을 하지 않을 때는 자연스러움이 좀 줄더라도 괜찮습니다:

  ```swift
  AudioUnit.instantiate(
    with: description,
    options: [.inProcess], completionHandler: stopProgressBar)
  ```

* **'공장 메소드 (factory methods)'[^factory-method] 의 이름은 "`make`" 로 시작합니다.** 예를 들어, `x.makeIterator()` 라고 합니다.

* **초기자 및 [공장 메소드 (factory methods)](https://en.wikipedia.org/wiki/Factory_method_pattern) 호출** 의 첫 번째 인자는 '기본 이름 (base name)[^base-name] 으로 시작하는 구절' 을 형성하지 않도록 합니다. 예를 들어, `x.makeWidget(cogCount: 47)` 라고 합니다.

  예를 들어, 이러한 호출의 첫 번째 인자는 '기본 이름 (base name) 과 같은 구절' 인 것처럼 읽히지 않아야 합니다.

  ```swift
  // 좋은 예제
  let foreground = Color(red: 32, green: 64, blue: 128)
  let newPart = factory.makeWidget(gears: 42, spindles: 14)
  let ref = Link(target: destination)
  ```

  다음은, API 작성자가 첫 번째 인자에 '문법적인 연속성 (grammatical continuity)' 을 부여하려고 한 것입니다.

  ```swift
  // 잘못된 예제
  let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)
  let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)
  let ref = Link(to: destination)
  ```

  사실상, 이 지침은 [argument labels (인자 이름표)](#argument-labels-인자-이름표) 에 대한 것과 마찬가지로 호출이 [value preserving type conversion (값 보존 타입 변환)](#type-conversion) 을 하지 않는 한 첫 번째 인자는 이름표를 가질 것을 의미합니다.

  ```swift
  let rgbForeground = RGBColor(cmykForeground)
  ```

* **함수와 메소드는 '부작용 (side-effects)'[^side-effects] 에 따라 이름을 짓습니다.**

  - '부작용 (side-effects)' 이 없는 것은, `x.distance(to: y)`, `i.successor()` 처럼, '명사구' 로 읽히도록 합니다.

  - '부작용 (side-effects)' 이 있는 것은, `print(x)`, `x.sort()`, `x.append(y)` 처럼, '명령형 동사구 (imperative verb phrases)' 로 읽히도록 합니다.

  - **변경/변경하지 않는 메소드 쌍의 이름은** 일관성이 있어야 합니다. '변경 메소드 (mutating method)' 는 종종 비슷한 '의미 구조 (semantics)' 를 가지는 별도의 '변경하지 않는 (nonmutating)', 그 자리에서 인스턴스를 갱신하는 대신 새로운 값을 반환하는, 버전을 가집니다.

    * 연산을 **동사로 설명하는 것이 자연스러울** 때는, '변경 메소드 (mutating method)' 에 대해서 동사의 '명령형 (imperative)' 을 사용하고 이에 대응되는 '변경하지 않는 (nonmutating)' 것의 이름은 "ed" 또는 "ing" 접미사를 적용합니다.

      **Mutating** | | **Nonmutating**
      ---|---|---
      `x.sort()` | | `z = x.sorted()`
      `x.append(y)` | | `z = x.appending(y)`


      - 변경하지 않는 것의 이름은 (보통 "ed" 를 추가한) 동사의 '과거 분사 (past [participle](https://en.wikipedia.org/wiki/Participle)[^participle])' 를 사용하도록 합니다:

        ```swift
        /// 그 자리에서 `self` 를 거꾸로 뒤집습니다.
        mutating func reverse()

        /// `self` 를 거꾸로 한 것의 복사본을 반환합니다.
        func reversed() -> Self
        ...
        x.reverse()
        let y = x.reversed()
        ```

      - 동사가 직접 목적어를 가지기 때문에 "ed" 를 추가하는 것이 문법적으로 맞지 않을 때는, 동사의 '현재 분사 [participle](https://en.wikipedia.org/wiki/Participle)' 를 사용하여, "ing" 를 덧붙여서, 변경하지 않는 것의 이름을 짓도록 합니다.

        ```swift
        /// `self` 에서 모든 개행 문자를 벗겨냅니다.
        mutating func stripNewlines()

        /// `self` 에서 모든 개행 문자가 벗겨진 것의 복사본을 반환합니다.
        func strippingNewlines() -> String
        ...
        s.stripNewlines()
        let oneLine = t.strippingNewlines()
        ```

    * 연산을 **명사로 설명하는 것이 자연스러울** 때는, '변경하지 않는 메소드 (nonmutating method)' 에 대해서 명사를 사용하고 이에 대응되는 '변경하는 (nonmutating)' 것의 이름에 "form" 접두사를 적용합니다.

      **Nonmutating** | | **Mutating**
      ---|---|---
      `x = y.union(z)` | | `y.formUnion(z)`
      `j = c.successor(i)` | | `c.formSuccessor(&i)`


* 사용할 때 변경되지 않는다면 **불리언 메소드와 불리언 속성은 받는 쪽에서 단언문으로 읽히도록 사용합니다** 가령 `x.isEmpty`, `line1.intersects(line2)` 같은 것이 있습니다.

* **그것이 무엇인지를 설명하는 프로토콜은 명사로 읽혀지도록 해야 합니다** (가령 `Collection` 같은 것이 있습니다).

* **_보유 능력 (capability)_ 을 설명하는 프로토콜은 `able`, `ible`, 또는 `ing` 접미사를 사용하여 이름을 지어야 합니다.** (가령 `Equatable`, `ProgressReporting` 같은 것이 있습니다).

* 그 외 다른 **타입, 속성, 변수, 및 상수는 명사로 읽혀지도록** 이름을 짓습니다.

#### Use Terminology Well (용어를 잘 사용하기)

---|---|---|---
          | **Term of Art-기술 용어** |     | _명사 (noun)_ 특정 분야 또는 직업에서 엄밀하고, 특수한 의미를 가지는 단어 또는 구절[^term-of-art]
          | |     | 

* **애매한 용어는 피하고** 더 일반적이고 의미도 잘 전달하는 단어를 사용합니다. "피부 (skin)" 가 의도에 맞다면 굳이 "표피 (epidermis)" 라고 하지 않습니다. '기술 용어 (term of art)' 는 '핵심적인 소통 도구' 이지만, 다른 경우라면 잃어 버릴 수도 있는 '결정적인 의미 (crucial meaning)' 를 붙잡아야할 때만 사용하도록 합니다.

* **기존에 확립된 의미를 유지한 채로** 기술 용어를 사용합니다.

  더 일반적인 단어 대신 '전문적인 용어 (technical term)' 를 사용하는 유일한 이유는 다른 경우라면 모호하거나 불명확한 것을 _엄밀하게 (precisely)_ 표현하기 때문입니다. 그러므로, API 는 합당한 의미에 따라 엄격하게 용어를 사용해야 합니다.

  - **전문가를 놀라게 하지 않도록 합니다.**: 이미 용어에 친숙한 사람이 새로운 의미가 발명된 것을 보면 놀랍기도 하고 화가 나기도 할 것입니다.

  - **초보자를 혼란스럽게 하지 않도록 합니다.**: 용어를 배우려는 사람은 웹 검색을 하게 될 것이고 전통적인 의미를 찾게 될 것입니다.

* **축약어를 피하도록 합니다.** '축약어 (abbreviations)', 특히 표준이-아닌 것은, 이해를 하려면 축약되지-않은 형태로 올바르게 번역해야만 한다는 점에서, 사실상 '기술 용어 (terms-of-art)' 인 것입니다.

  > 사용한 축약어는 어떤 것이든 의도한 의미를 웹 검색으로 쉽게 찾을 수 있어야 합니다.

* **선례를 받아들이도록 합니다.** 기존 문화에 대한 준수를 희생하면서까지 완전 초보자를 위해 용어를 최적화하지는 않도록 합니다.

  자료가 서로 인접해 있는 구조의 경우, 초보자라면 의미를 파악하기에 `List` 가 더 쉽더라도, `List` 라는 단순화된 용어보다 `Array` 라고 이름을 짓는 것이 더 좋습니다. '배열 (arrays)' 은 '현대의 컴퓨팅 (modern computing)' 에서 기반이므로, 모든 프로그래머가 배열이 무엇인지 알고 있거나-곧 배우게 될 것입니다. 대부분의 프로그래머에게 친숙한 용어를 사용하여, 웹 검색이나 질문을 통해 보상받을 수 있게 합니다.

  수학 같은, 특정한 프로그래밍 _분야 (domain)_ 에서는 `sin(x)` 처럼 이미 널리 사용되는 용어가 `verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)`[^sin] 와 같은 설명 방식의 구절보다 더 적합합니다. 이 경우에는, 축약어를 피하라는 지침보다 선례가 더 중시된다는 점에 주목하기 바랍니다: 완전한 단어는 `sine` 일지라도, “sin(x)” 는 프로그래머 사이에서는 수십년 동안, 그리고 수학자 사이에서는 수백년 동안 일상적으로 사용된 것입니다.

### Conventions (협약)

#### General Conventions (일반적인 협약)

* **계산 속성의 복잡도가 'O(1)' 이 아닌 경우 이를 문서화합니다.**[^complexity] 사람들은 속성에 접근 할 때, 이를 저장 속성이라고 생각하기 때문에, 이것이 상당한 계산과 엮여 있지는 않을 것이라고 가정합니다. 이러한 가정을 위반할 때는 반드시 경고해야 합니다.

* **자유 함수 (free functions) 보다는 메소드와 속성을 사용하도록 합니다.** '자유 함수 (free function)'[^free-function] 는 다음과 같은 특수한 경우에만 사용합니다:

  1. `self` 가 분명하지 않을 때:

    ```swift
    min(x, y, z)
    ```

  2. 함수가 '구속 조건이 없는 제네릭 (unconstrained generic)' 일 때:

  ```swift
  print(x)
  ```

  3. '함수 구문 표현' 이 '확립된 분야의 표기법' 에 해당할 때:

  ```swift
  sin(x)
  ```

* **대소문자 협약을 따르도록 합니다.** 타입과 프로토콜의 이름은 `UpperCamelCase` (낙타 모양 대문자)[^uppser-camel-case] 입니다. 그 외 모든 것들은 `lowCamelCase` (낙타 모양 소문자) 입니다.

  미국 영어에서 일상적으로 모두 대문자로 나타내는 [두문자어 (Acronyms and Initialisms)](https://en.wikipedia.org/wiki/Acronym)[^acronyms] 는 '대소문자 협약' 에 따라 대문자 또는 소문자로 균일하게 표기해야 합니다.

  ```swift
  var utf8Bytes: [UTF8.CodeUnit]
  var isRepresentableAsASCII = true
  var userSMTPServer: SecureSMTPServer
  ```

  그 외 다른 두문자어는 일상적인 단어로 취급합니다:

  ```swift
  var radarDetector: RadarScanner
  var enjoysScubaDiving = true
  ```

* **메소드는 기본 이름을 공유할 수 있는데** 이는 기본 의미를 같이 공유하거나 서로 별개인 분야에서 작동할 때에 그렇습니다.

  예를 들어, 다음과 같은 것들이 권장되는 것은, 이 메소드들이 본질적으로 같은 것을 하기 때문입니다:

  ```swift
  // 좋은 예제
  extension Shape {
    /// `other` 가 `self` 내에 있다는 필요충분조건을 만족하면 `true` 를 반환합니다.
    func contains(_ other: Point) -> Bool { ... }

    /// `other` 전체가 `self` 내에 있다는 필요충분조건을 만족하면 `true` 를 반환합니다.
    func contains(_ other: Shape) -> Bool { ... }

    /// `other` 가 `self` 내에 있다는 필요충분조건을 만족하면 `true` 를 반환합니다.
    func contains(_ other: LineSegment) -> Bool { ... }
  }
  ```

  그리고 '기하학 타입 (geometric types)' 과 '집합체 타입 (collections)' 은 서로 별도의 분야이므로, 같은 프로그램 내에서 다음과 같이 하는 것 또한 괜찮습니다:

  ```swift
  // 좋은 예제
  extension Collection where Element : Equatable {
    /// `self` 가 `sought` 와 같은 원소를 가지고 있다는 필요충분조건을 만족하면 `true` 를 반환합니다.
    func contains(_ sought: Element) -> Bool { ... }
  }
  ```

  하지만, 아래의 `index` 메소드들은 다른 '의미 구조 (semantics)' 를 가지므로, 이름을 다르게 지어야 합니다:

  ```swift
  // 잘못된 예제
  extension Database {
    /// Rebuilds the database's search index
    func index() { ... }

    /// Returns the `n`th row in the given table.
    func index(_ n: Int, inTable: TableID) -> TableRow { ... }
  }
  ```

  마지막으로, "반환 타입에 대한 중복 정의 (overloading on return type)" 는 타입 추론 시에 모호함을 유발할 수 있기 때문에 피합니다.

  ```swift
  // 잘못된 예제
  extension Box {
    /// Returns the `Int` stored in `self`, if any, and
    /// `nil` otherwise.
    func value() -> Int? { ... }

    /// Returns the `String` stored in `self`, if any, and
    /// `nil` otherwise.
    func value() -> String? { ... }
  }
  ```

#### Parameters (매개 변수)

```swift
func move(from start: Point, to end: Point)
```

* **매개 변수 이름은 문서화에 도움이 되도록 선택합니다.** 매개 변수 이름은 함수나 메소드를 사용하는 곳에서는 나타나지 않지만, 설명에 있어서 중요한 역할을 합니다.

  이 이름들은 문서가 쉽게 읽히도록 선택합니다. 예를 들어, 이런 이름은 문서를 자연스럽게 읽히도록 만듭니다.

  ```swift
  // 좋은 예제

  /// Return an `Array` containing the elements of `self`
  /// that satisfy `predicate`.
  /// `self` 의 원소 중 `predicate` 를 만족하는 것을 담고 있는 `Array` 를 반환합니다.
  func filter(_ predicate: (Element) -> Bool) -> [Generator.Element]

  /// Replace the given `subRange` of elements with `newElements`.
  /// 주어진 `subRange` 의 원소들을 `newElements` 로 대체합니다.
  mutating func replaceRange(_ subRange: Range, with newElements: [E])
  ```

  하지만, 아래 있는 것들은 문서를 어색하고 문법적이지 않도록 만듭니다.

  ```swift
  // 잘못된 예제

  /// Return an `Array` containing the elements of `self`
  /// that satisfy `includedInResult`.
  /// `self` 의 원소 중 `includedInResult` 를 만족하는 것을 담고 있는 `Array` 를 반환합니다.
  func filter(_ includedInResult: (Element) -> Bool) -> [Generator.Element]

  /// Replace the range of elements indicated by `r` with
  /// the contents of `with`.
  /// `r` 로 지시한 범위의 원소들을 `with` 의 내용으로 대체합니다.
  mutating func replaceRange(_ r: Range, with: [E])
  ```

* **기본 설정 매개 변수 (defaulted parameters) 의 장점은** 공통된 사용법을 간단하게 만들 때마다 취하도록 합니다. 매개 변수가 공통적으로-사용되는 단일한 값을 가진다면 '기본 설정 (default)' 의 후보입니다.

  '기본 설정 인자 (default arguments)' 는 관계가 없는 정보를 숨겨 가독성을 개선합니다. 예를 들면 다음과 같습니다:

  ```swift
  // 잘못된 예제
  let order = lastName.compare(
    royalFamilyName, options: [], range: nil, locale: nil)
  ```

  위는 훨씬 더 간단해질 수 있습니다:[^simpler]

  ```swift
  // 좋은 예제
  let order = lastName.compare(royalFamilyName)
  ```

  '기본 설정 인자' 가 일반적으로 '메소드 일가 (method families)' 보다 더 나은데, 이는 API 를 이해하려는 사람에게 부담이 더 적기 때문입니다.

  ```swift
  // 좋은 예제
  extension String {
    /// ...설명...
    public func compare(
      _ other: String, options: CompareOptions = [],
      range: Range? = nil, locale: Locale? = nil
    ) -> Ordering
  }
  ```

  위에 있는 것은 간단하지 않은 것 같지만, 다음 보다는 훨씬 더 간단합니다:

  ```swift
  // 잘못된 예제
  extension String {
    /// ...설명 1...
    public func compare(_ other: String) -> Ordering
    /// ...설명 2...
    public func compare(_ other: String, options: CompareOptions) -> Ordering
    /// ...설명 3...
    public func compare(
      _ other: String, options: CompareOptions, range: Range) -> Ordering
    /// ...설명 4...
    public func compare(
      _ other: String, options: StringCompareOptions,
      range: Range, locale: Locale) -> Ordering
  }
  ```

  '메소드 일가 (method family)' 는 모든 구성원에 대해 사용자가 별도로 문서화해서 이해할 필요가 있습니다. 이 중에서 결정하려면, 사용자가 이 모든 것을 이해해야 하며, 가끔 있는 놀라운 관계-예를 들어, `foo(bar: nil)` 과 `foo()` 가 항상 동의어는 아니라는 것-은 이를 대부분은 똑같은 문서에서 사소한 차이점을 캐내는 지루한 과정으로 만듭니다. 기본 설정을 가진 단일 메소드의 사용은 대단히 우수한 프로그래머 경험을 제공합니다.

* **기본 설정을 가진 매개 변수의 위치는** 매개 변수 목록의 끝으로 보내는 것이 낫습니다. 기본 설정이 없는 매개 변수가 보통 메소드의 의미 구조상 더 본질적이며, 메소드가 호출되는 곳에서 사용하기에 안정적인 '초기화 패턴 (initial pattern)' 을 제공합니다.

#### Argument Labels (인자 이름표)

```swift
func move(from start: Point, to end: Point)
x.move(from: x, to: y)
```

* **인자를 구별하는게 쓸모 없을 때는 모든 이름표를 생략합니다.**, 가령 `min(number1, number2)`, `zip(sequence1, sequence2)` 라고 합니다.

* <strong id="type-conversion">'값 보존 타입 변환 (value preserving type conversion)' 을 하는 초기자에서, 첫 번째 인자 이름표는 생략합니다</strong>, 가령 `Int64(someUInt32)` 라고 합니다.

  첫 번째 인자는 항상 변환의 '원천 (source)' 이어야 합니다.

  ```swift
  extension String {
    // Convert `x` into its textual representation in the given radix
    init(_ x: BigInt, radix: Int = 10)          ← 초기 밑줄에 주목합니다.
  }

  text = "The value is: "
  text += String(veryLargeNumber)
  text += " and in hexadecimal, it's"
  text += String(veryLargeNumber, radix: 16)
  ```

  하지만, "좁히는 (narrowing)" 타입 변환에서는, 좁힘을 설명하는 이름표를 하기를 추천합니다.

  ```swift
  extension UInt32 {
    /// Creates an instance having the specified `value`.
    init(_ value: Int16)                        ← 넓히는 것이므로, 이름표가 없습니다.
    /// Creates an instance having the lowest 32 bits of `source`.
    init(truncating source: UInt64)
    /// Creates an instance having the nearest representable
    /// approximation of `valueToApproximate`.
    init(saturating valueToApproximate: UInt64)
  }
  ```

  > 값 보존 타입 변환은 [단사 사상 (monomorphism)](https://en.wikipedia.org/wiki/Monomorphism)[^monomorphism] 입니다. 즉, 소스의 값에 있는 모든 차이가 결과의 값에 있는 차이로 귀결됩니다. 예를 들어, `Int8` 에서 `Int64` 로의 변환은 '값 보존' 인데 이는 모든 별개의 `Int8` 값이 별개의 `Int64` 값으로 변환되기 때문입니다. 하지만, 다른 방향으로의 변환은 '값 보존' 일 수 없습니다: `Int64` 은 `Int8` 으로 표현할 수 있는 것보다 더 많은 값을 가지고 있습니다.
  >
  > 참고 : 원래의 값을 가져오는 능력은 변환이 '값 보존' 인지의 여부와는 관계가 없습니다.


* **첫 번째 인자가 [전치사 구 (prepositional phrase)](https://en.wikipedia.org/wiki/Adpositional_phrase#Prepositional_phrases) 를 형성할 때는, 인자 이름표를 부여합니다.** 인자 이름표는, `x.removeBoxes(havingLength: 12)` 처럼, 보통은 [전치사 (preposition)](https://en.wikipedia.org/wiki/Preposition_and_postposition) 로 시작해야 합니다.

  처음 두 인자가 '단일 추상 명사 (single abstraction)' 를 표현할 때는 예외가 생깁니다.

  ```swift
  // 잘못된 예제
  a.move(toX: b, y: c)
  a.fade(fromRed: b, green: c, blue: d)
  ```

  이런 경우, 추상 명사를 명확하게 유지하도록, 인자 이름표를 전치사 _뒤에서 (after)_ 부터 시작합니다.

  ```swift
  // 좋은 예제
  a.moveTo(x: b, y: c)
  a.fadeFrom(red: b, green: c, blue: d)
  ```


* **그 외의 경우에서, 첫 번째 인자가 문법적인 구절을 형성하는 경우, 이름표를 생략하고**, `x.addSubview(y)` 처럼, '기본 이름 (base name)' 앞에 어떤 단어를 추가합니다.

  이 지침은, 첫 번째 인자가 문법적인 구절을 형성하지 _않는 (doesn't)_ 경우, 이름표를 가져야 함을 의미합니다.

  ```swift
  // 좋은 예제
  view.dismiss(animated: false)
  let text = words.split(maxSplits: 12)
  let studentsByName = students.sorted(isOrderedBefore: Student.namePrecedes)
  ```

  구절은 올바른 의미를 전달하는 것이 중요함에 주의합니다. 다음은 문법적으로는 맞겠지만 잘못된 것을 표현하게 됩니다.

  ```swift
  // 잘못된 예제
  view.dismiss(false)   // 물러나지 말아야 하는 것인가? 불리언 값을 물러가게 하라는 것인가?
  words.split(12)       // 12 라는 수를 쪼개야 하는가?
  ```

  기본 설정 값을 가지는 인자는 생략할 수 있어서, 문법적인 구절을 형성하지 않을 수도 있으므로, 항상 이름표를 가져야 함에 주의하기 바랍니다.

* **다른 모든 인자들은 이름표를 붙입니다.**

### Special Instructions (특수한 지시 사항들)

* **튜플 멤버의 이름표와 클로저 매개 변수의 이름은** API 에 나타날 때마다 붙이도록 합니다.

  이 이름들은 설명에 아주 도움이 되며, '문서화 주석 (documentation comments)' 에서 참조할 수 있으며, 튜플 멤버를 접근할 때 의미 전달이 잘 됩니다.

  ```swift
  /// Ensure that we hold uniquely-referenced storage for at least
  /// `requestedCapacity` elements.
  ///
  /// If more storage is needed, `allocate` is called with
  /// `byteCount` equal to the number of maximally-aligned
  /// bytes to allocate.
  ///
  /// - Returns:
  ///   - reallocated: `true` iff a new block of memory
  ///     was allocated.
  ///   - capacityChanged: `true` iff `capacity` was updated.
  mutating func ensureUniqueStorage(
    minimumCapacity requestedCapacity: Int,
    allocate: (_ byteCount: Int) -> UnsafePointer<Void>
  ) -> (reallocated: Bool, capacityChanged: Bool)
  ```

  클로저 매개 변수에 사용하는 이름은 최상위 함수의 [매개 변수 이름 (parameter names)](#parameters-매개-변수) 처럼 선택해야 합니다. 클로저 인자에 대한 이름표는 호출하는 쪽에서는 지원하지 않습니다.

* **'구속 조건이 없는 다형성 (unconstrained polymorphism)' 은 좀 더 주의해서** (`Any`, `AnyObject`, 및 구속 조건이 없는 제네릭 매개 변수 등의) 중복정의 집합에서 모호함을 피하도록 합니다.

  예를 들어, 다음의 중복정의 집합을 고려해 봅시다:

  ```swift
  // 잘못된 예제
  struct Array {
    /// Inserts `newElement` at `self.endIndex`.
    public mutating func append(_ newElement: Element)

    /// Inserts the contents of `newElements`, in order, at
    /// `self.endIndex`.
    public mutating func append(_ newElements: S)
      where S.Generator.Element == Element
  }
  ```

  이 메소드들은 '의미 상의 일가족 (semantic family)' 을 형성하며, 맨 처음에 있는 인자 타입은 뚜렷하게 구별됩니다. 하지만, `Element` 가 `Any` 일 때는, '단일 원소 (single element)' 가 '일련의 원소들 (sequnce of elements)' 과 같은 타입을 가질 수 있습니다.

  ```swift
  // 잘못된 예제
  var values: [Any] = [1, "a"]
  values.append([2, 3, 4]) // [1, "a", [2, 3, 4]] or [1, "a", 2, 3, 4]?
  ```

  모호함을 없애기 위해, 두 번째 중복정의는 더 명시적으로 이름을 짓도록 합니다.

  ```swift
  // 좋은 예제
  struct Array {
    /// Inserts `newElement` at `self.endIndex`.
    public mutating func append(_ newElement: Element)

    /// Inserts the contents of `newElements`, in order, at
    /// `self.endIndex`.
    public mutating func append(contentsOf newElements: S)
      where S.Generator.Element == Element
  }
  ```

  새로운 이름이 '문서화 주석' 과 얼마나 더 잘 일치하는 지에 주목하기 바랍니다. 이 경우, 문서화 주석을 작성하는 행위가 실제로 API 작성자에게 논점을 떠올리게 합니다.

### 참고 자료

[^ducumentation-comment]: '문서화 주석 (documentation comment)' 이란 'Xcode 편집기' 에서 스위프트 코드의 선언을 '옵션-클릭' 했을 때 나타나는 주석을 말합니다. 문서화 주석은 개발자가 직접 추가할 수 있으므로, 'API 설계 지침' 에서는 자신이 작성하고 있는 코드에도 '문서화 주석' 을 추가하라고 조언하고 있습니다.

[^fragment]: 여기서 '문장 구절 (sentence fragment)' 을 사용하라는 것은 완전한 문장이 아니라, 하나의 구절 형태로 사용하라는 의미입니다. 'API 설계 지침' 에서는 '요약 (summary)' 에는 '문장 구절' 을 사용하고, 이어지는 '문단 설명' 에서는 '완전한 문장' 사용하라고 조언하고 있습니다.

[^symbol-comman-syntax]: 링크 자체는 바로 위의 링크와 같은 [symbol documentation markup](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW1) 문서로 연결됩니다.

[^factory-method]: '공장 메소드 (factory method)' 는 '공장 메소드 패턴 (factory method pattern)' 에서 사용하는 메소드로, '구체적으로 고정된 타입 (concrete type)' 을 지정하지 않은 채 객체를 생성할 수 있게 해줍니다. 보다 자세한 내용은 위키피디아의 [Factory method pattern](https://en.wikipedia.org/wiki/Factory_method_pattern) 및 [팩토리 메서드 패턴](https://ko.wikipedia.org/wiki/팩토리_메서드_패턴) 항목을 참고하기 바랍니다.

[^base-name]: '기본 이름 (base name)' 은 함수 또는 메소드에서 매개 변수와 괄호를 뺀 순수한 함수 자체의 이름인 것으로 추측됩니다.

[^side-effects]: 컴퓨터 용어에서의 '부작용 (side-effects)' 은 무조건 나쁜 것이 아니라 '부가적인 효과' 정도의 의미로 이해할 수 있습니다.

[^participle]: 원문 자체가 위키피디아의 [participle](https://en.wikipedia.org/wiki/Participle) 항목에 대한 링크로 되어 있습니다.

[^term-of-art]: 이어지는 내용을 보면 알겠지만, 스위프트는 이런 '기술 용어 (term of art)' 대신 일상 용어를 더 많이 사용할 것을 권장하고 있습니다. 스위프트 표준 라이브러리에 있는 클래스들을 봐도, `Image` 나 `Button` 처럼, 접두사 없이 일상 용어로 타입 이름을 정하는 것을 볼 수 있습니다.

[^sin]: 'verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle' 이 말을 직역하면 '각도를 가진 반지름의 끝이 원점에 있는 단위 원 상에 있을 때의 수직 위치' 정도로 옮길 수 있습니다.

[^complexity]: 컴퓨터 용어로 '복잡도 (complexity)' 라는 것은 알고리즘을 실행하는데 필요한 자원의 총량을 나타내는 말입니다. 보다 자세한 내용은 위키피디아의 [Computational complexity](https://en.wikipedia.org/wiki/Computational_complexity) 항목을 참고하기 바랍니다.

[^free-function]: 스위프트에서 '자유 함수 (free function)' 는 어느 영역에도 소속되어 있지 않은 '멤버가 아닌 함수 (non-member function)'-즉 일종의 전역 함수-를 의미합니다. 보다 자세한 내용은 위키피디아의 [Free function](https://en.wikipedia.org/wiki/Free_function) 항목을 참고하기 바랍니다.

[^uppser-camel-case]: '낙타 모양 대소문자 (camel case)' 는, 변수 이름을 지정할 때 모든 단어를 붙이고. 각 단어의 첫 글자를 대문자로 표기하면, 모양이 낙타 등처럼 생겼기 때문에 나온 말입니다. '낙타 모양 대소문자 (camel Case)' 에 대한 보다 자세한 내용은 위키피디아의 [Camel case](https://en.wikipedia.org/wiki/Camel_case) 와 [낙타 대문자](https://ko.wikipedia.org/wiki/낙타_대문자) 항목을 참고하기 바랍니다.

[^acronyms]: '두문자어 (Acronyms and Initialisms)' 는 'ASCII' 같이 단어의 앞머리 글자만 떼어 만든 줄임말을 의미합니다. 그리고 영어의 'Acronyms' 와 'Initialisms' 는 사실상 같은 단어입니다. 보다 자세한 내용은 위키피디아의 [Acronym](https://en.wikipedia.org/wiki/Acronym) 항목과 [두문자어](https://ko.wikipedia.org/wiki/두문자어) 항목을 참고하기 바랍니다.

[^simpler]: '기본 설정 매개 변수 (default parameters)' 를 사용하면 함수를 호출할 때 그와 연관된 인자를 생략할 수 있어서 코드가 간단해집니다. 스위프트의 `print(_:separator:terminator:)` 함수가 대표적인 예라고 할 수 있습니다.

[^monomorphism]: 원문에서는 '단사 사상 (monomorphism)' 이라는 말을 사용하고 있지만, 이를 사실 '단사 함수 (injective function)' 의 의미로써 사용하고 있습니다. '단사 함수' 는 '정의역 또는 소스 (source)' 에 있는 서로 다른 원소를 '공역 또는 결과 (result)' 에 있는 서로 다른 원소로 대응시키는 함수를 말합니다. 보다 자세한 내용은 위키피디아의 [Monomorphism](https://en.wikipedia.org/wiki/Monomorphism) 항목 및 [단사 사상](https://ko.wikipedia.org/wiki/단사_사상) 항목, 그리고 [Injective function](https://en.wikipedia.org/wiki/Injective_function) 항목 및 [단사 함수](https://ko.wikipedia.org/wiki/단사_함수) 항목을 참고하기 바랍니다.
