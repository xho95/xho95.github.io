---
layout: post
comments: true
title:  "Generics (일반화)"
date:   2020-02-29 11:30:00 +0900
categories: Swift Language Grammar Generic
---

{% include header_swift_book.md %}

## Generics (일반화)

_일반화 코드 (generic code)_ 는 유연하고, 재사용 가능한 함수와 타입을 작성하여, 직접 정의한 필수 조건[^requirements] 의 영향도 받는, 어떠한 타입과도 작업할 수 있게 합니다.

일반화는 스위프트의 가장 강력한 특징 중 하나로, 대부분의 스위프트 표준 라이브러리도 일반화 코드로 제작되어 있습니다. 사실, _언어 설명서 (Language Guide)_[^language-guide] 내내 일반화를 써왔었는데, 알지 못했을 겁니다. 예를 들어, 스위프트의 `Array` 와 `Dictionary` 타입은 둘 다 일반화 집합체[^genenric-colletion] 입니다. `Int` 값을 들고 있는 배열이나, `String` 값을 들고 있는 배열을 생성할 수도, 아니면 진짜로 스위프트로 생성할 수 있는 어떠한 다른 타입의 배열이라도 생성할 수 있습니다. 이와 비슷하게, 어떻게 지정된 타입의 값이든 저장하는 딕셔너리도 생성할 수 있으며, 그 타입이 될 수 있는 것엔 아무런 한계도 없습니다.

### The Problem That Generics Solve (일반화로 푸는 문제)

여기 있는 표준의, 일반화 아닌 함수인 `swapTwoInts(_:_:)` 는, 두 개의 `Int` 값을 맞바꿉니다:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

이 함수는 입-출력 매개 변수를 사용하여 `a` 와 `b` 의 값을 맞바꾸는데, [In-Out Parameters (입-출력 매개 변수)]({% link docs/swift-books/swift-programming-language/functions.md %}#in-out-parameters-입-출력-매개-변수) 에서 설명한 것과 같습니다.

`swapTwoInts(_:_:)` 함수는 원본 값 `b` 는 `a` 로, 원본 값 `a` 는 `b` 로, 맞바꿉니다. 이 함수를 호출하여 두 개의 `Int` 변수 값을 맞바꿀 수 있습니다:

```swift
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// "someInt is now 107, and anotherInt is now 3" 를 인쇄함
```

`swapTwoInts(_:_:)` 함수는 유용하지만, `Int` 값에만 쓸 수 있습니다. 두 개의 `String` 값이나, 두 개의 `Double` 값을 맞바꾸고 싶으면, 더 많은 함수들을 작성해야 하며, 이는 아래에 볼 `swapTwoStrings(_:_:)` 과 `swapTwoDoubles(_:_:)` 같은 것들입니다:

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
  let temporaryA = a
  a = b
  b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

`swapTwoInts(_:_:)` 는 그 본문이, `swapTwoStrings(_:_:)`, 및 `swapTwoDoubles(_:_:)` 함수와 그 정체가 똑같다는 걸 알아차렸을 수도 있습니다. 유일한 차이점은 이들이 받아들이는 값의 타입입니다 (`Int` 와, `String`, 및 `Double`).

더 유용하고, 더 유연한 방법은, 단 하나의 함수를 작성하여 _어떠한 (any)_ 타입의 두 값이든 맞바꾸는 겁니다. 일반화 코드는 그런 함수를 작성할 수 있게 합니다. (이 함수들을 일반화한 버전은 아래에서 정의합니다.)

> 세 개의 모든 함수들에서, `a` 와 `b` 의 타입은 반드시 같아야 합니다. `a` 와 `b` 가 같은 타입이 아니면, 그들의 값을 맞바꾸는게 불가능합니다. 스위프트는 타입-안전 언어라서, (예를 들어) `String` 타입 변수와 `Double` 타입 변수가 값을 서로 맞바꾸도록 허용하지 않습니다. 그러한 시도의 결과는 컴파일-시간 에러입니다.

### Generic Functions (일반화 함수)

_일반화 함수 (generic functions)_ 는 어떤 타입과도 작업할 수 있습니다. 여기 있는 건 위에 있는 `swapTwoInts(_:_:)` 함수의 일반화 버전인, `swapTwoValues(_: _:)` 입니다:

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

`swapTwoValues(_:_:)` 함수의 본문은 그 정체가 `swapTwoInts(_:_:)` 함수의 본문과 완전히 똑같습니다. 하지만, `swapTwoValues(_:_:)` 의 첫째 줄은 `swapTwoInts(_:_:)` 와 살짝 다릅니다. 첫째 줄을 비교하면 이렇습니다:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<T>(_ a: inout T, _ b: inout T)
```

일반화 버전의 함수는 _자리 표시용 (placeholder)_ 타입 이름 (이 경우엔, `T`) 를 _실제 (actual)_ 타입 이름 (`Int` 나, `String`, 및 `Double` 같은 것들) 대신 사용합니다. 자리 표시용 타입 이름은 `T` 가 무엇이어야 하는지 대해선 어떤 것도 말하지 않지만, `T` 가 무엇을 나타내든, `a` 와 `b` 가 둘 다 반드시 똑같은 타입인 `T` 여야 _한다고 (does)_ 말합니다. `T` 인 곳에 쓸 실제 타입은 매 번 `swapTwoValues​​(_:_:)` 함수를 호출할 때마다 결정됩니다.

일반화 함수와 일반화 아닌 함수의 또 다른 차이점은 일반화 함수 이름 (`swapTwoValues​​(_:_:)`) 뒤에는 자리 표시용 타입 이름 (`T`) 이 꺾쇠 괄호 (`<T>`) 안에 담겨 따라온다는 겁니다. 괄호는 스위프트에게 `swapTwoValues​​(_:_:)` 함수 정의 안에서는 `T` 가 자리 표시용 타입 이름이라고 말해줍니다. `T` 는 자리 표시자이기 때문에, 스위프트가 `T` 라는 실제 타입을 찾지 않습니다.

`swapTwoValues​​(_:_:)` 함수는 이제, _어떠한 (any)_ 타입의 두 값도 전달될 수 있다는 걸 제외하면, `swapTwoInts` 와 똑같은 방식으로 호출할 수 있는데, 두 값의 타입이 서로 똑같기만 하면 됩니다. `swapTwoValues​​(_:_:)` 를 호출할 때마다, 함수에 전달된 값의 타입으로 `T` 에 쓸 타입을 추론합니다.

아래의 두 예제에서, `T` 는 각각 `Int` 와 `String` 이라고 추론됩니다:

```swift
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt 는 이제 107 이고, anotherInt 는 이제 3 임

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString 은 이제 "world" 이고, anotherString 은 이제 "hello" 임
```

> 위에서 정의한 `swapTwoValues(_:_:)` 함수는 `swap` 이라는 일반화 함수에서 영감받은 건데, 이는 스위프트 표준 라이브러리에 있는 것으로, 앱에서 자동으로 쓸 수 있습니다. 자신만의 코드에 `swapTwoValues(_:_:)` 함수와 같은 동작이 필요하다면, 직접 구현하기 보단 스위프트에 이미 있는 `swap(_:_:)` 함수를 쓰면 됩니다.

### Type Parameters (타입 매개 변수)

위에 있는 `swapTwoValues(_:_:)` 예제에서, 자리 표시용 타입 `T` 는 _타입 매개 변수 (type parameter)_ 의 한 예입니다. 타입 매개 변수는 자리 표시용 타입을 지정하고 이름을 붙이며, 함수 이름 바로 뒤, 한 썅의 꺾쇠 괄호 사이에 (`<T>` 와 같이) 작성합니다.

일단 한 번 타입 매개 변수를 지정하면, 이를 써서 함수의 매개 변수 타입 (`swapTwoValues(_:_:)` 함수의 `a` 와 `b` 매개 변수 같은 것) 이나, 함수의 반환 타입, 또는 함수 본문 안에서의 타입 보조 설명[^type-annotation] 등을 정의할 수 있습니다. 각각의 경우에, 타입 매개 변수는 함수를 호출할 때마다 _실제 (actual)_ 타입으로 교체됩니다. (위의 `swapTwoValues(_:_:)` 예제에서, `T` 는 첫 번째 함수 호출에선 `Int` 로 교체되고, 두 번째로 호출에선 `String` 으로 교체됩니다.)

하나 이상의 타입 매개 변수를 제공할 수도 있는데 꺾쇠 괄호 안에 여러 개의 타입 매개 변수 이름을 쓰고, 쉼표로 구분하면 됩니다.

### Naming Type Parameters (타입 매개 변수의 이름짓기)

대부분의 경우, 타입 매개 변수는 셜명하는 식의 이름을 가지며, `Dictionary<Key, Value>` 의 `Key` 와 `Value` 및 `Array<Element>` 의 `Element` 같이, 타입 매개 변수와 이를 쓸 일반화 타입 또는 함수와의 관계를 말해줍니다. 하지만, 이들 간에 의미있는 관계가 없을 땐, 전통적으로 `T`, `U`, `V` 같이 단 하나의 문자로 이름을 지어서, 위의 `swapTwoValues(_:_:)` 함수에 있는 `T` 와 같이 합니다.

> 타입 매개 변수엔 항상 낙타 모양 대문자 (upper camel case)[^upper-camel-case] 이름 (인 `T` 와 `MyTypeParamter` 같은 것들) 을 줘서, 값이 아닌, _타입 (type)_ 의 자리를 표시하는 거라고 지시합니다.

### Generic Types (일반화 타입)

일반화 함수에 더해, 스위프트는 자신만의 _일반화 타입 (generic types)_ 도 정의할 수 있게 합니다. 이러한 자신만의 클래스와, 구조체, 및 열거체들은 _어떠한 (any)_ 타입과도 작업할 수 있으며, 그 방식이 `Array` 및 `Dictionary` 와 비슷합니다.

이번 절에서는 `Stack` 이라는 일반화 집합체 타입의 작성법을 보여줍니다. 스택은 순서 있는 값 집합[^ordered-set] 으로, 배열과 비슷하지만, 연산 집합이 스위프트의 `Array` 타입보다 더 제약되어 있습니다.[^restricted] 배열은 배열의 어떤 위치에서든 새로운 항목을 집어 넣고 제거하는 걸 허용합니다. 하지만, 스택은 집합체의 끝에서서만 새 항목을 덧붙이는 걸 허용합니다 (이를 스택에 새 값 _밀어 넣기 (pushing)_ 라고 합니다). 이와 비슷하게, 스택은 집합체 끝에서서만 항목을 제거하는 걸 허용합니다 (이는 스택에서 값 _빼내기 (popping)_ 라고 합니다).

> `UINavigationController` 클래스는 스택이라는 개념을 써서 **길찾기 계층 구조**[^navigation-hierarchy] 에 있는 **뷰 컨트롤러** 들을 모델링합니다.[^navigation-stack] `UINavigationController` 클래스의 `pushViewController(_:animated:)` 메소드를 호출하여 **길찾기 스택** 에 **뷰 컨트롤러** 를 추가하(거나 밀어 넣으)며, `popViewControllerAnimated(_:)` 메소드로 **길찾기 스택** 에서 **뷰 컨트롤러** 를 제거(하거나 빼냅니다). 스택은 엄격한 "후입 선출 (last in, first out)"[^LIFO] 접근법으로 집합체를 관리할 필요가 있을 때 유용한 집합체 모델입니다.

아래 삽화는 스택의 밀어 넣기와 빼내기 동작을 보여줍니다:

![Push and Pop of Stack](/assets/Swift/Swift-Programming-Language/Generic-stack-push-and-pop.png)

1. 스택에는 현재 세 개의 값이 있습니다.
2. 네 번째 값을 스택 맨 위에 밀어 넣습니다.
3. 스택은 이제 네 개의 값을 들고 있으며, 가장 최근게 맨 위에 있습니다.
4. 스택 맨 위의 항목을 빼냅니다.
5. 값을 빼낸 후, 스택은 다시 한번 세 개의 값을 들고 있습니다.

일반화 아닌 버전의 스택 작성법은 이런데, 이 경우엔 `Int` 값의 스택입니다:

```swift
struct IntStack {
  var items = [Int]()
  mutating func push(_ item: Int) {
    items.append(item)
  }
  mutating func pop() -> Int {
    return items.removeLast()
  }
}
```

이 구조체는 `Array` 속성인 `items` 를 써서 스택에 값을 저장합니다. `Stack` 이 제공한 두 메소드인, `push` 와 `pop` 은, 스택에 값을 밀어 넣고 빼냅니다. 이 메소드를 `mutating` 으로 표시한 건, 구조체의 `items` 배열을 수정 (하거나 _변경 (mutate)_ 할) 필요가 있기 때문입니다.

위에서 본 `IntStack` 타입은 `Int` 값 하고만 쓸 수 있긴, 합니다. _일반화 (generic)_ `Stack` 구조체를 정의하여, _어떠한 (any)_ 타입의 값으로 된 스택이든 관리할 수 있다면, 훨씬 더 유용할 겁니다.

똑같은 코드를 일반화한 버전은 이렇습니다:

```swift
struct Stack<Element> {
  var items = [Element]()
  mutating func push(_ item: Element) {
    items.append(item)
  }
  mutating func pop() -> Element {
    return items.removeLast()
  }
}
```

일반화 버전의 `Stack` 은 일반화 아닌 버전과 본질적으로는 똑같지만, 실제 타입인 `Int` 대신 타입 매개 변수인 `Element` 를 쓴다는 걸 알아두기 바랍니다. 이 타입 매개 변수는 한 쌍의 꺾쇠 괄호 안에 써서 (`<Element>`) 구조체 이름 바로 뒤에 둡니다.

`Element` 는 나중에 제공할 타입의 자리 표시용 이름을 정의합니다. 이 미래 타입을 구조체 정의 안 어디서든 `Element` 로 참조할 수 있습니다. 이번 경우엔, 세 곳에서 `Element` 를 자리 표시자로 씁니다:

* `items` 라고 하는, `Element` 타입 값의 빈 배열로 초기화되는, 속성을 생성하기 위해
* `push(_:)` 메소드에 있는 단 하나의 매개 변수인 `item` 가, 반드시 `Element` 타입이어야 한다고, 지정하기 위해
* `pop()` 메소드에서 반환되는 값이 `Element` 타입의 값일 거라고 지정하기 위해

일반화 타입이기 때문에, `Stack` 을 쓰면 _어떠한 (any)_ 유효한 타입의 스택이든 스위프트로 생성할 수 있으며, 그 방식은 `Array` 및 `Dictionary` 와 비슷합니다.

새로운 `Stack` 인스턴스를 생성하려면 스택에 저장할 타입을 꺾쇠 괄호 안에 씁니다. 예를 들어, 새로운 문자열 스택을 생성하려면, `Stack<String>()` 이라고 씁니다.:

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 스택엔 이제 4 개의 문자열이 담김
```

네 개의 값을 스택에 밀어 넣은 후의 `stackOfStrings` 을 보면 이렇습니다:

![Pushing of Stack](/assets/Swift/Swift-Programming-Language/Generic-stack-pushing.png)

스택에서 값을 빼내면 맨 위의 값인, `"cuatro"` 를, 제거하고 반환합니다:

```swift
let fromTheTop = stackOfStrings.pop()
// fromTheTop 은 "cuatro" 와 같으며, 스택엔 이제 3개의 문자열이 담김
```

맨 위 값을 빼낸 후의 스택을 보면 이렇습니다:

![Popping of Stack](/assets/Swift/Swift-Programming-Language/Generic-stack-popping.jpg)

### Extending a Generic Type (일반화 타입 확장하기)

일반화 타입을 확장할 때는, 타입 매개 변수 목록을 익스텐션의 정의 부분에 제공하지 않습니다.[^type-parameter-list] 그 대신, _원본 (original)_ 타입 정의에 있는 타입 매개 변수 목록을 익스텐션 본문에서 쑬 수 있어서, 원본 타입 매개 변수 이름으로 원본 정의에 있는 타입 매개 변수를 참조합니다.

다음 예제는 일반화 `Stack` 타입을 확장하여 `topItem` 이라는 읽기-전용 계산 속성을 추가하는데, 이는 스택에서 맨 위의 항목을 빼내지 않고 반환합니다:

```swift
extension Stack {
  var topItem: Element? {
    return items.isEmpty ? nil : items[items.count - 1]
  }
}
```

`topItem` 속성은 `Element` 타입의에 대한 옵셔널 값을 반환합니다. 스택이 비었으면, `topItem` 이 `nil` 을 반환하고; 스택이 비지 않으면, `topItem` 이 `items` 배열의 마지막 항목을 반환합니다.

이 익스텐션은 타입 매개 변수 목록을 정의하지 않는다는 걸 알아두기 바랍니다. 그 대신, `Stack` 타입에 이미 있던 타입 매개 변수 이름인, `Element` 를, 익스텐션 안에서 사용하여 `topItem` 계산 속성의 옵셔널 타입을 지시합니다.

이제 어떤 `Stack` 인스턴스에서든 `topItem` 계산 속성을 써서 자신의 맨 위 항목을 제거하지 않고 접근하여 조회할 수 있습니다.

```swift
if let topItem = stackOfStrings.topItem {
  print("The top item on the stack is \(topItem).")
}
// "The top item on the stack is tres." 를 인쇄함
```

일반화 타입의 익스텐션은 필수 조건도 포함할 수 있어서 확장된 타입의 인스턴스가 반드시 만족해야 새로운 기능을 얻도록 할 수도 있으며, 이는 아래의 [Extensions with a Generic Where Clause (일반화 where 절이 있는 익스텐션)]({% link docs/swift-books/swift-programming-language/generics.md %}#extensions-with-a-generic-where-clause-일반화-where-절이-있는-익스텐션) 에서 논의합니다.

### Type Constraints (타입 구속 조건)

`swapTwoValues​​(_:_:)` 함수와 `Stack` 타입은 어떠한 타입과도 작업할 수 있습니다. 하지만, 일반화 함수 및 일반화 타입과 사용할 수 있는 타입에 강제로 특정 _타입 구속 조건 (type constraints)_ 을 주는게 유용할 때도 있습니다. 타입 구속 조건은 타입 매개 변수가 반드시 특정한 클래스를 상속하거나, 특별한 프로토콜 또는 프로토콜 합성[^protocol-composition] 을 따라야 한다는 걸 지정합니다.

예를 들어, 스위프트의 `Dictionary` 타입은 딕셔너리의 키로 쓸 수 있는 타입에 제한을 둡니다. [Dictionaries (딕셔너리)]({% link docs/swift-books/swift-programming-language/collection-types.md %}#dictionaries-딕셔너리) 에서 설명하듯, 딕셔너리의 키 타입은 반드시 _해시 가능 (hashable)_[^hashable] 해야 합니다. 즉, 반드시 그 자신을 유일하게 나타낼 수 있는 방법을 제공해야 합니다. `Dictionary` 는 키가 해시 가능할 필요가 있는데 그래야만 한 특별한 키에 이미 값이 담겼는지 검사할 수 있습니다. 이런 필수 조건이 없다면, `Dictionary` 가 특별한 키에 값을 집어 넣거나 교체하는게 좋은지 말할 수도 없고, 딕셔너리에 이미 있는 키가 주어져도 값을 찾을 수 없을 겁니다.

이 필수 조건을 강제하는 건 `Dictionary` 의 키 타입에 대한 타입 구속 조건인데, 이는 키 타입이 반드시, 스위프트 표준 라이브러리에서 정의한 특수한 프로토콜인, `Hashable` 프로토콜을 따라야 한다고 지정합니다. 스위프트의 모든 기초 타입 (인 `String`, `Int`, `Double`, 및 `Bool` 같은 것) 들은 기본적으로 해시 가능합니다. 자신만의 타입이 `Hashable` 프로토콜을 따르게 만드는 것에 대한 정보는, [Conforming to the Hashable Protocol](https://developer.apple.com/documentation/swift/hashable#2849490)[^conforming] 을 참고하기 바랍니다.

자신의 타입 구속 조건은 자신만의 일반화 타입을 생성할 때 정의할 수 있으며, 이 구속 조건들이 일반화 프로그래밍[^generic-programming] 의 대부분의 강력함을 제공합니다. `Hashable` 같은 추상적인 개념 (abstract concepts) 은 타입의 성격을, 고정 타입 (concrete type) 보단, 개념적인 성질 (conceptual characteristics) 로써 정합니다.[^conceptual-characteristics]

#### Type Constraint Syntax (타입 구속 조건 구문)

타입 구속 조건을 작성하려면 단 하나의 클래스 또는 프로토콜 구속 조건을 타입 매개 변수의 이름 뒤에, 콜론으로 구분해서, 타입 매개 변수 목록 부분에 두면 됩니다. 일반화 함수에 대한 타입 구속 조건의 기본 구문을 보면 아래와 같습니다 (구문이 일반화 타입과 똑같긴 합니다):

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
  // 함수 본문은 여기에 둠
}
```

위에 있는 가상의 함수엔 두 개의 타입 매개 변수가 있습니다. 첫 번째 타입 매개 변수인, `T`, 에 있는 타입 구속 조건은 `T` 가 `SomeClass` 의 하위 클래스이길 요구합니다. 두 번째 타입 매개 변수인, `U`, 에 있는 타입 구속 조건은 `U` 가 `SomeProtocol` 프로토콜을 따르길 요구합니다.

#### Type Constraints in Action (타입 구속 조건의 실제 사례)

여기 있는 일반화 아닌 함수 `findIndex(ofString:in:)` 에는, `String` 값을 줘서 `String` 값의 배열 안에 그게 있는 지를 찾습니다. `findIndex(ofString:in:)` 함수는 옵셔널 `Int` 값을 반환하는데, 문자열을 찾았으면 배열에서 첫번째로 맞은 문자열의 색인일거고, 못찾았으면 `nil` 일겁니다:

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
  for (index, value) in array.enumerated() {
    if value == valueToFind {
      return index
    }
  }
  return nil
}
```

`findIndex(ofString:in:)` 함수를 쓰면 문자열 배열에 있는 문자열 값을 찾을 수 있습니다:

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findIndex(ofString: "llama", in: strings) {
  print("The index of llama is \(foundIndex)")
}
// "The index of llama is 2" 를 인쇄함
```

하지만, 배열에서 값의 색인을 찾는 원리가 문자열에만 유용한 건 아닙니다. 똑같은 기능을 일반화 함수로 작성하려면 문자열이라고 언급한 어떤 곳이든 그 대신 어떠한 타입 `T` 라고 대체하면 됩니다.

여기서 `findIndex(ofString:in:)` 의 일반화 버전이라고 예상했을, `findIndex(of:in:)` 를, 작성해보면 이렇습니다. 이 함수의 반환 타입은 여전히 `Int?` 이라는 걸 알아둬야 하는데, 함수가 반환하는게 옵셔널 색인 번호이지, 배열 안의 옵셔널 값이 아니기 때문입니다. 경고하는데, 허나-이 함수는 컴파일되지 않으며, 그 이유는 예제 뒤에서 설명합니다:

```swift
func findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {
  for (index, value) in array.enumerated() {
    if value == valueToFind {
      return index
    }
  }
  return nil
}
```

이 함수는 위에서 썼듯이 컴파일되지 않습니다. 문제는 같음 비교 검사인, "`if value == valueToFind`" 에 있습니다. 스위프트의 모든 타입을 같음 비교 연산자 (`==`) 로 비교할 수 있는 건 아닙니다. 자신만의 클래스나 구조체를 생성하여 복잡한 데이터 모델을 나타냈다면, 예를 들어, 그 땐 그 클래스나 구조체의 "같음 (equal to)" 의 의미는 스위프트가 추측할 수 있는게 아닙니다. 이 때문에, 이 코드가 _모든 (every)_ 가능한 타입 `T` 와 작업할 거라는 보증이 불가능하여, 코드를 컴파일하려 할 때 적절한 에러를 보고하게 됩니다.

하지만, 모든 걸 잃은 건 아닙니다. 스위프트 표준 라이브러리에서 정의한 프로토콜인 `Equatable` 은, 이를 따르는 어떠한 타입이든 같음 비교 연산자 (`==`) 와 같지 않음 비교 연산자 (`!=`) 를 구현하길 요구하여 그 타입의 두 값은 어떤 것이든 비교하도록 합니다. 스위프트의 모든 표준 타입은 `Equatable` 프로토콜을 자동으로 지원합니다.

`Equatable` 인 어떤 타입이든 안전하게 `findIndex(of:in:)` 함수와 쓸 수 있는데, 이게 같음 비교 연산자를 지원한다는 걸 보증하기 때문입니다. 이 사실을 표현하고자, 함수를 정의할 때 타입 구속 조건인 `Equatable` 을 타입 매개 변수의 정의 부분에 작성합니다:

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {
  for (index, value) in array.enumerated() {
    if value == valueToFind {
      return index
    }
  }
  return nil
}
```

`findIndex(of:in:)` 에 있는 단 하나의 타입 매개 변수는 `T: Equatable` 이라 쓰며, 이는 "`Equatable` 프로토콜을 따르는 어떠한 타입 `T`" 라는 의미입니다.

`findIndex(of:in:)` 함수는 이제 컴파일이 성공하며 `Equatable` 인 어떤 타입과도 쓸 수 있어, `Double` 이나 `String` 과도 쓸 수 있습니다:

```swift
let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])
// doubleIndex 는 값이 없는 옵셔널 Int 인데, 이는 배열에 9.3 이 없기 때문임
let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"])
// stringIndex 는 2 라는 값을 담고 있는 옵셔널 Int 임
```

### Associated Types (결합 타입)

프로토콜을 정의할 때, 하나 이상의 결합 타입을 프로토콜 정의 부분에 선언해 두는게 유용할 때가 있습니다. _결합 타입 (associated type)_ 은 자리 표시용 이름[^placeholder-name] 을 타입에 주서 이를 프로토콜 부분에서 쓰는 겁니다. 그 결합 타입에 쓸 실제 타입은 프로토콜이 채택되기 전까진 지정되지 않습니다. 결합 타입의 지정은 `associatedtype` 키워드로 합니다.[^associated-type]

#### Associated Types in Action (결합 타입의 실제 사례)

여기 있는 `Container` 라는 프로토콜 예제는, `Item` 이라는 결합 타입을 선언합니다:

```swift
protocol Container {
  associatedtype Item
  mutating func append(_ item: Item)
  var count: Int { get }
  subscript(i: Int) -> Item { get }
}
```

`Container` 프로토콜에서 정의한 세 개의 필수 능력 (required capabilities) 은 어떤 컨테이너라도 반드시 제공해야 합니다:

* `append(_:)` 메소드로 컨테이너에 새로운 항목을 추가하는 게 가능해야 합니다.
* `Int` 값을 반환하는 `count` 속성을 통해 컨테이너의 항목 개수에 접근하는 게 가능해야 합니다.
* `Int` 색인 값을 입력받는 첨자로 컨테이너에 있는 각각의 항목을 가져오는 게 가능해야 합니다.

이 프로토콜은 항목을 컨테이너에 어떻게 저장해야 하는지나 허용된 타입이 무엇인지에 대해선 지정하지 않습니다. 프로토콜에서 지정하는 건 어떤 타입이든 `Container` 라고 하기 위해선 반드시 제공해야 할 세 조각의 기능뿐입니다. 이를 따르는 타입은, 이 세 필수 조건들을 만족하는 한, 추가 기능을 제공할 수도 있습니다.

`Container` 프로토콜을 따르는 어떠한 타입이든 반드시 자신이 저장할 값의 타입을 지정할 수 있어야 합니다. 특히, 올바른 타입의 항목만 반드시 컨테이너에 추가된다는 확신을 줘야 하며, 첨자에서 반환될 항목도 반드시 타입이 명확해야 합니다.

이러한 필수 조건을 정의하려면, `Container` 프로토콜이, 특정 컨테이너가 들고 있을 원소의 타입이 뭔지 알지 못한 채로, 그 타입을 참조할 방법이 필요합니다. `Containter` 프로토콜은 `append(_:)` 메소드로 전달될 어떠한 값의 타입이든 반드시 컨테이너의 원소 타입과 똑같을 것과, 컨테이너의 첨자에서 반환될 값의 타입이 반드시 컨테이너의 원소 타입과 똑같을 것을, 지정할 필요가 있습니다.

이를 이루기 위해, `Container` 프로토콜은 결합 타입인 `Item` 을 선언하는데, `associatedtype Item` 이라고 씁니다. 프로토콜은 `Item` 이 뭔지는 정의하지 않습니다-그 정보는 이를 따르는 타입이 제공하도록 내버려둡니다. 그럼에도 불구하고, `Item` 이란 별명은 `Container` 에 있는 항목의 타입을 참조하고, `append(_:)` 메소드와 첨자에서 쓸 타입을 정의하여, 어떠한 `Container` 든 동작이 예상대로 강제된다는 확신을 줄, 방법을 제공합니다.

여기 있는 건 위의 [Generic Types (일반화 타입)](#generic-types-일반화-타입) 에 있는 일반화 아닌 버전의 `IntStack` 타입을, 개조하여 `Container` 프로토콜을 따르게 한 겁니다:

```swift
struct IntStack: Container {
  // 원본 IntStack 의 구현
  var items = [Int]()
  mutating func push(_ item: Int) {
    items.append(item)
  }
  mutating func pop() -> Int {
    return items.removeLast()
  }
  // Container 프로토콜을 따르게 하는 것
  typealias Item = Int
  mutating func append(_ item: Int) {
    self.push(item)
  }
  var count: Int {
    return items.count
  }
  subscript(i: Int) -> Int {
    return items[i]
  }
}
```

`IntStack` 타입은 `Container` 프로토콜의 세 필수 조건을 모두 구현하며, 각 경우마다 `IntStack` 타입에 이미 있던 기능 부분을 감싸는 식으로 이 필수 조건들을 만족하고 있습니다.

게다가, `IntStack` 은 이번 `Container` 구현에서, 쓸 적절한 `Item` 은 `Int` 타입이라는 것도 지정합니다. `typealias Item = Int` 라고 정의하는 건 이 `Container` 프로토콜 구현의 추상 타입인 `Item` 을 고정 타입인 `Int` 로 바꿉니다.

스위프트의 타입 추론 장치에 감사하게도, 실제로는 `Item` 으로 고정된게 `Int` 라는 걸 `IntStack` 정의 부분에서 선언할 필요가 없습니다.[^type-inference] `IntStack` 이 `Container` 프로토콜의 모든 필수 조건을 따르고 있기 때문에, 스위프트에서 쓸 적절한 `Item` 의 추론은, 단순히 `append(_:)` 메소드의 `item` 매개 변수 타입과 첨자의 반환 타입을 살펴 보면 됩니다. 진짜로, 위에 있는 코드의 `typealias Item = Int` 줄을 삭제해도, 모든게 여전히 작동하는데, `Item` 으로 써야할 타입이 뭔지 명확하기 때문입니다.

일반화 `Stack` 타입이 `Container` 프로토콜을 따르도록 할 수도 있습니다:

```swift
struct Stack<Element>: Container {
  // 원본 Stack<Element> 의 구현
  var items = [Element]()
  mutating func push(_ item: Element) {
    items.append(item)
  }
  mutating func pop() -> Element {
    return items.removeLast()
  }
  // Container 프로토콜을 따르게 하는 것
  mutating func append(_ item: Element) {
    self.push(item)
  }
  var count: Int {
    return items.count
  }
  subscript(i: Int) -> Element {
    return items[i]
  }
}
```

이번에는, 타입 매개 변수인 `Element` 를 `append(_:)` 메소드의 `item` 매개 변수 타입과 첨자의 반환 타입으로 썼습니다. 그러므로 스위프트가 이 특별한 컨테이너에서 `Item` 으로 쓸 적절한 타입이 `Element` 라는 걸 추론할 수 있습니다.

#### Extending an Existing Type to Specify an Associated Type (이미 있던 타입을 확장하여 결합 타입 지정하기)

기존에 이미 있던 타입을 확장하여 프로토콜을 따르게 할 수 있는데, [Adding Protocol Conformance with an Extension (익스텐션으로 프로토콜을 따르게 하기)]({% link docs/swift-books/swift-programming-language/protocols.md %}#adding-protocol-conformance-with-an-extension-익스텐션으로-프로토콜을-따르게-하기) 에서 설명합니다. 여기엔 결합 타입이 있는 프로토콜도 포함되빈다.

스위프트의 `Array` 타입은 이미 제공된 `append(_:)` 메소드와, `count` 속성, 및 `Int` 색인으로 자신의 원소를 가져옵니다. 이 세 개의 능력은 `Container` 프로토콜의 필수 조건과 들어 맞습니다. 이것은 `Array` 를 확장해서 `Container` 프로토콜을 따르게 하려면 단순히 그 `Array` 가 프로토콜을 채택한다고 선언하기만 하면 된다는 의미입니다. 이는 빈 익스텐션으로 하는데, [Declaring Protocol Adoption with an Extension (익스텐션으로 프로토콜 채택한다고 선언하기)]({% link docs/swift-books/swift-programming-language/protocols.md %}#declaring-protocol-adoption-with-an-extension-익스텐션으로-프로토콜-채택-선언하기) 에서 설명합니다:

```swift
extension Array: Container {}
```

`Array` 에 이미 있던 `append(_:)` 메소드와 첨자는, 그냥 위에 있던 일반화 `Stack` 타입 처럼, 스위프트가 `Item` 에 쓸 적절한 타입을 추론할 수 있게 합니다. 이 익스텐션을 정의한 후엔, 어떠한 `Array` 든 `Container` 로 쓸 수 있습니다.

#### Adding Constraints to an Associated Type (결합 타입에 구속 조건 추가하기)

프로토콜에 있는 결합 타입에 타입 구속 조건을 추가하여 그걸 따르는 타입이 구속 조건들을 만족하도록 요구할 수 있습니다. 예를 들어, 다음 코드에서 정의한 `Container` 버전은 컨테이너 안의 항목이 같음 비교가 가능하길 요구합니다:[^equatable]

```swift
protocol Container {
  associatedtype Item: Equatable
  mutating func append(_ item: Item)
  var count: Int { get }
  subscript(i: Int) -> Item { get }
}
```

이 버전의 `Container` 를 따르려면, 컨테이너의 `Item` 타입이 `Equatable` 프로토콜을 따라야 합니다.

#### Using a Protocol in Its Associated Type's Constraints (자신의 결합 타입 구속 조건 안에서 프로토콜 사용하기)

프로토콜은 자기 자신의 필수 조건 부분에 나타날 수 있습니다. 예를 들어, 여기 있는 프로토콜은 `Container` 프로토콜을 개량한 건데, 필수 조건으로 `suffix(_:)` 메소드를 추가합니다. `suffix(_:)` 메소드는 컨테이너의 끝에서부터 주어진 개수의 원소를 반환하는데, 이들을 `Suffix` 타입의 인스턴스에 저장하ㄴ고 있습니다.

```swift
protocol SuffixableContainer: Container {
  associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
  func suffix(_ size: Int) -> Suffix
}
```

이 프로토콜에서, `Suffix` 는 결합 타입으로, 위의 `Containter` 예제에 있는 `Item` 타입 같은 겁니다. `Suffix` 엔 두 개의 구속 조건이 있는데: 반드시 `SuffixableContainer` 프로토콜 (현재 정의 중인 프로토콜) 을 따라야 한다는 것과, 반드시 자신의 `Item` 타입과 컨테이너의 `Item` 타입이 똑같아야 한다는 것입니다. `Item` 에 대한 구속 조건은 일반화 `where` 절인데, 이는 아래에 있는 [Associated Types with a Generic Where Clause (일반화 where 절이 있는 결합 타입)](#associated-types-with-a-generic-where-clause-일반화-where-절이-있는-결합-타입) 에서 논의합니다.

여기 있는 건 위의 [Generic Types (일반화 타입)](#generic-types-일반화-타입) 에 있는 `Stack` 타입의 익스텐션으로 `SuffixableContainer` 프로토콜을 따르고 있습니다:

```swift
extension Stack: SuffixableContainer {
  func suffix(_ size: Int) -> Stack {
    var result = Stack()
    for index in (count-size)..<count {
      result.append(self[index])
    }
    return result
  }
  // Suffix 는 Stack 으로 추론됨.
}
var stackOfInts = Stack<Int>()
stackOfInts.append(10)
stackOfInts.append(20)
stackOfInts.append(30)
let suffix = stackOfInts.suffix(2)
// suffix 는 20 과 30 을 담고 있음
```

위 예제에서, `Stack` 의 결합 타입인 `Suffix` 도 `Stack` 이어서, `Stack` 에 대한 접미사 (suffix) 연산 역시 또 다른 `Stack` 를 반환합니다. 대안으로, `SuffixableContainer` 를 따르는 타입이 그 자신과는 다른 `Suffix` 타입을 가질 수 있는데-이는 접미사 연산이 다른 타입을 반환할 수 있다는 의미입니다. 예를 들어, 여기 있는 일반화 아닌 `IntStack` 타입의 익스텐션은 `SuffixableContainer` 를 따르도록 했는데, 자신의 접미사 타입으로 `IntStack` 대신 `Stack<Int>` 를 사용합니다:

```swift
extension IntStack: SuffixableContainer {
  func suffix(_ size: Int) -> Stack<Int> {
    var result = Stack<Int>()
    for index in (count-size)..<count {
      result.append(self[index])
    }
    return result
  }
  // Suffix 는 Stack<Int> 로 추론됨.
}
```

### Generic Where Clauses (일반화 'where' 절)

타입 구속 조건은, [Type Constraints (타입 구속 조건)](#type-constraints-타입-구속-조건) 에서 설명하듯, 일반화 함수나, 첨자, 또는 타입과 결합된 타입 매개 변수에 대해서 필수 조건을 정의할 수 있도록 합니다.

결합 타입에 대해서도 필수 조건을 정의하는게 유용할 수 있습니다. 이렇게 하려면 _일반화 where 절 (generic where clause)_ 을 정의하면 됩니다. 일반화 `where` 절은 결합 타입이 반드시 특정한 프로토콜을 따라야 한다거나, 특정한 타입 매개 변수와 결합 타입이 반드시 똑같아야 한다는 걸 요구할 수 있도록 합니다. 일반화 `where` 절은 `where` 키워드로 시작해서, 그 뒤에 결합 타입에 대한 구속 조건이나 타입과 결합 타입 간의 같음 관계가 따라옵니다. 일반화 `where` 절은 타입이나 함수 본문을 여는 중괄호 바로 앞에 작성합니다.

아래 예제에서 정의한 `allItemsMatch` 라는 일반화 함수는, 두 개의 `Container` 인스턴스에 똑같은 항목이 똑같은 순서로 담겨 있는지를 검사합니다. 함수는 모든 항목이 맞으면 불리언 값인 `true` 를 그렇지 않으면 `false` 값을 반환합니다.

검사할 두 컨테이너가 똑같은 타입의 컨테이너는 아니더라도 (물론 그럴 수도 있지만), 똑같은 타입의 항목은 들고 있어야 합니다. 이런 필수 조건은 타입 구속 조건과 일반화 `where` 절의 조합을 통하여 표현됩니다:

```swift
func allItemsMatch<C1: Container, C2: Container>
  (_ someContainer: C1, _ anotherContainer: C2) -> Bool
  where C1.Item == C2.Item, C1.Item: Equatable {

  // 두 컨테이너에 담긴 항목의 개수가 똑같은지 검사함
  if someContainer.count != anotherContainer.count {
    return false
  }

  // 각 항목을 짝지어 검사해서 이들이 같다고 할 수 있는지 검사함
  for i in 0..<someContainer.count {
    if someContainer[i] != anotherContainer[i] {
      return false
    }
  }

  // 모든 항목이 맞아서, 참을 반환함
  return true
}
```

이 함수는 `someContainer` 와 `anotherContainer` 라는 두 개의 인자를 입력 받습니다. `someContainer` 인자는 타입이 `C1` 이고, `anotherContainer` 인자는 타입이 `C2` 입니다. `C1` 과 `C2` 둘 다 두 컨테이너 타입의 타입 매개 변수라서 함수가 호출될 때 결정됩니다.

다음의 필수 조건들이 함수의 두 타입 매개 변수에 놓여져 있습니다:

* `C1` 은 반드시 `Container` 프로토콜을 따라야 합니다 (`C1: Container` 라고 쎴음).
* `C2` 도 반드시 `Container` 프로토콜을 따라야 합니다 (`C2: Container` 라고 썼음).
* `C1` 의 `Item` 은 반드시 `C2` 의 `Item` 과 똑같아야 합니다 (`C1.Item == C2.Item` 이라고 썼음).[^items]
* `C1` 의 `Item` 은 반드시 `Equatable` 프로토콜을 따라야 합니다 (`C1.Item: Equatable` 이라고 썼음).

첫 번째와 두 번째 필수 조건은 함수의 타입 매개 변수 목록에 정의되어 있고, 세 번째와 네 번째 필수 조건은 함수의 일반화 `where` 절에 정의되어 있습니다.

이 필수 조건들의 의미는 이렇습니다:

* `someContainer` 는 `C1` 타입의 컨테이너입니다.
* `anotherContainer` 는 `C2` 타입의 컨테이너입니다.
* `someContainer` 와 `anotherContainer` 는 똑같은 타입의 항목을 담고 있습니다.
* `someContainer` 에 있는 항목을 같지 않음 연산자 (`!=`) 로 검사해서 서로 다른 건지 확인할 수 있습니다.

세 번째와 네 번째 필수 조건을 조합하면 `anotherContainer` 의 항목 _도 (also)_ `!=` 연산자로 검사할 수 있다는 의미가 되는데, 이들도 `someContainer` 안의 항목과 정확하게 똑같은 타입이기 때문입니다.

이러한 필수 조건들은 `allItemsMatch(_:_:)` 함수가 두 개의 컨테이너를 비교할 수 있게 하는데, 심지어 이들이 서로 다른 컨테이너 타입이라도 그렇습니다.

`allItemsMatch(_:_:)` 함수는 두 개의 컨테이너에 똑같은 개수의 항목이 담겼는지 검사하는 걸로 시작합니다. 서로 다른 개수의 항목이 담겼다면, 서로 맞을 수가 없으므로, 함수가 `false` 를 반환합니다.

이걸 검사한 후에, 함수는 `someContainer` 안에 있는 모든 항목들을 `for-in` 반복문과 반-열린 범위 연산자 (`..<`)[^half-open-range-operator] 로 반복합니다. 각각의 항목마다, 함수는 `someContainer` 에 있는 항목이 `anotherContainer` 에 있는 해당 항목과 같지 않은지 검사합니다. 두 항목이 같지 않다면, 두 컨테이너가 맞지 않는 것이고, 함수는 `false` 를 반환합니다.

안맞는 걸 못찾고 반복문을 마치면, 두 컨테이너가 맞는 것이라, 함수가 `true` 를 반환합니다.

`allItemsMatch(_:_:)` 함수의 실 사례를 보면 이렇습니다:

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
  print("All items match.")
} else {
  print("Not all items match.")
}

// "All items match." 를 인쇄함
```

위 예제는 `String` 값을 저장하는 `Stack` 인스턴스를 생성하여, 세 문자열을 스택에 밀어 넣습니다. 예제에선 `Array` 인스턴스도 생성하여 스택과 똑같은 세 문자열이 담긴 배열 글자 값[^literal] 으로 초기화합니다. 스택과 배열은 서로 다른 타입일지라도, 둘 다 `Container` 프로토콜을 따르며, 둘 다 똑같은 타입의 값을 담고 있습니다. 그러므로 `allItemsMatch(_:_:)` 함수를 이 두 컨테이너를 인자로 호출할 수 있습니다. 위 예제에서, `allItemsMatch(_:_:)` 함수는 두 컨테이터에 있는 모든 항목이 들어 맞는다고 올바르게 보고합니다.

### Extensions with a Generic Where Clause (일반화 where 절이 있는 익스텐션)

일반화 `where` 절을 익스텐션 부분에 쓸 수도 있습니다. 아래 예제는 이전 예제에 있던 일반화 `Stack` 구조체를 확장하여 `isTop(_:)` 메소드를 더합니다.

```swift
extension Stack where Element: Equatable {
  func isTop(_ item: Element) -> Bool {
    guard let topItem = items.last else {
      return false
    }
    return topItem == item
  }
}
```

이 새로운 `isTop(_:)` 메소드는 첫 번째로 스택이 비었는지 검사하고, 그런 다음엔 주어진 항목을 스택의 가장 윗 항목과 비교합니다. 이걸 일반화 `where` 절 없이 하려고 하면, 문제가 생기는데: `isTop(_:)` 구현에서 `==` 연산자를 쓰고 있지만, `Stack` 의 정의에선 항목의 같음 비교가 가능해야 한다고 요구하지 않아서, `==` 연산자를 쓰는 결과가 컴파일-시간 에러가 될거라는 겁니다. 일반화 `where` 절을 쓰는 건 새로운 필수 조건을 익스텐션에 추가해서, 스택 안에 있는 항목이 비교 가능할 때만 익스텐션이 `isTop(_:)` 메소드를 추가하도록 해줍니다.

여기서 `isTop(_:)` 메소드의 실 사례를 보면 이렇습니다:

```swift
if stackOfStrings.isTop("tres") {
  print("Top element is tres.")
} else {
  print("Top element is something else.")
}
// "Top element is tres." 를 인쇄함
```

원소의 같음 비교가 불가능한 스택에 대해서 `isTop(_:)` 메소드를 호출하려고 하면, 컴파일-시간 에러를 갖게 됩니다:

```swift
struct NotEquatable { }
var notEquatableStack = Stack<NotEquatable>()
let notEquatableValue = NotEquatable()
notEquatableStack.push(notEquatableValue)
notEquatableStack.isTop(notEquatableValue)  // 에러
```

프로토콜의 익스텐션에 일반화 `where` 절을 사용할 수 있습니다. 아래 예제는 이전 예제의 `Container` 프로토콜을 확장하여 `startWith(_:)` 메소드를 추가합니다.

```swift
extension Container where Item: Equatable {
  func startsWith(_ item: Item) -> Bool {
    return count >= 1 && self[0] == item
  }
}
```

`startsWith(_:)` 메소드는 먼저 컨테이너에 적어도 하나의 항목을 있는지 확실히 한 다음, 컨테이너의 첫 번째 항목과 주어진 항목이 일치하는 지를 검사합니다. 이 새로운 `startsWith(_:)` 메소드는, 컨테이터 항목이 비교 가능한 한, 위에서 사용한 스택과 배열을 포함하여, `Container` 프로토콜을 준수한 어떤 타입과도 사용할 수 있습니다.

```swift
if [9, 9, 9].startsWith(42) {
  print("Starts with 42.")
} else {
  print("Starts with something else.")
}
// "Starts with something else." 를 인쇄함
```

위 예제의 일반화 `where` 절은 `Item` 이 프로토콜을 준수하길 요구하지만, `Item` 이 정해진 타입이길 요구하는 일반화 `where` 절도 작성할 수 있습니다. 예를 들면 다음과 같습니다:

```swift
extension Container where Item == Double {
  func average() -> Double {
    var sum = 0.0
    for index in 0..<count {
      sum += self[index]
    }
    return sum / Double(count)
  }
}
print([1260.0, 1200.0, 98.6, 37.0].average())
// "648.9" 를 인쇄함
```

이 예제는 자신의 `Item` 타입이 `Double` 인 컨테이너에 `average()` 메소드를 추가합니다. 이는 컨테이너 항목을 반복하여 더하고, 컨테이너 횟수로 나누어 평균을 계산합니다. 횟수를 명시적으로 `Int` 에서 `Double` 로 변환하여 부동-소수점 나누기가 가능하게 합니다.

익스텐션의 일부인 일반화 `where` 절은, 그냥 다른 곳에서 작성한 일반화 `where` 절이 그런 것 같이, 여러 개의 필수 조건을 포함할 수 있습니다. 목록에서 각각의 필수 조건은 쉼표로 구분합니다.

### Contextual Where Clauses (상황별 where 절)

이미 일반화 타입인 상황에서 작업할 때는, 자기 자신의 일반화 타입 구속 조건이 없는 선언에서 일반화 `where` 절을 작성할 수 있습니다. 예를 들어, 일반화 타입의 첨자에서 또는 일반화 타입의 익스텐션에 있는 메소드에서 일반화 `where` 절을 작성할 수 있습니다. 아래 예제에서, `Container` 구조체는 일반화 (구조체) 이고, `where` 절은 무슨 타입 구속 조건을 만족해야 이 새로운 메소드를 컨테이너에서 사용할 수 있는 지 지정합니다.

```swift
extension Container {
  func average() -> Double where Item == Int {
    var sum = 0.0
    for index in 0..<count {
      sum += Double(self[index])
    }
    return sum / Double(count)
  }
  func endsWith(_ item: Item) -> Bool where Item: Equatable {
    return count >= 1 && self[count-1] == item
  }
}
let numbers = [1260, 1200, 98, 37]
print(numbers.average())
// "648.75" 를 인쇄함
print(numbers.endsWith(37))
// "true" 를 인쇄함
```

이 예제는 항목이 정수일 땐 `Container` 에 `average()` 메소드를 추가하고, 항목이 비교 가능할 땐 `endsWith(_:)` 메소드를 추가합니다. 함수 둘 다 일반화 `where` 절을 포함하여 원본 `Container` 선언의 일반화 `Item` 타입 매개 변수에 타입 구속 조건을 추가합니다.

상황별 `where` 절의 사용 없이 이 코드를 작성하고 싶으면, 각각의 일반화 `where` 절마다 하나씩, 두 개의 익스텐션을 작성합니다. 위 예제와 아래 예제의 동작은 똑같습니다.

```swift
extension Container where Item == Int {
  func average() -> Double {
    var sum = 0.0
    for index in 0..<count {
      sum += Double(self[index])
    }
    return sum / Double(count)
  }
}
extension Container where Item: Equatable {
  func endsWith(_ item: Item) -> Bool {
    return count >= 1 && self[count-1] == item
  }
}
```

상황별 `where` 절을 사용한 이 예제 버전에서, `average()` 와 `endsWith(_:)` 구현은 둘 다 동일한 익스텐션 안에 있는데 이는 각 메소드의 일반화 `where` 절이 그 메소드를 사용하려면 만족해야 할 필수 조건을 알려주기 때문입니다. 이러한 필수 조건을 익스텐션의 일반화 `where` 절로 옮기면 동일한 상황에서 메소드를 사용하게 하지만, 필수 조건마다 하나의 익스텐션을 요구합니다.

### Associated Types with a Generic Where Clause (일반화 where 절이 있는 결합 타입)

결합 타입은 일반화 `where` 절을 포함할 수 있습니다. 예를 들어 반복자[^iterator] 를 포함한, 표준 라이브러리의 `Sequence` 프로토콜이 사용하는 것 같은, 버전의 `Container` 를 만들고 싶다고 가정합니다. 그걸 작성하는 방법은 이렇습니다:

```swift
protocol Container {
  associatedtype Item
  mutating func append(_ item: Item)
  var count: Int { get }
  subscript(i: Int) -> Item { get }

  associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
  func makeIterator() -> Iterator
}
```

`Iterator` 의 일반화 `where` 절은 반복자가, 반복자 타입에는 상관없이, 반드시 컨테이너 항목과 동일한 항목 타입의 원소 사이를 오고 가길 요구합니다. `makeIterator()` 함수는 컨테이너의 반복자에 대한 접근을 제공합니다.

또 다른 프로토콜을 상속한 프로토콜에서, 상속한 결합 타입에 구속 조건을 추가하려면 프로토콜 선언에 일반화 `where` 절을 포함하면 됩니다. 예를 들어, 다음 코드가 선언한 `ComparableContianer` 프로토콜은 `Item` 이 `Comparable` 을 준수하길 요구합니다:

```swift
protocol ComparableContainer: Container where Item: Comparable { }
```

### Generic Subscripts (일반화 첨자)

첨자는 일반화일 수 있으며, 일반화 `where` 절을 포함할 수 있습니다. 자리 표시용 타입 이름은 `subscript` 뒤의 꺾쇠 괄호 안에 작성하며, 일반화 `where` 절은 첨자 본문을 여는 중괄호 바로 앞에 작성합니다. 예를 들면 다음과 같습니다:

```swift
extension Container {
  subscript<Indices: Sequence>(indices: Indices) -> [Item]
    where Indices.Iterator.Element == Int {
      var result = [Item]()
      for index in indices {
        result.append(self[index])
      }
      return result
  }
}
```

이 `Container` 프로토콜 익스텐션이 추가한 첨자는 일렬로 나열된 색인을 취해서 각각의 주어진 색인 위치의 항목을 담은 배열을 반환합니다. 이 일반화 첨자의 구속 조건은 다음과 같습니다:

* 꺽쇠 괄호 안의 `Indices` 일반화 매개 변수[^generic-parameter] 는 표준 라이브러리의 `Sequence` 프로토콜을 준수한 타입이어야 합니다.
* 첨자는, 그 `Indices` 타입의 인스턴스인, `indices` 라는, 단일 매개 변수를 취합니다.
* 일반화 `where` 절은 시퀀스의 반복자가 반드시 `Int` 타입의 원소 사이를 오고 가길 요구합니다. 이는 시퀀스에 있는 색인이 컨테이너에서 사용할 색인과 동일한 타입임을 보장합니다.

함께 취합해보면, 이 구속 조건들은 `indices` 매개 변수에 전달한 값은 일렬로 나열된 정수들이라는 걸 의미합니다.

### 다음 장

[Opaque Types (불투명 타입) >]({% link docs/swift-books/swift-programming-language/opaque-types.md %})

### 참고 자료

{% include footer_swift_book.md %} 이 장의 원문은 [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html) 에서 볼 수 있습니다.

[^language-guide]: **언어 설명서** 는 **스위프트 프로그래밍 언어** 책에서 스위프트 문법을 설명하는 부분으로, [이 곳]({% link docs/swift-books/swift-programming-language/index.md %}#language-guide-언어-설명서) 에서 확인할 수 있습니다. 지금 보고 있는 글도 언어 설명서 안에 있는 겁니다.

[^genenric-colletion]: '일반화 집합체 (generic collections)' 는 집합체의 원소가 일반화 타입인 집합체를 의미입니다.

[^type-annotation]: '타입 보조 설명 (type annotation)' 은 `let a: Int` 에서의 `Int` 처럼 해당 속성의 타입을 설명하는 것을 말합니다. 타입 보조 설명에 대한 더 자세한 정보는 [The Basics (기초)]({% link docs/swift-books/swift-programming-language/the-basics.md %}) 장의 [Type Annotations (타입 보조 설명)]({% link docs/swift-books/swift-programming-language/the-basics.md %}#type-annotations-타입-보조-설명) 절을 참고하기 바랍니다.

[^upper-camel-case]: '낙타 모양 대문자 (upper camel case)' 는 스위프트에서 사용하는 타입 이름이 **낙타 등 모양** 처럼 생겼기 때문에 붙은 이름입니다. 낙타 모양 대문자에 대한 더 자세한 설명은, [Structures and Classes (구조체와 클래스)]({% link docs/swift-books/swift-programming-language/structures-and-classes.md %}) 장의 [Definition Syntax (정의 구문)]({% link docs/swift-books/swift-programming-language/structures-and-classes.md %}#definition-syntax-정의-구문) 부분을 참고하기 바랍니다.

[^ordered-set]: '순서 있는 집합 (ordered set)' 은 리스트와 비슷하게 각각의 항목을 저장한 순서가 유지되는 집합으로, '정렬된 집합 (sorted set)' 과는 수학적인 의미가 다릅니다. 이 둘의 차이점에 대해서는, **StackOverflow** 의 [What is the difference between an ordered and a sorted collection?](https://stackoverflow.com/questions/1084146/what-is-the-difference-between-an-ordered-and-a-sorted-collection) 항목을 참고하기 바랍니다.

[^restricted]: `Array` 보다 `Stack` 의 연산 집합이 더 제약되어 있다는 건 `Stack` 이 되기 위해선 `Array` 보다 더 많은 조건이 필요하다는 의미이기도 합니다.

[^navigation-hierarchy]: '길찾기 계층 구조 (navigation hierarchy)' 는 특정한 **뷰** 에 이르기까지의 과정을 겹쳐 쌓아 놓은 구조를 말합니다. 최초의 **뷰** 로 돌아가려면 쌓여 있는 모든 **뷰** 들을 닫아야 합니다. 수많은 아이폰 앱들이 이러한 구조로 되어 있는 것을 볼 수 있습니다.

[^navigation-stack]: **SwiftUI** 에서는 `NavigationStack` 이라는 것이 비슷한 역할을 합니다. 이름에서 알 수 있듯이, `NavigationStack` 도 스택을 이용하여 동작합니다.

[^LIFO]: '후입 선출 (last in, first out)' 이라는 용어에 대해서는 위키피디아의 [FIFO and LIFO accounting](https://en.wikipedia.org/wiki/FIFO_and_LIFO_accounting) 항목과 [선입 선출법과 후입 선출법](https://ko.wikipedia.org/wiki/선입_선출법과_후입_선출법) 항목을 참고하기 바랍니다. 이 용어는 컴퓨터가 있기 이전부터 사용되었던 것 같습니다. 컴퓨터 용어의 **LIFO** 를 검색하면 **스택 (stack)** 으로 연결되는데, 이에 대한 더 자세한 정보는, **위키피디아** 의 [Stack (abstract data type)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) 항목과 [스택](https://ko.wikipedia.org/wiki/스택) 항목을 참고하기 바랍니다.

[^type-parameter-list]: '일반화 (generic) 타입' 의 익스텐션을 정의할 때는, 꺽쇠 괄호 부분을 쓰지 않는다는 의미입니다.

[^protocol-composition]: '프로토콜 합성 (protocol composition)' 에 대한 더 자세한 정보는, [Protocols (프로토콜; 규약)]({% link docs/swift-books/swift-programming-language/protocols.md %}) 장에 있는 [Protocol Composition (프로토콜 합성)]({% link docs/swift-books/swift-programming-language/protocols.md %}#protocol-composition-프로토콜-합성) 부분을 보도록 합니다.

[^hashable]: 본문 바로 뒤에서 설명하듯, '해시 가능 (hashable)' 이란, 자신을 유일하게 나타낼 수 있는 방법을 제공할 수 있다는 의미입니다. 해시 가능에 대한 더 자세한 정보는, [Collection Types (집합체 타입)]({% link docs/swift-books/swift-programming-language/collection-types.md %}) 장에 있는 [Hash Values for Set Types (셋 타입의 해시 값)]({% link docs/swift-books/swift-programming-language/collection-types.md %}#hash-values-for-set-types-셋-타입의-해시-값) 부분을 참고하기 바랍니다.

[^conforming]: 원문 자체가 **애플 개발자 문서** 로 가는 링크입니다.

[^generic-programming]: '일반화 프로그래밍 (genenric programming)' 에 대한 더 자세한 정보는, 위키피디아의 [Generic programming](https://en.wikipedia.org/wiki/Generic_programming) 항목을 보도록 합니다.

[^conceptual-characteristics]: '타입의 셩격을, 고정 타입 보단, 개념적인 성질로써 정한다' 는 건 프로그래밍에서의 '덕 타이핑 (duck typing)' 과 비슷한 개념입니다. **덕 타이핑** 에 대한 더 자세한 정보는, 위키피디아의 [Duck typing](https://en.wikipedia.org/wiki/Duck_typing#Templates_or_generic_types) 항목과 [덕 타이핑](https://ko.wikipedia.org/wiki/덕_타이핑) 항목을 참고하기 바랍니다.

[^associated-type]: '결합 타입 (associated types)' 은 프로토콜에서 '일반화 (generic)' 를 구현하는 방법입니다. 프로토콜 그 자체는 타입 매개 변수를 사용할 수 없으므로, 결합 타입을 써서 일반화를 하는 것입니다. 즉, 클래스라면 `class Container<Item> { ... }` 이라고 하는데, 프로토콜은 그럴 수 없으므로 `protocol Container { associatedtype Item; ... }` 이라고 하는 겁니다.

[^placeholder-name]: '자리 표시용 이름 (placeholder name)' 에 대해서는 위에 있는 [Generic Functions (일반화 함수)](#generic-functions-일반화-함수)) 부분을 참고하기 바랍니다.

[^type-inference]: 스위프트의 초창기 문법에선 프로그래머가 수동으로 `typealias Item = Int` 라고 해줘야 했었습니다. 하지만, 최근에는 `append(_ item:)` 함수를 구현하면서 `item:` 타입이 `Int` 라고 하면 스위프트가 알아서 `Item` 이 `Int` 라는 걸 추론하기 때문에 따로 `typealias Item = Int` 라고 쓸 필요가 없어졌습니다.

[^equatable]: 예제 코드의 `associatedtype Item: Equatable` 부분입니다.

[^items]: 이 필수 조건은 항목의 값뿐만 아니라, 타입도 똑같다는 걸 보장하는데, `==` 연산자로 비교하려면 항목의 타입이 서로 똑같아야 하기 때문입니다.

[^half-open-range-operator]: '반-열린 범위 연산자 (half-open range operator)' 에 대한 더 자세한 내용은, [Basic Operators (기초 연산자)]({% link docs/swift-books/swift-programming-language/basic-operators.md %}) 장의 [Half-Open Range Operator (반-열린 범위 연산자)]({% link docs/swift-books/swift-programming-language/basic-operators.md %}#half-open-range-operator-반-열린-범위-연산자) 부분을 보도록 합니다.

[^literal]: '글자 값 (literal)' 에 대해서는, [Lexical Structure (어휘 구조)]({% link docs/swift-books/swift-programming-language/lexical-structure.md %}) 장의 [Literals (글자 값)]({% link docs/swift-books/swift-programming-language/lexical-structure.md %}#literals-글자-값) 부분을 보도록 합니다.

[^iterator]: 컴퓨터 프로그래밍 용어로 '반복자 (iterator)' 는 컨테이너의 항목 사이를 오갈 수 있게 만드는 객체를 의미합니다. 반복자에 대한 더 자세한 정보는, 위키피디아의 [Iterator](https://en.wikipedia.org/wiki/Iterator) 항목과 [반복자](https://ko.wikipedia.org/wiki/반복자) 항목을 보도록 합니다.

[^generic-parameter]: 본문에서 말하는 '일반화 매개 변수 (generic parameter)' 는 '타입 매개 변수 (type parameter)' 를 의미합니다.
