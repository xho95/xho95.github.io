---
layout: post
comments: true
title:  "Swift 5.3: Closures (클로저; 잠금 블럭)"
date:   2020-03-03 11:30:00 +0900
categories: Swift Language Grammar Closure
redirect_from: "/swift/language/grammar/closure/2020/02/29/Closures.html"
---

> Apple 에서 공개한 [The Swift Programming Language (Swift 5.3)](https://docs.swift.org/swift-book/) 책의 [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html) 부분[^Closures]을 번역하고, 설명이 필요한 부분은 주석을 달아서 정리한 글입니다. 전체 번역은 [Swift 5.3: Swift Programming Language (스위프트 프로그래밍 언어)]({% post_url 2017-02-28-The-Swift-Programming-Language %}) 에서 확인할 수 있습니다.

## Closures (클로저; 잠금 블럭)

_클로저 (Closures)_[^closure]는 코드에서 사용도 하고 전달할 수도 있는 독립된 '기능 블럭 (blocks of functionality)' 입니다. 스위프트의 클로저는 C 와 오브젝티브-C 의 '블럭 (blocks)', 그리고 다른 프로그래밍 언어의 '람다식 (lambdas)' 과 비슷합니다.

클로저는 자신이 정의된 영역의 어떤 상수와 변수에 대한 참조도 '붙잡고 (capture)' 저장할 수 있습니다. 이를 보고 해당 상수와 변수를 _잠근다 (closing over)_ 라고 합니다. 스위프트는 '붙잡는 것 (capturing)' 에 대한 모든 메모리 관리를 직접 처리합니다.

> '붙잡기 (capturing)' 라는 개념에 친숙하지 않더라도 걱정할 필요 없습니다. 아래의 [Capturing Values (값 붙잡기)](#capturing-values-값-붙잡기) 에서 자세하게 설명합니다.

'전역 (global) 함수' 와 '중첩 (nested) 함수' 는, [Functions (함수)]({% post_url 2020-06-02-Functions %}) 에서 소개한 것처럼, 실제로는 클로저의 특수한 경우에 해당합니다.[^global-nested-function] 클로저는 세 가지 형식 중 하나를 취합니다:

* '전역 함수' 는 이름은 가지지만 어떤 값도 '붙잡지' 않는 클로저입니다.
* '중첩 함수' 는 이름을 가지며 자신을 감싸는 함수의 값을 '붙잡을' 수 있는 클로저입니다.
* '클로저 표현식 (closure expressions)' 은 자기 주위 영역의 값을 붙잡을 수 있는 가벼운 '구문 표현 (syntax)' 으로 작성한 이름 없는 클로저입니다.

스위프트의 '클로저 표현식' 은, 일반적인 상황에서 간결하고, 번잡하지 않게 구문 표현을 최적화하여, 깔끔하고, 명확한 스타일을 가집니다:

* 영역 내의 매개 변수와 반환 값의 타입을 추론함
* '단일 표현식 (single-expression) 클로저' 는 암시적으로 반환함
* 인자 이름의 '줄임 표현 (shorthand)'[^shorthand]
* '끝자리 클로저 구문 표현 (trailing closure syntax)'[^trailing]

### Closure Expressions (클로저 표현식)

중첩 함수는, [Nested Functions (중첩 함수)]({% post_url 2020-06-02-Functions %}#nested-functions-중첩-함수) 에서 소개한 것처럼, 큰 함수 내에서 '독립된 코드 블럭' 을 정의하고 이름 붙이는 편리한 수단입니다. 하지만, 온전한 선언과 이름 없이도 더 짧은 버전의 함수-같은 구조를 작성하는 것이 유용할 때가 있습니다. 이는 작업하는 함수나 메소드가 하나 이상의 함수를 인자로 취할 때 특히 더 그렇습니다.

_클로저 표현식_ 은 '인라인 클로저 (inline closure)'[^inline-closure] 를 간결하고, 집중된 구문 표현으로 작성하기 위한 방법입니다. '클로저 표현식' 은 분명한 의도를 잃지 않으면서도 클로저를 '줄임 형식 (shorthand form)' 으로 작성하기 위해 여러 가지 구문 표현 최적화를 제공합니다. 아래의 클로저 표현식 예제는 단일 `sort(by:)` 메소드 예제를 여러번 반복하면서, 매 번 똑같은 기능을 더 간결한 방식으로 표현하는, 개량을 함으로써 이러한 최적화를 보여줍니다.

#### The Sorted Method (정렬 메소드)

스위프트의 표준 라이브러리는 `sorted(by:)` 라는 메소드를 제공하는데, 이는, 직접 제공한 '정렬 클로저' 의 출력에 기초하여, 아는 타입의 값 배열을 정렬합니다. 일단 정렬 과정을 한 번 완료하면, `sorted(by:)` 메소드는 예전과 타입과 크기가 같으며, 올바르게 정렬된 순서의 원소를 가진, 새로운 배열을 반환합니다. 원본 배열은 `sorted(by:)` 메소드로 수정되지 않습니다.

아래의 클로저 표현식 예제는 `String` 값의 배열을 알파벳 역순으로 정렬하기 위해 `sorted(by:)` 메소드를 사용합니다. 다음은 정렬되기 전인 초기 배열입니다:

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`sorted(by:)` 메소드는 배열의 '내용물 (contents)' 과 같은 타입인 두 인자를 취하는 클로저를 받아서, 값을 한 번 정렬하면 첫 번째 값이 두 번째 값 앞에 있어야 할지 뒤에 있어야 할지를 말하는 `Bool` 값을 반환합니다. '정렬 클로저' 는 첫 번째 값이 두 번째 값 _앞에_ 있어야 하면 `true` 를 반환하고, 다른 경우 `false` 를 반환할 필요가 있습니다.

이 예제는 `String` 값의 배열을 정렬하므로, 정렬 클로저는 `(String, String) -> Bool` 타입의 함수일 필요가 있습니다.

정렬 클로저를 제공하는 한가지 방법은 올바른 타입의 보통 함수를 작성하여, 이를 `sorted(by:)` 메소드 인자로 전달하는 것입니다:

```swift
func backward(_ s1: String, _ s2: String) -> Bool {
  return s1 > s1
}
var reversedNames = names.sorted(by: backward)
// reversedNames 는 ["Ewa", "Daniella", "Chris", "Barry", "Alex"] 입니다.
```

첫 번째 문자열 (`s1`) 이 두 번째 문자열 (`s2`) 보다 크면, 정렬된 배열에서 `s1` 이 `s2` 앞에 있어야 함을 지시하도록, `backward(_:_:)` 함수가 `true` 를 반환할 것입니다. 문자열의 문자에서, "보다 큼 (greater)" 은 "알파벳에서 보다 더 뒤에 있다" 는 의미입니다. 이는 문자 `"B"` 가 문자 `"A"` "보다 큼" 을 뜻하고, 문자열 `"Tom"` 이 문자열 `"Tim"` "보다 큼" 을 의미합니다. 이는, `"Barry"` 를 `"Alex"` 앞에 두고 하는 것을, 계속해서, 알파벳 역순으로 정렬합니다.

하지만, 이는 본질적으로 '단일-표현식 함수 (`a > b`)' 를 작성하기에는 다소 좀 길고-지루한 방식이긴 합니다. 이 예제에서는, 정렬 클로저를, '클로저 표현식 구문 표현' 을 사용하여, '인라인 (inline)' 으로 작성한다면 더 좋을 것입니다.

#### Closure Expression Syntax (클로저 표현식 구문 표현)

클로저 표현식의 기본 문법은 다음과 같습니다:

{(`parameters (매개 변수)`) -> `return type (반환 타입)` in
  `statements (문장)`
}

클로저 표현식의 _매개 변수_ 는 '입-출력 매개 변수 (in-out parameters)'[^in-out] 여도 상관없지만, 기본 값은 가질 수 없습니다. '가변개수 매개 변수 (variadic parameters)의 이름을 지정했다면 '가변개수 매개 변수' 도 사용할 수 있습니다. '튜플 (tuples)' 도 매개 변수 타입과 반환 타입으로 사용할 수 있습니다.

아래 예제는 위에 있는 `backward(_:_:)` 함수의 클로저 표현식 버전을 보여줍니다:

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
  return s1 > s2
})
```

위의 '인라인 클로저 (inline closure)' 에서 매개 변수와 반환 타입을 선언 하는 부분이 `backward(_:_:)` 함수와 완전히 똑같다는 것에 주목합니다. 두 경우 모두 `(s1: String, s2: String) -> Bool` 로 작성했습니다. 그러나 '인라인 클로저 표현식 (inline closure expression)' 에서는 매개 변수와 리턴 타입이 중괄호 밖이 아니라 _안에_ 적혀 있습니다.

클로저 본문 자체는 `in` 키워드로 시작합니다. 이 키워드는 클로저의 매개 변수와 반환 타입에 대한 정의가 끝났으며, 클로저 본문이 시작될 것임을 알려줍니다.

클로저 본문이 아주 짧으므로, 한 줄로도 작성할 수 있습니다.

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
```

이 전체도 `sorted(by:)` 메소드를 호출하는 기능을 동일하게 유지합니다. 여전히 한 쌍의 중괄호가 메소드의 전체 인자를 감싸고 있습니다. 하지만 이제 이 인자는 '인라인 클로저 (inline closure)' 입니다.

#### Inferring Type From Context (문맥으로 타입 추론하기)

'정렬 클로저' 는 메소드에 인자로 전달되므로, 스위프트가 이 매개 변수들의 타입과 반환하는 값의 타입을 추론할 수 있습니다. `sorted(by:)` 메소드는 문자열 배열에서 호출되므로, 인자는 `(String, String) -> Bool` 타입의 함수일 수 밖에 없을 것입니다. 이 말은 클로저 표현식을 작성할 때 `(String, String)` 이나 `Bool` 같은 타입은 작성할 필요가 없다는 뜻입니다. 모든 타입을 추론할 수 있으므로, '반환 표시 화살표 (`->`)' 와 매개 변수 이름 주위의 괄호도 생략 할 수 있습니다:

```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

클로저를 함수나 메소드에 전달할 때 '삽입 클로저 표현식' 을 쓰면, 매개 변수의 타입과 반환 타입을 항상 추론할 수 있습니다. 결과적으로, 클로저를 함수나 메소드의 인자로 사용할 때는, 이 '삽입 클로저' 를 완전한 형태로 작성할 일이 없습니다.

그럼에도 불구하고, 원한다면 언제든 타입을 명시적으로 나타낼 수도 있고, 또 코드를 읽을 때 모호함을 피하고 싶으면 이렇게 하는게 좋긴 합니다. `sorted(by:)` 메소드의 경우 클로저의 목적이 정렬임이 명확하며, 문자열 배열의 정렬을 지원하고 있으므로 누가 봐도 클로저가 `String` 값을 사용할 것이라고 가정하는 데 별 문제 없습니다.

#### Implicit Returns from Single-Expression Closures (단일-표현식 클로저의 암시적인 반환)

'단일 구문 클로저' 는 선언할 때 `return` 키워드를 생략하면 그 문장이 자동으로 반환되며, 이 방법으로 앞의 예제를 고치면 다음과 같습니다:

```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

여기서 `sorted(by:)` 메소드 인자의 '함수 타입'으로부터, 이 클로저는 반드시 `Bool` 값을 반환할 것임이 분명합니다. 또한 클로저 본문은 `Bool` 값을 반환하는 한 문장의 표현식 (`s1> s2`) 으로 되어 있어서, 헷갈릴 일이 없으므로, `return` 키워드를 생략해도 문제가 없습니다.

#### Shorthand Argument Names (인자 이름으로 약칭 사용하기)

스위프트는 '삽입 클로저' 에 자동으로 인자 이름의 약칭을 제공하기 때문에, 클로저 인자 값을 가리킬 때 `$0`, `$1`, `$2` 등을 사용하면 됩니다.

클로저 표현식 내에서 인자 이름 대신 약칭을 사용하는 경우, 클로저의 '인자 목록 (argument list)' 을 정의에서 생략할 수 있으며, 인자 이름을 대신할 약칭의 개수와 타입은 함수 타입으로부터 추론됩니다. `in` 키워드도 생략 가능한데, 이는 클로저 표현식에 본문 밖에 없기 때문입니다:

```swift
reversedNames = names.sorted(by: { $0 > $1 } )
```

여기서 `$0` 과 `$1` 은 각각 클로저의 첫 번째와 두 번째 `String` 인자를 가리킵니다.

#### Operator Methods (연산자 메소드)

실제로는 위의 클로저 표현식을 더 짧게 작성할 수 있습니다. 스위프트의 `String` 타입은 문자열에 특화된 '보다 큰 연산자 (`>`)' 를 메소드로 자체 정의하고 있는데, 두 개의 `String` 타입 매개 변수를 가지고 `Bool` 타입 값을 반환합니다. 이것은 `sorted(by:)` 메소드에서 요구하는 메소드 타입과 정확히 일치합니다. 따라서 단순히 이 '보다 큰 연산자' 를 전달하기만 하면 스위프트가 알아서 문자열에 특화된 구현으로 추론해서 사용합니다.

```swift
reversedNames = names.sorted(by: >)
```

연산자 메소드에 대한 더 자세한 내용은 [Operator Methods (연산자 메소드)]({% post_url 2020-05-11-Advanced-Operators %}#operator-methods-연산자-메소드) 를 참고하기 바랍니다.

### Trailing Closures (끝자리 클로저)

클로저 표현식을 함수의 최종 인자로써 함수에 전달해야 하는데 그 클로저 표현식이 아주 긴 경우, _끝자리 클로저 (trailing closure)_ 로 대신 작성하는 것이 좋을 수 있습니다. 끝자리 클로저는 함수 호출의 괄호 뒤에 작성하지만, 그럼에도 불구하고 그 끝자리 클로저는 여전히 함수의 인자입니다. '끝자리 클로저 구문 표현 (trailing closure syntax)' 을 사용할 때는, 함수 호출 시에 첫 번째 클로저에 대한 _인자 이름표 (argument label)_ 는 작성하지 않습니다. 함수 호출은 '다중 끝자리 클로저 (multiple trailing closures)' 를 포함할 수 있습니다; 하지만, 아래에 있는 처음 몇몇 예제는 '단일 끝자리 클로저' 를 사용합니다.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
  // 함수 본문을 여기에 둡니다.
}

// 이 함수를 끝자리 클로저를 사용하지 않고 호출하는 방법은 다음과 같습니다:

someFunctionThatTakesAClosure(closure: {
  // 클로저 본문을 여기에 둡니다.
})

// 이 함수를 끝자리 클로저로 대신해서 호출하는 방법은 다음과 같습니다:

someFunctionThatTakesAClosure() {
  // 끝자리 클로저의 본문을 여기에 둡니다.
}
```

위의 [Closure Expression Syntax (클로저 표현식 구문 표현)](#closure-expression-syntax-클로저-표현식-구문-표현) 에 있는 '문자열-정렬 (strig-sort) 클로저' 도 끝자리 클로저를 사용하면 `sorted(by:)` 메소드의 괄호 밖에 작성할 수 있습니다:

```swift
reversedNames = names.sorted() { $0 > $1 }
```

클로저 표현식이 함수나 메소드의 유일한 인자이면서 해당 표현식을 끝자리 클로저로 제공하는 경우, 그 함수를 호출할 때 함수나 메소드 이름 뒤의 괄호 쌍 `()` 을 작성할 필요가 없습니다:

```swift
reversedNames = names.sorted { $0 > $1 }
```

끝자리 클로저는 한 줄 안에 작성하는 것이 불가능할 정도로 클로저가 아주 길 때 가장 좋습니다. 예를 들어 보면, 스위프트의 `Array` 타입은 `map(_:)` 이라는 메소드를 가지고 있는데, 이것은 단일 인자로 클로저 표현식을 받습니다. 클로저는 배열의 각 항목마다 한 번씩 호출되며, 해당 항목에 대한 (어떤 다른 타입일 수도 있는) 또 다른 '맵핑된 값 (mapped value)'[^mapped-value] 을 반환합니다. `map(_:)` 에 전달하는 클로저에 코드를 작성함으로써 '맵핑 (mapping; 대응 관계)' 의 본 성질과 반환 값의 타입을 지정합니다.

제공된 클로저를 각각의 배열 원소에 적용하고 난 후, `map(_:)` 메소드는, 원래 배열에 있던 연관된 값들과 같은 순서로 된, 모든 새로운 '맵핑된 값 (mapped values)' 을 담고 있는 새로운 배열을 반환합니다.

`Int` 값의 배열을 `String` 값의 배열로 변환하는 끝자리 클로저를 가진 `map(_:)` 메소드를 사용하는 방법은 다음과 같습니다. 배열 `[16, 58, 510]` 이 새로운 배열인 `[ "OneSix", "FiveEight", "FiveOneZero"]` 을 생성하는데 사용됩니다:

```swift
let digitNames = [
  0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
  5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]

let numbers = [16, 58, 510]
```

위 코드는 '정수 숫자 (integer digits)' 와 그 영어-버전의 이름 사이의 '맵핑 (mapping; 대응 관계)' 에 대한 '딕셔너리 (dictionary)' 를 생성합니다. 문자열로 변환하기 위해 준비한, 정수 배열도 정의하고 있습니다.

이제, 클로저 표현식을 배열의 `map(_:)` 메소드에 대한 끝자리 표현식으로 전달하면, `numbers` 배열로 `String` 값의 배열을 생성할 수 있습니다:

```swift
let strings = numbers.map { (number) -> String in
  var number = number
  var output = ""
  repeat {
    output = digitNames[number % 10]! + output
    number /= 10
  } while number > 0
  return output
}
// strings 는 [String] 타입으로 추론됩니다.
// 값은 ["OneSix", "FiveEight", "FiveOneZero"] 입니다.
```

이 `map(_:)` 메소드는 배열에 있는 각 항목에 대해서 클로저 표현식을 한 번씩 호출합니다. 클로저의 입력 매개 변수인, `number` 의 타입은 지정할 필요가 없는데, 이 타입은 '맵핑될 (mapped)' 배열에 있는 값으로 추론할 수 있기 때문입니다.

이 예제에서, 변수 `number` 는 클로저의 `number` 매개 변수의 값으로 초기화되었으므로, 이 값은 클로저 본문에서 수정할 수 있습니다. (함수와 클로저의 매개 변수는 항상 상수입니다.)[^constants] 이 클로저 표현식은 `String` 이라는 반환 타입도 지정하여, '맵핑된 출력 배열 (mapped output array)' 에 저장될 타입도 지시합니다.

이 클로저 표현식은 매 번 호출할 때마다 `output` 이라는 문자열을 만듭니다. `number` 의 마지막 자리 숫자는 나머지 연산자를 사용하며 (`number % 10`) 계산하며, 이 숫자를 사용하여 `digitNames` 딕셔너리에 있는 적당한 문자열을 찾아 갑니다. 이 클로저를 사용하면 '0' 보다 큰 어떠한 정수에 대해서라도 문자열 표현을 생성할 수 있습니다.

> `digitNames` 딕셔너리의 첨자 연산 호출은 그 뒤에 느낌표 (`!`) 가 붙어 있는데, 이는 딕셔너리의 첨자 연산이 옵셔널 값을 반환하기 때문으로 키 (key) 가 존재하지 않으면 딕셔너리의 찾기가 실패할 수 있다는 것을 지시합니다. 위 예제에서, `number % 10` 는 `digitNames` 딕셔너리의 첨자 연산 키로 항상 유효하다는 것이 보증되므로, 첨자 연산의 옵셔널 반환 값에 저장된 `String` 값의 포장을 강제로-풀기 위해 느낌표를 사용합니다.

`digitNames` 딕셔너리에서 가져온 문자열은, 해당 수의 문자열 버전을 역순으로 효과적으로 제작하기 위해, `output` _앞에_ 추가됩니다. (표현식 `number % 10` 은 `16` 일 때 `6` 을, `58` 일 때 `8` 을, `510` 일 때 `0` 을 부여합니다.)

그 다음에는 `number` 변수를 `10` 으로 나눕니다. 정수이기 때문에, 나누는 동안 값이 잘려서, `16` 은 `1` 이 되고, `58` 은 `5`, `510` 은 `51` 이 됩니다.

이 과정을 반복하다가 `number` 가 `0` 과 같아지면, 그 순간 클로저가 `output` 문자열을 반환하고, 이를 `map(_:)` 메소드가 '출력 배열 (output array)' 에 추가합니다.

위 예제에서 '끝자리 클로저 구문 표현' 을 사용하면, 전체 클로저를 `map(_:)` 메소드의 바깥 괄호로 포장할 필요 없이, 클로저의 '기능성 (functionality)' 을 클로저가 지원하는 함수 바로 뒤에 깔끔하게 '은닉 (encapsulates)' 합니다.

함수가 '다중 클로저' 를 받을 경우, 첫 번째 끝자리 클로저에 대한 '인자 이름표 (argument label)' 는 생략하고 나머지 끝자리 클로저들은 이름표를 답니다. 예를 들어, 아래 함수는 '사진 전시실' 에 사진을 싣습니다:

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
  if let picture = download("photo.jpg", from: server) {
    completion(picture)
  } else {
    onFailure()
  }
}
```

사진을 실으려고 이 함수를 호출할 때, 클로저를 두 개 제공합니다. 첫 번째 클로저는 다운로드를 성공한 후에 사진을 보여주는 '완료 상황 처리자 (completion handler)' 입니다. 두 번째 클로저는 사용자에게 에러를 보여주는 '에러 처리자 (error handler)' 입니다.

```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

이 예제에서, `loadPicture(from:completion:onFailure:)` 함수는 네트워크 작업을 백그라운드로 '급파하고 (dispatch)'[^dispatch], 네트워크 작업을 마쳤을 때 두 '완료 상황 처리자' 중 하나를 호출합니다. 함수를 이런 방식으로 작성하는 것은, 단 하나의 클로저를 사용하여 두 가지 상황을 처리하는 대신, 네트워크 실패를 처리하는 코드를 다운로드 성공 후 사용자 인터페이스를 갱신하는 코드로 부터 깔끔하게 구분할 수 있게 해줍니다.

### Capturing Values (값 붙잡기)

클로저는 자신이 정의되어 있는 영역에 있는 상수와 변수를 _붙잡을 (capture)_ 수 있습니다. 그런 다음 이 상수와 변수를 참조하고 (refer to)[^refer-to] 변경 (modify) 할 수 있는데, 상수와 변수가 정의된 영역이 사라져도 이게 가능합니다.[^capture-scope]

스위프트에서 값을 붙잡을 수 있는 클로저 중에서 가장 간단한 것은 '중첩 함수 (nested function)' 인데, 이는 다른 함수 본문 안에 작성하는 방식입니다. 중첩 함수는 자기 외부 함수의 인자는 어느 것이든 붙잡을 수 있으며 외부 함수 내에 정의되어 있으면 상수와 변수도 어느 것이든 붙잡을 수 있습니다.

다음에 예로 든 함수 `makeIncrementer` 는 `incrementer` 라는 '중첩 함수' 를 갖고 있습니다. 그리고 이 중첩 함수인 `incrementer()` 는 자기 주위 영역에 있는 두 값인  `runningTotal` 과 `amount` 를 담습니다. 값을 붙잡은 후, `incrementer` 는  `makeIncrementer` 가 반환하는 클로저이면서, 호출될 때마다 `runningTotal` 을 `amount` 만큼 증가시키는 역할을 합니다.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
  var runningTotal = 0
  func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
  }
  return incrementer
}
```

`makeIncrementer` 의 반환 타입은 `() -> Int` 입니다. 이것은 단순히 값이 아니라 하나의 _함수 (function)_ 를 반환한다는 것을 의미합니다. 이 함수가 '반환하는 함수' 는 매개 변수를 갖지 않으며, 호출 될 때마다 `Int` 값을 반환합니다. 함수로 다른 함수를 반환하는 방법을 알고 싶으면 [Function Type as Return Types (반환 타입으로써의 함수 타입)]({% post_url 2020-06-02-Functions %}#function-type-as-return-types-반환-타입으로써의-함수-타입) 을 보기 바랍니다.

`makeIncrementer(forIncrement:)` 함수는 `runningTotal` 이라는 정수 변수를 정의하여 반환될 'incrementer (증가기)' 의 현재 총 누적 값을 저장합니다. 이 변수는 `0` 으로 초기화 됩니다.

`makeIncrementer(forIncrement:)` 함수는 매개 변수로 하나의 `Int` 값을 가지는데, 인자 이름표 (argument label) 가 `forIncrement` 이고 매개 변수 이름이 `amount` 입니다. 이 매개 변수에 전달되는 인자 값은 반환된 'incrementer (증가기)' 가 호출될 때마다 `runningTotal` 을 얼마나 증가시켜야 하는 지를 지정합니다. 실제 증가시키는 역할은 `makeIncrementer` 함수에 '중첩 함수'인 `incrementer` 가 담당합니다. 이 함수는 단순히 `runningTotal` 에 `amount` 를 추가한 후 결과를 반환합니다.

따로 떼어 놓고 보면, '중첩 함수' 인 `incrementer` 는 상당히 이상해 보입니다:

```swift
func incrementer() -> Int {
  runningTotal += amount
  return runningTotal
}
```

`incrementer()` 함수는 아무런 매개 변수도 갖지 않으면서 함수 내에서 `runningTotal` 및 `amount` 를 참조하고 있습니다. 이것은 '_참조_ 를 붙잡기 (by capturing a _reference_)' 때문에 가능한 것이며 자기 주위에 있는 `runningTotal` 과 `amount` 를 붙잡음으로써 자기 본문에서 사용할 수 있게 되는 것입니다. '참조로 붙잡는 것 (capturing by reference)' 은 `makeIncrementer` 호출이 끝나도 `runningTotal` 과 `amount` 가 사라지지 않도록 하며, 다음에 `incrementer` 함수가 호출 될 때도 `runningTotal` 을 사용할 수 있도록 합니다.

> 최적화에 의해서, 클로저가 값을 바꾸지 않는 경우나 클로저가 생성된 이후로 값이 바뀌지 않았을 때, 스위프트는 (참조) 대신 값의 _복사본 (copy)_ 을 붙잡고 저장할 수도 있습니다.
>
> 스위프트는 필요없는 변수의 정리 작업을 포함하여 모든 메모리 관리도 직접 담당합니다.

`makeIncrementer` 를 실제로 사용하면 다음과 같습니다:

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
```

이 예제는 `incrementalByTen` 이라는 상수를 만들어서, 호출 될 때마다 `runningTotal` 변수에 `10` 을 더하는 '증가 함수 (increment function)' 를 참조하도록 설정합니다. 함수를 여러 번 호출했을 때의 동작은 다음과 같습니다:

```swift
incrementByTen()
// 10 의 값을 반환합니다.
incrementByTen()
// 20 의 값을 반환합니다.
incrementByTen()
// 30 의 값을 반환합니다.
```

두 번째 '증가기 (incrementer)' 를 생성하면, 이것은 새로운 별도의 `runningTotal` 변수에 대한 자기만의 참조를 가지게 됩니다:

```swift
let incrementBySeven = makeIncrementer(forIncrement: 7)

incrementalBySeven()
// 7 의 값을 반환합니다.
```

원래의 '증가기 (`incrementByTen`)' 을 다시 호출하면 그 자신의 `runningTotal` 변수는 계속 증가하지만, `incrementBySeven` 에 담긴 변수에는 영향을 주지 않습니다.

```swift
incrementByTen()
// 40 의 값을 반환합니다.
```

클로저를 클래스 인스턴스의 속성으로 할당하거나, 클로저로 클래스의 인스턴스나 멤버를 가리켜서 클로저가 그 인스턴스를 붙잡게 (capture) 되면, 클로저와 그 인스턴스 사이에는 '강한 참조 순환 (strong reference cycles)' 이 생깁니다. 스위프트는 _붙잡을 목록 (capture lists; 캡처 리스트)_ 를 사용해서 이 강한 참조 순환을 끊어 냅니다. 이에 대한 자세한 내용은 [Strong Reference Cycles for Closures (클로저에 대한 강한 참조 순환)]({% post_url 2020-06-30-Automatic-Reference-Counting %}#strong-reference-cycles-for-closures-클로저에-대한-강한-참조-순환) 에서 확인할 수 있습니다.

### Closures Are Reference Types (클로저는 참조 타입입니다)

앞의 예에서, `incrementBySeven` 과 `incrementByTen` 이 상수인데도, 이 상수들이 참조하는 클로저들은 여전히 자신이 붙잡고 있는 `runningTotal` 변수를 증가시키고 있음을 알 수 있습니다. 이는 함수와 클로저가 참조 타입 (reference types) 이기 때문에 그런 것입니다.

함수나 클로저를 상수나 변수에 할당한다는 것은 실제로는 그 상수나 변수를 함수나 클로저의 _참조 (reference)_ 로 설정한다는 것을 뜻합니다. 위 예에서 `incrementByTen` 이 상수라는 것은 참조하는 클로저를 바꿀 수 없다는 것을 의미하며, 클로저의 내용이 상수라는 것을 의미하는 것이 아닙니다.

이것이 가지는 또 다른 의미는, 만약 한 클로저를 두 개의 서로 다른 상수나 변수에 할당할 경우, 이 두 상수나 변수는 동일한 클로저를 참조하고 있다는 것입니다.

```swift
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 50 의 값을 반환합니다.

incrementByTen()
// 60 의 값을 반환합니다.
```

위의 예는 `alsoIncrementByTen` 을 호출하는 것은 사실상 `incrementByTen` 을 호출하는 것이라는 것을 보여줍니다. 둘이 참조하는 클로저가 같기 때문에, 둘이 증가시키고 반환하는 총 누적 값이 동일합니다.

### Escaping Closures (벗어나는 클로저)

클로저는 이를 함수에 인자로 전달했지만, 호출은 함수가 반환한 후에 할 때, 함수를 _벗어난다 (escape)_ 라고 합니다.[^escape] 클로저를 매개 변수로 받는 함수를 선언할 때는, 클로저가 벗어나도록 허용된 것임을 지시하기 위해 매개 변수의 타입 앞에 `@escaping` 을 작성할 수 있습니다.

클로저가 벗어날 수 있는 한 가지 방법은 함수 외부에서 정의한 변수에 저장하는 것입니다. 예를 들어 보면, '비동기 (asynchronous)' 연산을 시작하는 많은 함수들은 '완료 상황 처리자 (completion handler)' 로 클로저 인자를 받습니다. 함수는 연산을 시작한 후 반환하지만, 클로저는 연산을 완료할 때까지 호출되지 않습니다-클로저는, 나중에 호출하려면, 벗어날 필요가 있습니다. 예를 들면 다음과 같습니다:

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
  completionHandlers.append(completionHandler)
}
```

`someFunctionWithEscapingClosure(_:)` 함수는 클로저를 인자로 받아서 이를 함수 외부에서 선언한 배열에 추가합니다. 이 함수의 매개 변수를 `@escaping` 으로 표시하지 않으면, 컴파일-시간 에러 (compile-time error) 를 얻게 됩니다.

`self` 를 참조하는 '벗어나는 클로저' 는 `self` 가 클래스의 인스턴스를 참조하고 있다면 '특별한 주의 (special consideration)' 가 필요합니다. '벗어나는 클로저' 에서 `self` 를 붙잡는 것은 의도하지 않게 '강한 참조 순환 (strong reference cycle)' 을 만들기 쉽습니다. '참조 순환' 에 대한 정보는, [Automatic Reference Counting (자동 참조 카운팅)]({% post_url 2020-06-30-Automatic-Reference-Counting %}) 을 참고하기 바랍니다.

보통은, 클로저 본문에서 변수를 사용하기만 하면 클로저가 이를 암시적으로 붙잡지만, 이 경우에는 명시적으로 해야 합니다. `self` 를 붙잡고 싶으면, 사용할 때 `self` 를 명시적으로 작성하거나, 아니면 클로저가 '붙잡을 목록 (capture list)' 에 `self` 를 포함시키도록 합니다.[^explicit] `self` 를 명시적으로 작성하는 것은 자신의 의도를 드러내도록 해주며, 참조 순환이 없다고 확정해야 함을 상기시켜 줍니다. 예를 들어, 아래 코드에서, `someFunctionWithEscapingClosure(_:)` 에 전달된 클로저는 `self` 를 명시적으로 참조합니다. 이와는 대조적으로, `someFunctionWithNonescapingClosure(_:)` 에 전달된 클로저는 '벗어나지 않는 클로저 (nonescaping closure)' 이며, 이는 `self` 를 암시적으로 참조할 수 있다는 것을 의미합니다.

```swift
someFunctionWithNonescapingClosure(closure: () -> Void) {
  closure()
}

class SomeClass {
  var x = 0
  func doSomething() {
    someFunctionWithEscapingClosure { self.x = 100 }
    someFunctionWithNonescapingClosure { x = 200 }
  }
}

let instance = SomeClass()
instance.doSomething()
print(instance.x)
// "200" 를 출력합니다.

completionHandlers.first?()
print(instance.x)
// "100" 를 출력합니다.
```

이번 버전의 `doSomething()` 은 `self` 를 클로저의 '붙잡을 목록' 에 포함시켜서 붙잡은 다음, 암시적으로 `self` 를 참조합니다:

```swift
class SomeOtherClass {
  var x = 10
  func doSomething() {
    someFunctionWithEscapingClosure { [self] in x = 100 }
    someFunctionWithNonescapingClosure { x = 200 }
  }
}
```

만약 `self` 가 구조체나 열거체의 인스턴스라면, 항상 `self` 를 암시적으로 참조할 수 있습니다.[^implicitly] 하지만, `self` 가 구조체나 열거체의 인스턴스일 때는 '벗어나는 클로저' 가 `self` 를 '변경 가능한 참조 (mutable reference)' 로 붙잡을 수 없습니다. 구조체와 열거체는, [Structures and Enumerations Are Value Types (구조체와 열거체는 값 타입입니다)]({% post_url 2020-04-14-Structures-and-Classes %}#structures-and-enumerations-are-value-types-구조체와-열거체는-값-타입입니다) 에서 설명한 것처럼, '변경 가능성의 공유 (shared mutability)'[^shared-mutability] 를 허용하지 않습니다.

```swift
struct SomeStruct {
  var x = 10
  mutating func doSomething() {
    someFunctionWithNonescapingClosure { x = 200 }  // Ok
    someFunctionWithEscapingClosure { x = 100 }     // Error
  }
}
```

위 예제의 `someFunctionWithEscapingClosure` 함수 호출은 에러인데 이것이 '변경 메소드 (mutating method)' 안에 있기 때문에, `self` 가 '변경 가능한 (mutable)' 것이 되기 때문입니다. 이는 '벗어나는 클로저' 는 구조체에 대한 `self` 를 '변경 가능한 참조' 로 붙잡을 수 없다는 규칙을 위반합니다.

### Autoclosures (자동 클로저)

_자동 클로저 (autoclosure)_ 는 함수로 전달되는 표현식 형태의 인자를 감싸서 생기는 자동 생성 클로저를 말합니다. 이것은 따로 인자를 가지지 않으며, 호출될 때는 자신이 감싼 표현식의 값을 그대로 반환합니다. 이것이 문법적으로 편리한 부분은 함수 인자로 전체 클로저를 작성하는 것 대신 그냥 표현식을 쓰고 중괄호를 생략해도 된다는 점입니다.

'자동 클로저' 를 가지는 함수를 _호출하는_ 것은 일반적인 일이지만, 이러한 종류의 함수를 _구현하는_ 것은 상당히 복잡합니다. 예를 들어, `assert(condition:message:file:line:)` 함수는 `condition` 과 `message` 매개 변수로 자동 클로저를 가지는데; `condition` 매개 변수는 디버그 빌드 시에만 (in debug builds) '값을 계산하며 (evaluated)'[^evaluated], `message` 매개 변수는 `condition` 이 `false` 인 경우에만 값을 계산합니다.[^not-evaluated]

자동 클로저는 '값 계산 (evaluation)' 를 지연하는 효과가 있는데, 이는 클로저를 호출하기 전까지는 내부의 코드를 실행하지 않기 때문입니다. '값 계산을 지연 (delaying evaluation)' 하는 것은 특히 코드가 '부작용 (side effect)' 을 가지고 있거나 계산 비용이 많이 들 때 유용합니다. 코드를 계산하는 시점을 직접 제어할 수 있기 때문입니다. 아래 예제는 클로저가 '값 계산을 지연' 하는 방법을 보여줍니다:

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)
// "5" 를 출력합니다.

let customerProvider = { customersInLine.remove(at: 0) }
print(customersInLine.count)
// "5" 를 출력합니다.

print("Now serving \(customerProvider())!")
// "Now serving Chris!" 를 출력합니다.
Print(customersInLine.count)
// "4" 를 출력합니다.
```

클로저 내부의 코드에서 `customersInLine` 배열의 첫 번째 요소를 제거하도록 했지만, 실제로 클로저를 호출하기 전까지는 배열 요소가 제거되지 않습니다. 클로저를 전혀 호출하지 않는 다면, 클로저 내부의 표현식은 절대 값을 계산하지 않을 것이므로, 배열 요소도 절대 제거되지 않을 것입니다. `customerProvider` 의 타입은 `String` 이 아니라 `() -> String` — 매개 변수는 없고 문자열을 반환하는 함수 임을 명심하기 바랍니다.

함수의 인자로 클로저를 전달하는 것은 값 계산을 지연하는 것과 동일한 효과를 갖습니다.

```swift
// customersInLine 은 ["Alex", "Ewa", "Barry", "Daniella"] 입니다.
func serve(customer customerProvider: () -> String) {
  print("Now serving \(customerProvider())!")
}
serve(customer: { customersInLine.remove(at: 0) })
// "Now serving Alex!" 를 출력합니다.
```

위의 `serve(customer:)` 함수는 고객의 이름을 반환하는 클로저를 명시적으로 받고 있습니다. 반면 아래 버전의 `serve(customer:)` 함수는 동일한 작업을 수행하지만 클로저를 명시적으로 받지않고, 매개 변수 타입에 `@autoclosure` 특성을 붙여서 자동 클로저로 받도록 하고 있습니다. 이제 이 함수는 클로저가 아니라 `String` 을 인자로 받는 함수인 것처럼 호출할 수 있습니다. 인자는 자동으로 클로저로 변환되는데, `customerProvider` 매개 변수의 타입이 `@autoclosure` 특성을 갖게 되었기 때문입니다.

```swift
// customersInLine 은 ["Ewa", "Barry", "Daniella"] 입니다.
func serve(customer customerProvider: @autoclosure () -> String) {
  print("Now serving \(customerProvider())!")
}

serve(customer: customersInLine.remove(at: 0))
// "Now serving Ewa!" 를 출력합니다.
```

> 자동 클로저를 과도하게 사용하면 코드를 이해하기가 어려워집니다. 해당 영역과 함수 이름은 값 계산이 지연되고 있음을 명확히 알 수 있도록 만들어야 합니다.

자동 클로저이면서 (범위를) 벗어날 수도 있게 만들고 싶으면, `@autoclosure` 와 `@escaping` 특성을 동시에 사용합니다. `@escaping` 특성에 대해서는 위의 [Escaping Closures (벗어나는 클로저)](#escaping-closures-벗어나는-클로저) 에 설명했습니다.

```swift
// customersInLine 은 [Barry", "Daniella"] 입니다.
var customerProviders: [() -> String] = []

func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
  customerProviders.append(customerProvider)
}

collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")
// "Collected 2 closures." 를 출력합니다.

for customerProvider in customerProviders {
  print("Now serving \(customerProvider())!")
}
// "Now serving Barry!" 를 출력합니다.
// "Now serving Daniella!" 를 출력합니다.
```

위의 코드에서 `collectCustomerProviders(_:)` 함수는 `customerProvider` 의 인자로 전달된 클로저를 호출하는 대신, 이를 `customerProviders` 배열에 추가하고 있습니다. 이 배열은 함수 밖에서 선언되었으므로, 이제 함수 반환이 끝난 후에도 배열에 있는 클로저를 실행할 수 있게 되었습니다. 이는 결과적으로 `customerProvider` 인자의 값이 함수 범위를 벗어날 수 있도록 만듭니다.

### 참고 자료

[^Closures]: 원문은 [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)에서 확인할 수 있습니다.

[^closure]: 제목에서 'closure' 를 '잠금 블럭' 이라고도 표현했는데, 이는 의미의 이해를 돕기 위함이고, 앞으로는 의미를 강조하고자 하는 경우가 아니면 '클로저' 라고 발음대로 옮기도록 합니다.

[^global-nested-function]: 이를 수학 집합에 비유하면, 스위프트의 '전역 함수' 와 '중첩 함수' 는 '클로저' 의 부분 집합이라고 볼 수 있습니다.

[^shorthand]: '줄임 표현 (shorthand)' 은 클로저 내에서 사용하는 `$0` 등을 말합니다. 이번 장 뒷 부분에서 자세히 설명합니다.

[^trailing]: '끝자리 (trailing)' 는 '꼬리 처럼 마지막에 따라오는 것' 인데, 여기서는 함수의 인자 목록에서 맨 뒤에 오는 것을 말합니다. '끝자리 클로저 구문 표현 (trailing closure syntax)' 는 클로저가 함수의 마지막 인자일 경우 이 클로저를 함수 밖으로 꺼낼 수 있는 구문 표현입니다. 이 역시 이번 장의 뒷 부분에서 자세히 설명합니다.

[^in-out]: 스위프트의 입-출력 매개변수 (in-out parameters) 는 C 나 C++ 의 참조 (reference) 와 비슷하며, 함수 내부에서 인자의 값을 바꿀 수 있음을 나타냅니다.

[^inline-closure]: '인라인 클로저 (inline closure)' 는 코드 내에서 해당 위치에 직접 입력된 클로저를 말합니다. '해당 줄에 삽입되는 클로저' 라고 이해할 수 있습니다.

[^constants]: 본문에도 나와 있듯이 스위프트에서 함수 및 클로저의 매개 변수는 항상 상수이기 때문에 클로저 내에서 직접 변경할 수 없습니다. '입-출력 매개 변수 (in-out parameter)' 라는 것이 있긴 하지만 이는 내부에서 변경된 내용을 외부로 다시 넘겨줘야하는 특수한 경우에만 사용하는 것입니다.

[^dispatch]: 애플 운영체제에서 '디스패치 (dispatch; 급파하다)' 는 '병행 컴퓨팅 (Concurrent Computing)' 과 관련이 있습니다. 여기서 `loadPicture(from:completion:onFailure:)` 함수가 작업을 백그라운드로 '급파한다 (dispatch)' 는 것은, 함수를 호출한 다음 결과를 기다리지 않고 다른 작업을 하며 실제 다운로드 작업은 별도의 백그라운드 쓰레드에서 진행한다는 것을 의미합니다. 애플 운영체제에서는 '병행 컴퓨팅' 을 위해 'GCD (Grand Centeral Dispatch)' 라는 것을 지원하고 있는데, 이에 대한 더 자세한 내용은 위키피디아의 [Grand Central Dispatch](https://en.wikipedia.org/wiki/Grand_Central_Dispatch) 또는 애플 개발자 문서의 [Dispatch](https://developer.apple.com/documentation/DISPATCH) 를 참고하기 바랍니다.

[^refer-to]: C 나 C++ 언어에서 말하는 참조 (reference) 와 유사한 개념인데, 스위프트는 따로 참조 연산자 같은 것이 없이 객체에 해당하는 것이면 항상 참조를 합니다. 스위프트에서는 `class` 와 `closure` 가 항상 그렇습니다.

[^capture-scope]: 사실 이렇게 본래 영역이 사라져도 사용할 수 있다는 의미로 '붙잡다 (capture)' 라는 말을 사용한다고 볼 수 있습니다. 따로 붙잡아두고 있기 때문에 사용할 수 있게 되는 것입니다.

[^escape]: 'escape' 라는 단어의 의미에 대해서는 왕발님의 블로그 글, [Escape string (이스케이프) 이란?](https://m.blog.naver.com/jskorl/220544334899) 에 잘 설명되어 있는 것 같습니다. 'escape character' 를 '본래 의미를 벗어나서 특수한 의미를 가진 문자' 라고 이해한다면, 'escaping closure' 는 '본래 범위를 벗어나서 호출될 수 있는 클로저'라는 의미로 이해할 수 있을 것입니다.

[^evaluated]: '값을 계산한다' 는 것은 표현식을 실행하여 특정 값을 구한다는 의미입니다. 함수는 호출 (call) 해서 실행한다면, 표현식은 값을 계산하는 (evaluate) 것이 실행하는 것이라고 생각할 수 있습니다. 'evaluate' 와 'call' 을 구분하는 것에서 이 둘은 비슷하지만 서로 다른 개념임을 알 수 있습니다.

[^not-evaluated]: 예를 들어 `let a = 1; let b = 1; if a > 0 || b < 0 { print("OK!") }` 와 같은 코드가 있을 때, `a > 0` 가 `true` 이므로 전체 `if` 구문이 항상 `true` 가 되어, 표현식 `b < 0` 를 실행하는 것은 무의미합니다. 이런 상황에서 스위프트는 실제로 `b < 0` 의 '값을 계산하지 않는다' 는 것입니다.

[^mapped-value]: 여기서 '맵핑된 값 (mapped value)' 에 사용되는 '맵핑 (mapping)' 이란 말은 수학에서 말하는 '맵핑 (mapping)' 과 같은 개념입니다. '맵핑' 에 대해서는 위키피디아의 [Map (mathematics)](https://en.wikipedia.org/wiki/Map_(mathematics) 및 [맵핑 (수학)](https://ko.wikipedia.org/wiki/맵핑_(수학) 항목을 참고하기 바랍니다.

[^explicit]: `self` 를 명시적으로 사용한다는 것은 클로저 내부에서 `{ self.x = 1 }` 처럼 `self` 를 명시적으로 붙여주는 것을 말하며, '붙잡을 목록' 에 `self` 를 포함한다는 것은 `{ [self] in x = 1 }` 처럼 `self` 를 클로저 앞부분에 명시하는 것을 말합니다. 이 두 가지 방법 중에서 편한 방법을 선택하면 됩니다.

[^implicitly]: 구조체 같은 값 타입은 클로저가 `self` 를 암시적으로 붙잡기 때문에 본문에서 `self` 를 안붙여도 되지만, 클래스 같은 참조 타입의 `self` 는 클로저에서 명시적으로 붙여야 합니다. 값 타입의 클로저에서 `self` 를 안붙여도 되는 이유는 값 타입이 '참조 순환' 과는 상관 없기 때문입니다. 이 부분은 스위프트 5.3 부터 적용된 것으로, 보다 자세한 내용은 [SE-0269: Increase availability of implicit self in @escaping closures when reference cycles are unlikely to occur](https://github.com/apple/swift-evolution/blob/master/proposals/0269-implicit-self-explicit-capture.md) 문서를 참고하기 바랍니다.

[^shared-mutability]: 'shared mutability' 는 직역하면 '공유된 변경 가능성' 이라고 할 수 있는데, 의미 전달을 위해서 '변경 가능성을 공유하는 것' 으로 약간 의역하였습니다.
