---
layout: post
comments: true
title:  "Swift 5.7: Closures (클로저; 잠금 블럭)"
date:   2020-03-03 11:30:00 +0900
categories: Swift Language Grammar Closure
redirect_from: "/swift/language/grammar/closure/2020/02/29/Closures.html"
---

> Apple 에서 공개한 [The Swift Programming Language (Swift 5.7)](https://docs.swift.org/swift-book/) 책의 [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html) 부분[^Closures]을 번역하고, 설명이 필요한 부분은 주석을 달아서 정리한 글입니다. 전체 번역은 [Swift 5.7: Swift Programming Language (스위프트 프로그래밍 언어)]({% post_url 2017-02-28-The-Swift-Programming-Language %}) 에서 확인할 수 있습니다.

## Closures (클로저; 잠금 블럭)

_클로저 (Closures)_ 는 '코드에서 사용하고 전달할 수 있는 독립된 기능 블럭' 입니다. 스위프트 클로저는 'C 와 오브젝티브-C 의 블럭 (blocks)' 및 '다른 프로그래밍 언어의 람다식 (lambdas)' 과 비슷합니다.

클로저는 자신을 정의한 곳의 어떤 상수와 변수에 대한 참조든 '붙잡고 (capture)' 저장할 수 있습니다. 이를 보고 '해당 상수와 변수를 _잠근다 (closing over)_' 라고 합니다. 스위프트는 '붙잡기 (capturing) 에 대한 모든 메모리 관리' 를 직접 처리합니다.

> '붙잡기 (capturing) 라는 개념' 에 익숙치 않아도 걱정할 필요 없습니다. 아래에 있는 [Capturing Values (값 붙잡기)](#capturing-values-값-붙잡기) 에서 자세하게 설명합니다.

전역 함수와 중첩 함수는, [Functions (함수)]({% post_url 2020-06-02-Functions %}) 에서 소개한 것처럼, 실제로는 특수한 경우의 클로저입니다.[^global-nested-function] 클로저는 세 가지 형식 중 하나를 취합니다:

* 전역 함수는 '이름은 있지만 어떤 값도 붙잡지 않는 클로저' 입니다.
* 중첩 함수는 '이름이 있으며 자신을 둘러싼 함수의 값을 붙잡을 수 있는 클로저' 입니다.
* 클로저 표현식 (closure expressions) 은 '자기 주위의 값을 붙잡을 수 있는 가벼운 구문으로 작성한 이름 없는 클로저' 입니다.

스위프트 클로저 표현식은 깔끔하고, 명확한 스타일을 가지고, 일상적인 상황에서 간결하고, 번잡하지-않은 구문이 되도록 최적화합니다:

* 상황으로 매개 변수와 반환 값 타입을 추론함
* 단일-표현식 클로저로 암시적으로 반환함
* 짧게 줄인 인자 이름[^shorthand]
* 뒤에 딸린 클로저 (trailing closure) 구문[^trailing]

### Closure Expressions (클로저 표현식)

중첩 함수는, [Nested Functions (중첩 함수)]({% post_url 2020-06-02-Functions %}#nested-functions-중첩-함수) 에서 소개한 것처럼, 더 큰 함수에서 독립된 코드 블럭을 정의하고 이름짓는 편의 수단입니다. 하지만, 온전한 이름과 선언 없이 더 짧은 버전의 함수-같은 구조를 작성하는 게 유용할 때가 있습니다. 이는 자신의 인자로 하나 이상의 함수를 취하는 함수나 메소드와 작업할 때 특히 더 그렇습니다.

_클로저 표현식_ 은 '간결하고, 집중된 구문으로 인라인 클로저[^inline-closure] 를 작성하는 방법' 입니다. 클로저 표현식은 분명함과 의도를 잃지 않고도 클로저를 줄임 형식으로 작성하는 여러가지 구문 최적화를 제공합니다. 아래에 있는 클로저 표현식 예제는, 제각각 동일한 기능을 더 간단명료하게 표현하도록, `sort(by:)` 메소드라는 단일 예제를 여러번 반복하여 개량함으로써 이런 최적화를 묘사합니다.

#### The Sorted Method (정렬 메소드)

스위프트 표준 라이브러리는, 알려진 타입의 값 배열을, 제공한 정렬 클로저 출력을 기초로 정렬하는, `sorted(by:)` 라는 메소드를 제공합니다. 정렬 과정을 한 번 완료하고 나면, `sorted(by:)` 메소드는, 올바로 정렬한 원소를 가진, 예전과 똑같은 타입과 크기의, 새로운 배열을 반환합니다. `sorted(by:)` 메소드는 원본 배열을 수정하진 않습니다.

아래에 있는 클로저 표현식 예제는 `sorted(by:)` 메소드를 사용하여 `String` 값 배열을 알파벳 역순으로 정렬합니다. 다음은 정렬 전의 초기 배열입니다:

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`sorted(by:)` 메소드는 '배열 내용물과 똑같은 타입의 두 인자를 취하여, 값을 한 번 정렬하고 나면 첫 번째 값이 두 번째 값 앞에 있어야 하는 지 뒤에 있어야 하는 지 말해주는 `Bool` 값을 반환하는, 클로저' 를 받아 들입니다. 정렬 클로저는 첫 번째 값이 두 번째 값 _앞에_ 있어야 하면 `true` 를 반환하고, 그 외 경우라면 `false` 를 반환할 필요가 있습니다.

이 예제는 `String` 값 배열을 정렬하므로, 정렬 클로저는 `(String, String) -> Bool` 타입의 함수일 필요가 있습니다.

정렬 클로저를 제공하는 한 가지 방법은 올바른 타입인 보통의 함수를 작성하고, 이를 `sorted(by:)` 메소드의 인자로 전달하는 것입니다:

```swift
func backward(_ s1: String, _ s2: String) -> Bool {
  return s1 > s1
}
var reversedNames = names.sorted(by: backward)
// reversedNames 는 ["Ewa", "Daniella", "Chris", "Barry", "Alex"] 와 같음
```

첫 번째 문자열 (`s1`) 이 두 번째 문자열 (`s2`) 보다 크면, `backward(_:_:)` 함수가 `true` 를 반환하여, `s1` 이 정렬한 배열에서 `s2` 앞에 있어야 함을 지시합니다. 문자열 문자에서, "보다 크다 (greater)" 는 건 "알파벳에서 더 뒤에 있다" 는 의미입니다. 이는 글자 `"B"` 가 글자 `"A"` "보다 크며", 문자열 `"Tom"` 이 문자열 `"Tim"` "보다 크다" 는 의미입니다. 이는, `"Barry"` 를 `"Alex"` 앞에 두는 것, 등을 계속하여, 알파벳 역순으로 정렬합니다.

하지만, 이는 본질적으로 '단일-표현식 함수 (`a > b`)' 를 작성하기에는 다소 좀 길고-지루한 방식이긴 합니다. 이 예제의, 정렬 클로저를, '클로저 표현식 구문 표현' 을 사용하여, '인라인 (inline)' 으로 작성한다면 더 좋을 것입니다.

#### Closure Expression Syntax (클로저 표현식 구문)

클로저 표현식 구문은 다음의 일반 형식을 가집니다:

&nbsp;&nbsp;&nbsp;&nbsp;{ (`parameters-매개 변수`) -> `return type-반환 타입` in<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`statements-구문`<br />
&nbsp;&nbsp;&nbsp;&nbsp;}

클로저 표현식 구문의 _매개 변수 (parameters)_ 는 입-출력 (in-out) 매개 변수[^in-out] 일 순 있지만, 기본 값을 가질 순 없습니다. 가변 (variadic) 매개 변수 이름을 붙이면 가변 매개 변수를 사용할 수 있습니다. 튜플도 매개 변수 타입과 반환 타입으로 사용할 수 있습니다.

아래 예제는 위에 있는 `backward(_:_:)` 함수의 클로저 표현식 버전입니다:

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
  return s1 > s2
})
```

이 인라인 클로저의 매개 변수 및 반환 타입 선언은 `backward(_:_:)` 함수에 있는 선언과 '모든 점에서 똑같다 (identical)' 는 걸 기억하기 바랍니다. 두 경우 모두, `(s1: String, s2: String) -> Bool` 로 작성합니다. 하지만, 인라인 클로저 표현식에선, 중괄호 밖이 아니라, _안에 (inside)_ 다가 매개 변수와 반환 타입을 작성합니다.

클로저 본문은 `in` 키워드로 시작합니다. 이 키워드는 클로저 매개 변수와 반환 타입 정의는 종료했고, 클로저 본문을 시작한다고 지시합니다.

클로저 본문은 아주 짧기 때문에, 심지어 한 줄로 작성할 수도 있습니다:

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
```

이는 전체 `sorted(by:)` 메소드 호출이 동일하게 남아 있음을 묘사합니다. 여전히 메소드 전체 인자를 한 쌍의 괄호가 감싸서 포장합니다.[^a-pair-of-parentheses] 하지만, 해당 인자는 이제 인라인 클로저입니다.

#### Inferring Type From Context (상황으로 타입 추론하기)

정렬 클로저를 메소드 인자로 전달하기 때문에, 스위프트가 매개 변수 타입과 반환 값 타입을 추론할 수 있습니다. `sorted(by:)` 메소드를 문자열 배열에서 호출하고 있으므로, 인자는 반드시 `(String, String) -> Bool` 타입의 함수일 수 밖에 없습니다. 이는 클로저 표현식 정의에서 `(String, String)` 과 `Bool` 타입을 작성할 필요는 없다는 의미입니다. 모든 타입을 추론할 수 있기 때문에, 매개 변수 이름 주변의 반환 화살표 (`->`) 와 괄호도 생략할 수 있습니다:

```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

클로저를 인라인 클로저 표현식으로 함수나 메소드에 전달할 때는 매개 변수 타입과 반환 타입의 추론이 항상 가능합니다. 그 결과, 함수나 메소드 인자로 클로저를 사용할 때 자신의 가장 완전한 형식으로 인라인 클로저를 작성할 필요가 절대로 없습니다.

그럼에도 불구하고, 원한다면 여전히 타입을 명시할 수 있으며, 코드를 읽을 때의 모호함을 피할 수 있다면 그러는 걸 권장합니다. `sorted(by:)` 메소드의 경우, '정렬이 일어난다' 는 사실에 의해서 클로저의 목적이 명확하며, 문자열 배열의 정렬을 거들고 있기 때문에, 클로저가 `String` 값과 작업할 것이라 가정해도 안전합니다.

#### Implicit Returns from Single-Expression Closures (단일-표현식 클로저의 암시적인 반환)

단일-표현식 클로저는 선언에서 `return` 키워드를 생략함으로써 자신의 단일 표현식을 암시적으로 반환할 수 있으며, 이전 예제를 이렇게 한 버전은 다음과 같습니다:

```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

여기서 `sorted(by:)` 메소드 인자의 함수 타입은 '클로저가 반드시 `Bool` 값을 반환함' 을 명확하게 합니다. 클로저 본문이 `Bool` 값을 반환하는 단일 표현식 (`s1> s2`) 을 담고 있기 때문에, 헷갈릴 일 없이, `return` 키워드를 생략할 수 있습니다.

#### Shorthand Argument Names (짧게 줄인 인자 이름)

스위프트는 인라인 클로저의, 인자 값을 `$0`, `$1`, `$2`, 등등의 이름으로 참조할 수 있는, 짧게 줄인 인자 이름을 자동 제공합니다.

클로저 표현식 안에서 짧게 줄인 인자 이름을 사용하면, 정의에서 클로저 인자 목록을 생략할 수 있습니다. 짧게 줄인 인자 이름의 타입은 예상한 함수 타입으로 추론하며, 짧게 줄인 인자로 사용한 가장 높은 수는 클로저가 취한 인자 개수를 결정합니다. `in` 키워드도 생략할 수 있는데, 클로저 표현식 전체가 자신의 본문만으로 이루어지기 때문입니다:

```swift
reversedNames = names.sorted(by: { $0 > $1 } )
```

여기서, `$0` 과 `$1` 은 클로저의 첫 번째와 두 번째 `String` 인자를 참조합니다. 짧게 줄인 인자에서 가장 높은 수가 `$1` 이기 때문에, 클로저가 두 개의 인자를 취한다고 이해합니다. 여기 있는 `sorted(by:)` 함수는 인자 둘 다 문자열인 클로저를 예상하기 때문에, 짧게 줄인 인자 `$0` 과 `$1` 둘 다 `String` 타입입니다.

#### Operator Methods (연산자 메소드)

실제로는 심지어 위의 클로저 표현식을 _더 짧게 (shorter)_ 작성하는 방식도 있습니다. 스위프트 `String` 타입은 문자열에-특화된 자신만의 보다 큰 연산자 (`>`) 구현으로, `String` 타입의 매개 변수 두 개를 취하고, `Bool` 타입 값을 반환하는 메소드를 정의합니다. 이는 `sorted(by:)` 메소드가 필요한 메소드 타입과 정확하게 일치합니다. 그러므로, 단순히 '보다 큰 연산자 (`>`)' 를 전달할 수 있으며, 스위프트는 '문자열에-특화된 구현을 사용하고 싶어 한다' 고 추론할 것입니다.

```swift
reversedNames = names.sorted(by: >)
```

연산자 메소드에 대한 더 많은 내용은, [Operator Methods (연산자 메소드)]({% post_url 2020-05-11-Advanced-Operators %}#operator-methods-연산자-메소드) 부분을 보도록 합니다.

### Trailing Closures (뒤에 딸린 클로저)

클로저 표현식을 함수의 최종 인자로 전달할 필요가 있는데 클로저 표현식이 아주 길다면, _뒤에 딸린 클로저 (trailing closure)_ 로 대신 작성하는 게 유용할 수 있습니다. 뒤에 딸린 클로저는 함수 호출 괄호 뒤에 작성하는 것일지라도, 여전히 함수 인자입니다. 뒤에 딸린 클로저 구문을 사용할 때는, 함수 호출에서 첫 번째 클로저의 _인자 이름표 (argument label)_ 를 작성하지 않습니다. 함수 호출은 뒤에 딸린 클로저를 여러 개 포함할 수 있습니다; 만, 아래 첫 몇몇 예제는 뒤에 딸린 클로저를 하나만 사용합니다.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
  // 함수 본문을 여기에 둠
}

// 다음은 뒤에 딸린 클로저를 사용하지 않고 이 함수를 호출하는 방법입니다:

someFunctionThatTakesAClosure(closure: {
  // 클로저 본문을 여기에 둠
})

// 다음은 뒤에 딸린 클로저를 가지고 이 함수를 호출하는 방법입니다:

someFunctionThatTakesAClosure() {
  // 뒤에 딸린 클로저 본문을 여기에 둠
}
```

위의 [Closure Expression Syntax (클로저 표현식 구문)](#closure-expression-syntax-클로저-표현식-구문) 에 있는 문자열-정렬 클로저는 뒤에 딸린 클로저로써  `sorted(by:)` 메소드 괄호 밖에 작성할 수 있습니다:

```swift
reversedNames = names.sorted() { $0 > $1 }
```

함수나 메소드에 제공한 유일한 인자가 클로저 표현식인데 그 표현식을 뒤에 딸린 클로저로 제공한다면[^only-trailing-closure], 함수를 호출할 때 함수나 메소드 이름 뒤에 괄호 쌍 `()` 을 작성할 필요가 없습니다:

```swift
reversedNames = names.sorted { $0 > $1 }
```

뒤에 딸린 클로저는 한 줄로 작성하는 게 불가능할 정도로 클로저가 충분히 길 때 가장 유용합니다. 한 예로, 스위프트 `Array` 타입에는, 클로저 표현식을 단일 인자로 취하는, `map(_:)` 메소드가 있습니다. 배열의 각 항목마다 클로저를 한 번씩 호출하며, 해당 항목의 (다른 타입일 수도 있는) 대체 맵핑 값[^mapped-value] 을 반환합니다. `map(_:)` 에 전달할 클로저에 코드를 작성함으로써 맵핑의 본성과 반환 값 타입을 지정합니다.

제공한 클로저를 각각의 배열 원소에 적용한 후, `map(_:)` 메소드는 새로 맵핑한 모든 값을, 원본 배열에서 자신에 해당하는 값과 똑같은 순서로, 담은 새로운 배열을 반환합니다.

다음은 뒤에 딸린 클로저를 가진 `map(_:)` 메소드를 사용하여 `Int` 값 배열을 `String` 값 배열로 변환하는 방법입니다. `[16, 58, 510]` 라는 배열로 `[ "OneSix", "FiveEight", "FiveOneZero"]` 라는 새로운 배열을 생성합니다:

```swift
let digitNames = [
  0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
  5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]

let numbers = [16, 58, 510]
```

위 코드는 정수 숫자와 영어-버전 이름 사이의 맵핑에 대한 딕셔너리를 생성합니다. 문자열로 변할 준비가 된, 정수 배열도 정의합니다.

이제, 클로저 표현식을 배열의 `map(_:)` 메소드의 뒤에 딸린 클로저로 전달함으로써, `numbers` 배열로 `String` 값 배열을 생성할 수 있습니다:

```swift
let strings = numbers.map { (number) -> String in
  var number = number
  var output = ""
  repeat {
    output = digitNames[number % 10]! + output
    number /= 10
  } while number > 0
  return output
}
// strings 는 [String] 타입인 것으로 추론함
// 그 값은 ["OneSix", "FiveEight", "FiveOneZero"] 임
```

`map(_:)` 메소드는 배열의 각 항목마다 클로저 표현식을 한 번씩 호출합니다. `number` 라는, 클로저의 입력 매개 변수, 타입은 지정할 필요가 없는데, 맵핑할 배열의 값으로 타입을 추론할 수 있기 때문입니다.

이 예제에선, 클로저의 `number` 매개 변수 값으로 `number` 변수를 초기화하므로, 클로저 본문에서 값을 수정할 수 있습니다. (함수와 클로저의 매개 변수는 항상 상수입니다.)[^constants] 클로저 표현식은, 맵핑한 출력 배열이 저장할 타입을 지시하는, `String` 이라는 반환 타입도 지정합니다.

클로저 표현식을 매 번 호출할 때마다 `output` 이라는 문자열을 제작합니다. 이는 나머지 연산자 (`number % 10`) 를 써서 `number` 의 마지막 숫자를 계산하고, 이 숫자로 `digitNames` 딕셔너리에서 적절한 문자열을 찾아 봅니다. 클로저를 사용하면 0보다 큰 어떤 정수의 문자열 표현이든 생성할 수 있습니다.

> `digitNames` 딕셔너리의 첨자 연산 (subscript) 호출 뒤에는 느낌표 (`!`) 가 붙는데, 키 (key) 가 존재하지 않을 경우 딕셔너리 찾아보기가 실패할 수 있다는 걸 지시하고자 딕셔너리 첨자 연산이 옵셔널 값을 반환하기 때문입니다. 위 예제에선, `number % 10` 가 `digitNames` 딕셔너리의 유효한 첨자 연산 키라는 걸 항상 보증하므로[^guaranteed], 느낌표를 사용하여 첨자 연산의 옵셔널 반환 값에 저장한 `String` 값 포장을-강제로 풉니다.

`digitNames` 딕셔너리에서 가져온 문자열을 `output` _앞에 (front)_ 추가하여, 사실상 수치 값의 문자열 버전을 역순으로 제작합니다. (표현식 `number % 10` 은 `16` 이면 `6`, `58` 이면 `8`, `510` 이면 `0` 을 줍니다.)

그런 다음 `number` 변수를 `10` 으로 나눕니다. 정수이기 때문에, 나눗셈 중에 값을 잘라, `16` 은 `1` , `58` 은 `5`, `510` 은 `51` 이 됩니다.

이 과정을 반복하다가 `number` 가 `0` 이 되는, 순간에 클로저가 `output` 문자열을 반환하고, `map(_:)` 메소드가 출력 배열에 이를 추가합니다.

위 예제에서 뒤에 딸린 클로저 구문을 사용하면, 전체 클로저를 `map(_:)` 메소드 외부 괄호로 포장할 필요 없이, 클로저 기능을 클로저가 지원하는 함수 바로 뒤에 깔끔하게 은닉합니다.

함수가 여러 개의 클로저를 취하면, 뒤에 딸린 첫 번째 클로저의 인자 이름표는 생략하고 뒤에 딸린 나머지 클로저들은 이름표를 붙입니다. 예를 들어, 아래 함수는 사진 전시관 (gallary) 에 사진을 싣습니다:

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
  if let picture = download("photo.jpg", from: server) {
    completion(picture)
  } else {
    onFailure()
  }
}
```

이 함수를 호출하여 사진을 실을 때, 클로저 두 개를 제공합니다. 첫 번째 클로저는 '다운로드 성공 후에 사진을 보여주는 완료 처리자 (completion handler)' 입니다. 두 번째 클로저는 '사용자에게 에러를 보여주는 에러 처리자 (error handler)' 입니다.

```swift
loadPicture(from: someServer) { picture in
  someView.currentPicture = picture
} onFailure: {
  print("Couldn't download the next picture.")
}
```

이 예제에서, `loadPicture(from:completion:onFailure:)` 함수는 '네트워크 임무를 백그라운드로 급파 (dispatch)'[^dispatch] 하며, 네트워크 임무를 종료할 때 두 완료 처리자 중 하나를 호출합니다. 함수를 이런 식으로 작성하면, 두 상황 다 처리하는 단 하나의 클로저를 사용하는 대신, 네트워크 실패를 책임질 코드를 다운로드 성공 후 사용자 인터페이스를 갱신할 코드로부터 깨끗하게 분리할 수 있습니다.

### Capturing Values (값 붙잡기)

클로저는 자신의 정의 주위에 있는 상수와 변수를 _붙잡을 (capture)_ 수 있습니다. 그러면, 상수와 변수를 정의한 원본 영역이 더 이상 존재하지 않은 경우에도, 클로저가 해당 상수와 변수를 참조하고 수정할 수 있습니다.[^capture-scope]

스위프트에서, 값을 붙잡을 수 있는 가장 단순한 형식의 클로저는, 또 다른 함수 본문 안에 작성한, 중첩 함수입니다. 중첩 함수는 자기 바깥 함수의 어떤 인자든 붙잡을 수 있으며 바깥 함수에서 정의한 어떤 상수와 변수 역시도 붙잡을 수 있습니다.

다음 예제는, `incrementer` 라는 중첩 함수를 담고 있는, `makeIncrementer` 라는 함수입니다. 중첩 함수 `incrementer()` 는, 자기 주위의, `runningTotal` 과 `amount` 라는, 두 값을 붙잡습니다. 이 값을 붙잡은 후, 매 번 호출할 때마다 `makeIncrementer` 가 '`runningTotal` 을 `amount` 만큼 증가시키는 클로저' 로써 `incrementer` 를 반환합니다.[^factory-method]

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
  var runningTotal = 0
  func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
  }
  return incrementer
}
```

`makeIncrementer` 의 반환 타입은 `() -> Int` 입니다. 이는, 단순한 값이라기 보단, 하나의 _함수 (function)_ 를 반환한다는 의미입니다. 반환하는 함수에는 매개 변수가 없으며, 매 번 호출할 때마다 `Int` 값을 반환합니다. 함수가 다른 함수를 반환할 수 있는 방법을 배우려면, [Function Types as Return Types (반환 타입으로써의 함수 타입)]({% post_url 2020-06-02-Functions %}#function-types-as-return-types-반환-타입으로써의-함수-타입) 을 보도록 합니다.

`makeIncrementer(forIncrement:)` 함수는, 반환할 '증가기 (incrementer)' 의 현재 총 누적 값을 저장하는, `runningTotal` 이라는 정수 변수를 정의합니다. 이 변수는 `0` 이라는 값으로 초기화합니다.

`makeIncrementer(forIncrement:)` 함수에는 `forIncrement` 라는 인자 이름표와, `amount` 라는 매개 변수 이름을 가진, 단일한 `Int` 매개 변수가 있습니다. 이 매개 변수에 전달한 인자 값은 '반환한 증가기 (incrementer) 를 호출할 때마다 `runningTotal` 을 얼마나 증가해야 하는 지' 지정합니다. `makeIncrementer` 함수는, 실제 증가 작업을 수행하는, `incrementer` 라는 중첩 함수를 정의합니다. 이 함수는 단순히 `amount` 를 `runningTotal` 에 더하고, 결과를 반환합니다.

따로 떼어내서 고려할 땐, `incrementer()` 중첩 함수가 특이해 보일 지도 모릅니다:

```swift
func incrementer() -> Int {
  runningTotal += amount
  return runningTotal
}
```

`incrementer()` 함수는 어떤 매개 변수도 가지지 않는데, 그럼에도 함수 본문 안에서 `runningTotal` 과 `amount` 를 참조합니다. 이는 주위 함수로부터 `runningTotal` 과 `amount` 의 _참조 (reference)_ 를 붙잡아서 자신의 함수 본문에서 사용함으로써 이를 합니다. 참조로 붙잡는 건 `makeIncrementer` 호출이 끝났을 때도 `runningTotal` 과 `amount` 가 사라지지 않도록 보장하며, 다음 번 `incrementer` 함수 호출 시에도 `runningTotal` 이 사용 가능하도록 보장합니다.

> 최적화로써, 클로저가 해당 값을 변경하지 않고, 클로저 생성 후 값이 변경되지 않는다면, 스위프트가 값의 _복사본 (copy)_ 을 대신 붙잡고 저장할 수도 있습니다.
>
> 더 이상 필요없을 때 변수를 처분하는 것과 엮인 모든 메모리 관리도 스위프트가 처리합니다.

다음은 `makeIncrementer` 의 실제 사례입니다:

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
```

이 예제는 '매 번 호출할 때마다 `runningTotal` 변수에 `10` 을 더하는 증가기 (incrementer) 함수' 에 대한 참조를 `incrementalByTen` 이라는 상수에 설정합니다.  함수를 여러 번 호출하여 이 동작을 실제로 봅시다:

```swift
incrementByTen()
// 10 이라는 값을 반환함
incrementByTen()
// 20 이라는 값을 반환함
incrementByTen()
// 30 이라는 값을 반환함
```

두 번째 증가기를 생성하면, 이는 자신만 저장한 새로운, 별도의 `runningTotal` 변수에 대한 참조를 가질 겁니다:

```swift
let incrementBySeven = makeIncrementer(forIncrement: 7)
incrementalBySeven()
// 7 이라는 값을 반환함
```

원본 증가기 (`incrementByTen`) 를 다시 호출하면 자신의 `runningTotal` 변수가 계속 증가하며, `incrementBySeven` 이 붙잡은 변수에는 영향을 주지 않습니다:

```swift
incrementByTen()
// 40 이라는 값을 반환함
```

> 클로저를 클래스 인스턴스 속성에 할당했는데, 클로저가 해당 인스턴스나 그의 멤버를 참조함으로써 이를 붙잡았다면, 클로저와 인스턴스 사이에는 '강한 참조 순환 (strong reference cycles)' 이 생성됩니다. 스위프트는 _붙잡을 목록 (capture lists)_ 를 사용해서 이러한 강한 참조 순환을 끊습니다. 더 많은 정보는, [Strong Reference Cycles for Closures (클로저의 강한 참조 순환)]({% post_url 2020-06-30-Automatic-Reference-Counting %}#strong-reference-cycles-for-closures-클로저의-강한-참조-순환) 을 보도록 합니다.

### Closures Are Reference Types (클로저는 참조 타입입니다)

위 예제에서, `incrementBySeven` 과 `incrementByTen` 은 상수지만, 이 상수를 참조하는 클로저는 자신이 붙잡은 `runningTotal` 변수를 여전히 증가할 수 있습니다. 이는 함수와 클로저가 _참조 타입 (reference types)_ 이기 때문입니다.

함수나 클로저를 상수나 변수에 할당할 때마다, 실제로는 해당 상수나 변수가 함수나 클로저의 _참조 (reference)_ 가 되도록 설정하고 있는 것입니다. 위 예제에서 상수인 것은, 클로저 자체의 내용이 아닌, `incrementByTen` 이 _참조할 (refers to)_ 클로저를 선택하는 것입니다.[^refer-to-constant]

이는 두 서로 다른 상수나 변수에 클로저를 할당하면, 이 상수나 변수 둘 다 동일한 클로저를 참조한다는 의미이기도 합니다.

```swift
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 50 이라는 값을 반환함

incrementByTen()
// 60 이라는 값을 반환함
```

위 예제는 `alsoIncrementByTen` 호출이 `incrementByTen` 호출과 똑같다는 걸 보여줍니다. 둘 다 동일한 클로저를 참조하기 때문에, 둘 다 증가하며 동일한 총 누적 값을 반환합니다.

### Escaping Closures (벗어나는 클로저)

함수 인자로 전달했지만, 함수 반환 후에 클로저를 호출할 때, 클로저가 함수를 _벗어난다 (escape)_ 라고 말합니다.[^escape] 자신의 매개 변수 중 하나로 클로저를 취하는 함수를 선언할 때, 매개 변수 타입 앞에 `@escaping` 을 작성하면 벗어나도록 허용한 클로저라고 지시할 수 있습니다.

클로저가 벗어날 수 있는 한 가지 방법은 함수 밖에서 정의한 변수에 저장하는 것입니다. 한 예로, '비동기 (asynchronous) 연산' 을 시작하는 수많은 함수들이 클로저 인자를 완료 처리자로 취합니다. 함수는 연산 시작 후에 반환하지만, 클로저는 연산을 완료할 때까지 호출되지 않습니다-나중에 호출하려면, 클로저가 벗어날 필요가 있습니다. 예를 들면 다음과 같습니다:

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
  completionHandlers.append(completionHandler)
}
```

`someFunctionWithEscapingClosure(_:)` 함수는 자신의 인자로 클로저를 취하고 이를 함수 밖에서 선언한 배열에 추가합니다. 이 함수의 매개 변수를 `@escaping` 이라고 표시하지 않으면, 컴파일-시간 에러를 가질 것입니다.

벗어나는 클로저가 `self` 를 참조할 때 `self` 가 클래스 인스턴스를 참조하는 경우엔 특별한 주의가 필요합니다. 벗어나는 클로저에서 `self` 를 붙잡는 건 '강한 참조 순환' 을 생성하는 사고를 만들기가 쉽습니다. 참조 순환에 대한 정보는, [Automatic Reference Counting (자동 참조 카운팅)]({% post_url 2020-06-30-Automatic-Reference-Counting %}) 장을 보도록 합니다.

보통은, 클로저 본문에서 사용함으로써 클로저가 변수를 암시적으로 붙잡지만, 이 경우엔 명시적일 필요가 있습니다.[^need-to-be-explicit] `self` 를 붙잡고 싶으면, 사용할 때 `self` 를 명시하거나, 클로저의 '붙잡을 목록 (capture list)' 에 `self` 를 포함합니다.[^explicit] `self` 를 명시하는 건 자신의 의도를 표현하게 하여, 참조 순환이 없다고 확정한 걸 다시 생각나게 합니다. 예를 들어, 아래 코드에서, `someFunctionWithEscapingClosure(_:)` 에 전달한 클로저는 `self` 를 명시적으로 참조합니다. 이와 대조적으로, `someFunctionWithNonescapingClosure(_:)` 에 전달한 클로저는 '벗어나지 않는 (nonescaping) 클로저' 이며, 이는 `self` 를 암시적으로 참조할 수 있다는 의미입니다.

```swift
someFunctionWithNonescapingClosure(closure: () -> Void) {
  closure()
}

class SomeClass {
  var x = 0
  func doSomething() {
    someFunctionWithEscapingClosure { self.x = 100 }
    someFunctionWithNonescapingClosure { x = 200 }
  }
}

let instance = SomeClass()
instance.doSomething()
print(instance.x)
// "200" 을 인쇄함

completionHandlers.first?()
print(instance.x)
// "100" 을 인쇄함
```

다음은 클로저의 '붙잡을 목록' 에 `self` 를 포함함으로써 붙잡은 다음, `self` 를 암시적으로 참조하는, `doSomething()` 버전입니다:

```swift
class SomeOtherClass {
  var x = 10
  func doSomething() {
    someFunctionWithEscapingClosure { [self] in x = 100 }
    someFunctionWithNonescapingClosure { x = 200 }
  }
}
```

`self` 가 구조체나 열거체 인스턴스라면, 항상 암시적으로 `self` 를 참조할 수 있습니다.[^implicitly] 하지만, `self` 가 구조체나 열거체 인스턴스일 때는 벗어나는 클로저가 `self` 에 대한 '변경 가능한 참조 (mutable reference)' 를 붙잡을 수 없습니다. [Structures and Enumerations Are Value Types (구조체와 열거체는 값 타입입니다)]({% post_url 2020-04-14-Structures-and-Classes %}#structures-and-enumerations-are-value-types-구조체와-열거체는-값-타입입니다) 에서 설명한 것처럼, 구조체와 열거체는 '변경 가능성을 공유하는 (shared mutability) 걸' 허용하지 않습니다.

```swift
struct SomeStruct {
  var x = 10
  mutating func doSomething() {
    someFunctionWithNonescapingClosure { x = 200 }  // 됨
    someFunctionWithEscapingClosure { x = 100 }     // 에러
  }
}
```

위 예제에서 `someFunctionWithEscapingClosure` 함수를 호출하는 건 '변경 (mutating) 메소드' 안에 있어서, `self` 가 변경 가능하기 때문에, 에러입니다. 이는 '벗어나는 클로저는 구조체의 `self` 를 변경 가능한 참조로 붙잡을 수 없다' 는 규칙을 위반하는 것입니다.

### Autoclosures (자동 클로저)

_자동 클로저 (autoclosure)_ 는 함수 인자로 전달한 표현식을 포장하여 자동으로 생성되는 클로저입니다. 이는 어떤 인자도 취하지 않으며, 호출할 땐, 자기 안에 포장된 표현식 값을 반환합니다. 이런 구문상의 편의는 명시적인 클로저 대신 보통의 표현식을 작성함으로써 함수 매개 변수 주변의 중괄호를 생략하게 해줍니다.

자동 클로저를 취하는 함수를 _호출(call)_ 하는 건 흔하지만, 그런 종류의 함수를 _구현 (implement)_ 하는 건 흔하지 않습니다. 예를 들어, `assert(condition:message:file:line:)` 함수는 자신의 `condition` 과 `message` 매개 변수로 자동 클로저를 취하는데; `condition` 매개 변수는 '디버그 제작 (debug build)' 일 때만 평가하고[^evaluated] `message` 매개 변수는 `condition` 이 `false` 일 때만 평가합니다.

자동 클로저는, 클로저를 호출하기 전까지 안에 있는 코드를 실행하지 않기 때문에[^run], (값) 평가를 늦춰 줍니다. 평가를 늦추는 건, 해당 코드를 평가할 시점을 제어하게 해주기 때문에, 부작용 (side effects)[^side-effect] 이 있거나 계산 비용이 비싼 코드에서 유용합니다. 아래 코드는 클로저가 평가를 늦추는 방법을 보여줍니다:

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)
// "5" 를 인쇄함

let customerProvider = { customersInLine.remove(at: 0) }
print(customersInLine.count)
// "5" 를 인쇄함

print("Now serving \(customerProvider())!")
// "Now serving Chris!" 를 인쇄함
Print(customersInLine.count)
// "4" 를 인쇄함
```

클로저 안의 코드가 `customersInLine` 배열의 첫 번째 원소를 제거하고 있을지라도, 클로저를 실제로 호출하기 전까진 배열 원소를 제거하지 않습니다. 클로저를 절대로 호출하지 않는다면, 클로저 안의 표현식을 절대로 평가하지 않으며, 배열 원소도 절대 제거하지 않는다는 의미입니다. `customerProvider` 타입은 `String` 이 아니라-매개 변수가 없고 문자열을 반환하는 함수인-`() -> String` 라는 걸 기억하기 바랍니다.

클로저를 함수 인자로 전달할 땐 '늦춰진 평가' 와 똑같이 작동합니다.

```swift
// customersInLine 은 ["Alex", "Ewa", "Barry", "Daniella"] 임
func serve(customer customerProvider: () -> String) {
  print("Now serving \(customerProvider())!")
}
serve(customer: { customersInLine.remove(at: 0) })
// "Now serving Alex!" 를 인쇄함
```

위에 나열한 `serve(customer:)` 함수는 고객 이름을 반환하는 명시적인 클로저를 취합니다. 아래의 `serve(customer:)` 함수 버전은 동일한 연산을 수행하지만, 매개 변수 타입을 `@autoclosure` 특성으로 표시함으로써, 명시적인 클로저 대신, 자동 클로저를 취합니다. 이제 함수가 마치 클로저 대신 `String` 인자를 취하는 것처럼 호출할 수 있습니다. `customerProvider` 매개 변수의 타입을 `@autoclosure` 특성으로 표시했기 때문에, 자동으로 인자를 클로저로 변환합니다.

```swift
// customersInLine 은 ["Ewa", "Barry", "Daniella"] 임
func serve(customer customerProvider: @autoclosure () -> String) {
  print("Now serving \(customerProvider())!")
}

serve(customer: customersInLine.remove(at: 0))
// "Now serving Ewa!" 를 인쇄함
```

> 자동 클로저를 남용하면 코드를 이해하기가 어려워집니다. (문맥) 상황과 함수 이름은 평가를 미루고 있다는 걸 명확하게 해야 합니다.

자동 클로저가 벗어나도록 (escape) 허용하고 싶으면, `@autoclosure` 와 `@escaping` 특성 둘 다 사용합니다. `@escaping` 특성은 위의 [Escaping Closures (벗어나는 클로저)](#escaping-closures-벗어나는-클로저) 부분에서 설명합니다.

```swift
// customersInLine 은 [Barry", "Daniella"] 임
var customerProviders: [() -> String] = []

func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
  customerProviders.append(customerProvider)
}

collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")
// "Collected 2 closures." 를 인쇄함
for customerProvider in customerProviders {
  print("Now serving \(customerProvider())!")
}
// "Now serving Barry!" 를 인쇄함
// "Now serving Daniella!" 를 인쇄함
```

위 코드에서, `collectCustomerProviders(_:)` 함수는, `customerProvider` 인자로 전달한 클로저를 호출하는 대신, `customerProviders` 배열에 클로저를 덧붙입니다. 배열은 함수 영역 밖에 선언한 것이며, 이는 배열 안의 클로저는 함수 반환 후에도 실행할 수 있다는 의미입니다. 그 결과, `customerProvider` 인자 값이 함수 영역을 벗어날 수 있게 반드시 허용해야 합니다.

### 다음 장

[Enumerations (열거체) > ]({% post_url 2020-06-13-Enumerations %})

### 참고 자료

[^Closures]: 원문은 [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)에서 확인할 수 있습니다.

[^global-nested-function]: 수학에서의 집합으로 비유하면, 스위프트의 전역 함수와 중첩 함수는 '클로저의 부분 집합' 이라고 볼 수 있습니다.

[^shorthand]: '짧게 줄인 인자 이름' 은 클로저 안에서 사용할 수 있는 `$0` 등을 말합니다. 이에 대해서는 뒤에서 자세히 설명합니다.

[^trailing]: '뒤에 딸린 (trailing) 클로저 구문' 은, 클로저가 함수의 마지막 인자일 경우, 클로저를 함수 뒤에 딸려있게 꺼내는 구문입니다. 이 역시 뒤에서 자세히 설명합니다.

[^in-out]: 스위프트의 '입-출력 매개 변수 (in-out parameters)' 는 함수 내에서 값을 바꿀 수 있는 매개 변수입니다. 보다 자세한 정보는 [Functions (함수)]({% post_url 2020-06-02-Functions %}) 장의 [In-Out Parameters (입-출력 매개 변수)]({% post_url 2020-06-02-Functions %}#in-out-parameters-입-출력-매개-변수) 부분을 보도록 합니다.

[^inline-closure]: '인라인 클로저 (inline closure)' 는 해당 코드 위치에 직접 입력한 클로저입니다. 해당 코드 줄 안에 (in-line) 넣은 클로저' 라고 볼 수 있습니다.

[^constants]: 스위프트에서 함수와 클로저의 매개 변수는 항상 상수이기 때문에 클로저 안에서 변경할 수 없습니다. 그래서 본문의 `var number = number` 처럼 매개 변수 `number` 를 다시 변수 `number ` 에 할당하는 것입니다. '입-출력 (in-out) 매개 변수' 는 원본 값 자체를 변경해도 되는 (또는 원본 값 자체를 변경하는 게 더 효율적인) 특수한 경우에 사용합니다.

[^dispatch]: 애플 운영체제의 '급파 (dispatch)' 는 '동시성 (Concurrent)[^concurrent] 컴퓨팅' 과 관련이 있습니다. 여기서 `loadPicture(from:completion:onFailure:)` 함수가 작업을 백그라운드로 급파 (dispatch) 하는 건, 함수를 호출한 다음 결과를 기다리지 않고 곧바로 다른 작업을 하며, 실제 다운로드 작업은 별도 백그라운드 쓰레드에서 진행한다는 의미입니다. 애플 운영체제의 '동시성 컴퓨팅' 에 대한 더 자세한 내용은, [Concurrency (동시성)]({% post_url 2021-06-10-Concurrency %}) 장을 보도록 합니다. 

[^concurrent]: 'concurrent' 는 '동시성' 이라고도 합니다. 보다 자세한 내용은 위키피디아의 [Concurrent computing](https://en.wikipedia.org/wiki/Concurrent_computing) 항목과 [병행 컴퓨팅](https://ko.wikipedia.org/wiki/병행_컴퓨팅) 항목을 보도록 합니다.

[^capture-scope]: 아래 부분에 이어지는 설명을 보면, 스위프트 클로저는 '기본적으론 해당 상수와 변수를 참조로 붙잡지만, 최적화에 따라 이들을 복사하기도 한다' 는 것을 알 수 있습니다. 따라서 원본 영역이 존재하지 않더라도 이들을 참조하고 수정할 수 있습니다. 참고로 클로저는 클래스와 같이 참조 타입이라 '메모리의 자유 저장소 (free storage; 또는 heap) 영역' 에 생성됩니다. 

[^array-of-strings]: `sorted(by:)` 메소드를 `names` 의 멤버 함수로써 호출하고 있습니다.

[^evaluated]: '평가한다 (evaluate)' 는 건 표현식을 실행하여 특정 값을 구한다는 의미입니다. 함수를 실행하는 건 '호출 (call)' 이라고 하고, 표현식을 실행하는 건 '평가 (evaluation)' 라고 합니다. 값 '평가 (evaluation)' 에 대한 더 자세한 정보는, 위키피디아의 [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy) 항목과 [평가 전략 (컴퓨터 프로그래밍)](https://ko.wikipedia.org/wiki/평가_전략_(컴퓨터_프로그래밍)) 항목을 보도록 합니다.

[^mapped-value]: '대체 맵핑 값 (alternative mapped value)' 에서의 '맵핑' 은 수학에서 말하는 '맵핑' 개념과 같습니다. '맵핑' 을 직역하면 '대응 관계' 정도로 옮길 수 있습니다. '맵핑' 에 대한 더 자세한 정보는, 위키피디아의 [Map (mathematics)](https://en.wikipedia.org/wiki/Map_(mathematics) 항목과 [맵핑 (수학)](https://ko.wikipedia.org/wiki/맵핑_(수학) 항목을 보도록 합니다.

[^constants]: 함수와 클로저의 매개 변수는 항상 상수이기 때문에, `var number = number` 처럼, 매개 변수 `number` 를 다시 변수 `number ` 에 할당해야 수정할 수 있습니다. 입-출력 매개 변수는 원본 값 자체를 변경해도 되는 (또는 원본 값 자체를 변경하는 게 더 효율적인) 특수한 경우에만 사용합니다.

[^completion-handler]: '완료 처리자 (completion handler)' 는 해당 비동기 연산을 완료한 후에 호출되는 클로저를 말합니다. 

[^dispatch]: 애플 **OS** 에서 '급파 (dispatch)' 는 동시성 (concurrent) 과 관련이 있습니다. 여기서 `loadPicture(from:completion:onFailure:)` 함수가 작업을 백그라운드로 급파한다는 건, 함수를 호출한 다음 결과를 기다리지 않고 곧바로 다른 작업을 하며, 실제 다운로드 작업은 별도의 백그라운드 쓰레드에서 진행한다는 걸 의미합니다. 애플 ***OS** 의 동시성에 대해서는, [Concurrency (동시성)]({% post_url 2021-06-10-Concurrency %}) 장을 보기 바랍니다. 그 외에, 동시성 자체에 대한 더 자세한 정보는, 위키피디아의 [Concurrent computing](https://en.wikipedia.org/wiki/Concurrent_computing) 항목과 [병행 컴퓨팅](https://ko.wikipedia.org/wiki/병행_컴퓨팅) 항목을 참고하기 바랍니다.

[^capture-scope]: 기본적으로는, 스위프트 클로저가 상수와 변수를 참조로 붙잡지만, 최적화에 따라, 복사도 합니다. 따라서, 원본 영역과는 상관없이 참조하고 수정할 수 있습니다. 클래스 처럼, 클로저도 참조 타입이라 메모리 안의 자유 저장소 영역 (free storage; 또는 heap) 에 생성됩니다. 

[^only-trailing-closure]: 클로저 표현식이 함수나 메소드의 유일한 인자인 경우, 해당 클로저 표현식은 자동으로 뒤에 딸린 클로저가 될 수 있습니다.

[^guaranteed]: 이 예제의 `number % 10` 는 결과가 항상 `0...9` 사이의 정수이므로, 유효한 키임을 보증할 수 있습니다.

[^factory-method]:  스위프트에서 `make` 로 시작하는 함수나 메소드는 보통 '공장 메소드 패턴 (factory method pattern)' 을 사용하는 '공장 메소드 (factory method)' 입니다. 물론 이 예제에서 `makeIncrementer` 가 '객체' 를 반환하고 있는 것은 아니지만, 현대 프로그래밍에서 함수도 사실상 객체이므로, 이 역시 '공장 메소드' 의 일종이라고 볼 수 있습니다. 공장 메소드에 `make` 를 사용하는 것은 [API Design Guidelines (API 설계 지침)]({% post_url 2020-09-15-API-Design-Guidelines %}) 에 있는 [Strive for Fluent Usage (자연스러운 사용법이 되도록 노력하기)]({% post_url 2020-09-15-API-Design-Guidelines %}#strive-for-fluent-usage-자연스러운-사용법이-되도록-노력하기) 부분을 보도록 합니다. '공장 메소드' 및 '공장 메소드 패턴' 에 대한 더 자세한 정보는 위키피디아의 [Factory method pattern](https://en.wikipedia.org/wiki/Factory_method_pattern) 항목과 [팩토리 메서드 패턴](https://ko.wikipedia.org/wiki/팩토리_메서드_패턴) 항목을 보도록 합니다.

[^refer-to-constant]: 이는 `A` 를 참조하기로 선택한 클로저를 `B` 로 참조하게 바꿀 순 없지만, `A` 의 내용은 바꿀 수 있다는 의미입니다.

[^need-to-be-explicit]: 앞서 말한대로, 암시적으로 붙잡으면 강한 참조 순환을 만들게 되므로, 명시적으로 붙잡아서 '참조 순환' 을 만들지 않도록 하는 것입니다.

[^explicit]: `self` 를 명시적으로 사용한다는 것은 클로저 내부에서 `{ self.x = 1 }` 처럼 `self` 를 명시적으로 붙여주는 것을 말하며, 붙잡을 목록에 `self` 를 포함한다는 것은 `{ [self] in x = 1 }` 처럼 `self` 를 클로저 앞부분에 명시하는 것을 말합니다. 이 두 가지 방법 중에서 한 가지를 선택해서 사용하면 된다는 의미입니다.

[^run]: '실행' 이라는 용어에는 'run' 과 'execution' 두 가지가 있는데, 스택오버플로우의 [Difference between running and executing states of a process in the Operating System](https://stackoverflow.com/questions/55991011/difference-between-running-and-executing-states-of-a-process-in-the-operating-sy) 항목에 따르면, 'run' 은 '프로그램을 메모리로 불러와서 process 상태로 만드는 것' 이고, 'execute' 는 '프로그램이 CPU 를 사용하게 하는 것' 을 의미합니다. 즉, 여기서 코드를 실행하지 않는다는 건 메모리조차 사용하지 않는다는 의미입니다. 

[^side-effect]: [Expressions (표현식)]({% post_url 2020-08-19-Expressions %}) 맨 앞에서 설명한 것처럼, 컴퓨터 용어에서의 '부작용 (side effect)' 은 부수 효과 정도로 이해하는 것이 좋습니다.
